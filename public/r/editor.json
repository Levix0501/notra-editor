{
  "name": "editor",
  "version": "0.0.0",
  "description": "A Notion-like rich text editor component for React",
  "files": [
    {
      "path": "core/editor.tsx",
      "content": "import '../styles/editor.css';\n\nimport { Placeholder } from '@tiptap/extensions';\nimport { EditorContent, EditorContext, useEditor } from '@tiptap/react';\n\nimport { EditorExtensions } from '../extensions/editor';\nimport { getDictionary, I18nProvider } from '../i18n';\nimport { BlockDragHandle } from '../ui/drag-handle';\nimport { FixedToolbar } from '../ui/fixed-toolbar';\n\nimport type { Locale } from '../i18n';\n\nexport interface EditorProps {\n\tcontent?: string;\n\tonChange?: (content: string) => void;\n\tlocale?: Locale;\n}\n\nexport function Editor({ content = '', onChange, locale = 'en' }: EditorProps) {\n\tconst dictionary = getDictionary(locale);\n\n\tconst editor = useEditor({\n\t\tcontent,\n\t\teditorProps: {\n\t\t\tattributes: {\n\t\t\t\tautocomplete: 'off',\n\t\t\t\tautocorrect: 'off',\n\t\t\t\tautocapitalize: 'off',\n\t\t\t\t'aria-label': dictionary['editor.ariaLabel'],\n\t\t\t\tclass:\n\t\t\t\t\t'flex-1 px-4 sm:px-[max(64px,calc(50%-375px))] pb-[30vh] pt-15 sm:pt-23 outline-none'\n\t\t\t}\n\t\t},\n\t\textensions: [\n\t\t\t...EditorExtensions,\n\t\t\tPlaceholder.configure({\n\t\t\t\tplaceholder: dictionary['placeholder.default']\n\t\t\t})\n\t\t],\n\t\tonUpdate: ({ editor }) => onChange?.(editor.getHTML())\n\t});\n\n\treturn (\n\t\t<div className=\"notra-editor\">\n\t\t\t<I18nProvider locale={locale}>\n\t\t\t\t<EditorContext.Provider value={{ editor }}>\n\t\t\t\t\t<FixedToolbar />\n\n\t\t\t\t\t<EditorContent className=\"relative\" editor={editor}>\n\t\t\t\t\t\t<BlockDragHandle />\n\t\t\t\t\t</EditorContent>\n\t\t\t\t</EditorContext.Provider>\n\t\t\t</I18nProvider>\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "core/viewer.tsx",
      "content": "import '../styles/editor.css';\n\nimport { JSONContent } from '@tiptap/core';\nimport { renderToReactElement } from '@tiptap/static-renderer/pm/react';\nimport { JSX } from 'react';\n\nimport { ViewerExtensions } from '../extensions/viewer';\n\nexport interface ViewerProps {\n\tcontent: JSONContent;\n}\n\nexport function Viewer({ content }: ViewerProps): JSX.Element {\n\treturn (\n\t\t<div className=\"notra-editor\">\n\t\t\t{renderToReactElement({ extensions: ViewerExtensions, content })}\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "extensions/code-block-base.ts",
      "content": "import { CodeBlockLowlight } from '@tiptap/extension-code-block-lowlight';\nimport { all, createLowlight } from 'lowlight';\n\nexport const lowlight = createLowlight(all);\n\nexport const CodeBlockBase = CodeBlockLowlight.configure({\n\tlowlight\n});\n"
    },
    {
      "path": "extensions/code-block.tsx",
      "content": "import { TextSelection } from '@tiptap/pm/state';\nimport {\n\tNodeViewContent,\n\tNodeViewWrapper,\n\tReactNodeViewRenderer\n} from '@tiptap/react';\nimport { useEffect } from 'react';\n\nimport { CodeBlockBase } from './code-block-base';\nimport { CopyButton } from '../ui/code-block-copy-button';\nimport {\n\tLanguageSelect,\n\tresolveLanguageAlias\n} from '../ui/code-block-language-select';\n\nimport type { NodeViewProps } from '@tiptap/react';\n\nfunction CodeBlockNodeView({ node, updateAttributes }: NodeViewProps) {\n\tconst rawLanguage = node.attrs.language || '';\n\tconst language = resolveLanguageAlias(rawLanguage);\n\n\t// Normalize the stored attribute when an alias (e.g. \"js\") resolves to a full name.\n\t// Deferred via microtask to avoid flushSync during React render cycle.\n\tuseEffect(() => {\n\t\tif (rawLanguage && language !== rawLanguage) {\n\t\t\tqueueMicrotask(() => updateAttributes({ language }));\n\t\t}\n\t}, [rawLanguage, language, updateAttributes]);\n\n\treturn (\n\t\t<NodeViewWrapper>\n\t\t\t<div className=\"relative\">\n\t\t\t\t<pre className=\"hljs !p-0\">\n\t\t\t\t\t<div className=\"flex h-9 items-center justify-between px-2\">\n\t\t\t\t\t\t<LanguageSelect\n\t\t\t\t\t\t\tlanguage={language || 'auto'}\n\t\t\t\t\t\t\tonLanguageChange={(lang) => updateAttributes({ language: lang })}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<CopyButton value={node.textContent} />\n\t\t\t\t\t</div>\n\t\t\t\t\t<code className=\"!p-0\">\n\t\t\t\t\t\t<NodeViewContent className=\"scrollbar-hide max-h-[500px] overflow-auto p-4 pt-0\" />\n\t\t\t\t\t</code>\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t</NodeViewWrapper>\n\t);\n}\n\nexport const CodeBlock = CodeBlockBase.extend({\n\taddKeyboardShortcuts() {\n\t\treturn {\n\t\t\t...this.parent?.(),\n\t\t\t// Select only the code block content instead of the entire document\n\t\t\t'Mod-a': ({ editor }) => {\n\t\t\t\tif (!editor.isActive('codeBlock')) return false;\n\n\t\t\t\tconst { $anchor } = editor.state.selection;\n\n\t\t\t\t// Walk up the node tree to find the codeBlock node\n\t\t\t\tfor (let d = $anchor.depth; d > 0; d--) {\n\t\t\t\t\tif ($anchor.node(d).type.name === 'codeBlock') {\n\t\t\t\t\t\tconst start = $anchor.start(d);\n\t\t\t\t\t\tconst end = start + $anchor.node(d).content.size;\n\t\t\t\t\t\tconst { tr } = editor.state;\n\n\t\t\t\t\t\ttr.setSelection(TextSelection.create(tr.doc, start, end));\n\t\t\t\t\t\teditor.view.dispatch(tr);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tTab: ({ editor }) => {\n\t\t\t\tif (!editor.isActive('codeBlock')) return false;\n\n\t\t\t\tconst { state } = editor;\n\t\t\t\tconst { from, to } = state.selection;\n\t\t\t\tconst { tr, doc } = state;\n\n\t\t\t\t// Find the start of the current line by scanning backwards for newline\n\t\t\t\tconst textBefore = doc.textBetween(\n\t\t\t\t\tdoc.resolve(from).start(),\n\t\t\t\t\tfrom,\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t\tconst lastNewline = textBefore.lastIndexOf('\\n');\n\t\t\t\tconst lineStart =\n\t\t\t\t\tdoc.resolve(from).start() +\n\t\t\t\t\t(lastNewline === -1 ? 0 : lastNewline + 1);\n\n\t\t\t\ttr.insertText('  ', lineStart);\n\t\t\t\t// Shift cursor to account for the inserted spaces\n\t\t\t\ttr.setSelection(TextSelection.create(tr.doc, from + 2, to + 2));\n\t\t\t\teditor.view.dispatch(tr);\n\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\t'Shift-Tab': ({ editor }) => {\n\t\t\t\tif (!editor.isActive('codeBlock')) return false;\n\n\t\t\t\tconst { state } = editor;\n\t\t\t\tconst { from, to } = state.selection;\n\t\t\t\tconst { tr, doc } = state;\n\n\t\t\t\tconst textBefore = doc.textBetween(\n\t\t\t\t\tdoc.resolve(from).start(),\n\t\t\t\t\tfrom,\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t\tconst lastNewline = textBefore.lastIndexOf('\\n');\n\t\t\t\tconst lineStart =\n\t\t\t\t\tdoc.resolve(from).start() +\n\t\t\t\t\t(lastNewline === -1 ? 0 : lastNewline + 1);\n\n\t\t\t\t// Check leading spaces at line start and remove up to 2\n\t\t\t\tconst lineText = doc.textBetween(\n\t\t\t\t\tlineStart,\n\t\t\t\t\tMath.min(lineStart + 2, doc.content.size),\n\t\t\t\t\tundefined\n\t\t\t\t);\n\n\t\t\t\tlet removeCount = 0;\n\n\t\t\t\tif (lineText.startsWith('  ')) {\n\t\t\t\t\tremoveCount = 2;\n\t\t\t\t} else if (lineText.startsWith(' ')) {\n\t\t\t\t\tremoveCount = 1;\n\t\t\t\t}\n\n\t\t\t\tif (removeCount === 0) return true;\n\n\t\t\t\ttr.delete(lineStart, lineStart + removeCount);\n\t\t\t\t// Shift cursor back, but don't go before line start\n\t\t\t\tconst newFrom = Math.max(lineStart, from - removeCount);\n\t\t\t\tconst newTo = Math.max(lineStart, to - removeCount);\n\n\t\t\t\ttr.setSelection(TextSelection.create(tr.doc, newFrom, newTo));\n\t\t\t\teditor.view.dispatch(tr);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t},\n\taddNodeView() {\n\t\treturn ReactNodeViewRenderer(CodeBlockNodeView);\n\t}\n});\n"
    },
    {
      "path": "extensions/editor.ts",
      "content": "import { TrailingNode } from '@tiptap/extensions';\n\nimport { CodeBlock } from './code-block';\nimport { SharedExtensions } from './shared';\nimport { EditorUiState } from './ui-state';\n\nexport const EditorExtensions = [\n\t...SharedExtensions,\n\tCodeBlock,\n\tEditorUiState,\n\tTrailingNode.configure({\n\t\tnode: 'paragraph'\n\t})\n];\n"
    },
    {
      "path": "extensions/horizontal-rule.ts",
      "content": "import TiptapHorizontalRule from '@tiptap/extension-horizontal-rule';\nimport { mergeAttributes } from '@tiptap/react';\n\n// Wrapper div enables better cursor positioning around the rule\nexport const HorizontalRule = TiptapHorizontalRule.extend({\n\trenderHTML() {\n\t\treturn [\n\t\t\t'div',\n\t\t\tmergeAttributes(this.options.HTMLAttributes, { 'data-type': this.name }),\n\t\t\t['hr']\n\t\t];\n\t}\n});\n"
    },
    {
      "path": "extensions/shared.ts",
      "content": "import { Highlight } from '@tiptap/extension-highlight';\nimport { Subscript } from '@tiptap/extension-subscript';\nimport { Superscript } from '@tiptap/extension-superscript';\nimport { TaskItem } from '@tiptap/extension-task-item';\nimport { TaskList } from '@tiptap/extension-task-list';\nimport { TextAlign } from '@tiptap/extension-text-align';\nimport { Typography } from '@tiptap/extension-typography';\n\nimport { HorizontalRule } from './horizontal-rule';\nimport { Starter } from './starter';\n\nexport const SharedExtensions = [\n\tStarter,\n\tHorizontalRule,\n\tTaskList,\n\tTaskItem.configure({ nested: true }),\n\tSuperscript,\n\tSubscript,\n\tHighlight,\n\tTypography,\n\tTextAlign.configure({ types: ['heading', 'paragraph'] })\n];\n"
    },
    {
      "path": "extensions/starter.ts",
      "content": "import { StarterKit } from '@tiptap/starter-kit';\n\nexport const Starter = StarterKit.configure({\n\thorizontalRule: false,\n\tcodeBlock: false,\n\tdropcursor: { width: 2 },\n\tlink: {\n\t\topenOnClick: false,\n\t\tautolink: true,\n\t\tdefaultProtocol: 'https',\n\t\tHTMLAttributes: {\n\t\t\trel: 'noopener noreferrer',\n\t\t\ttarget: '_blank'\n\t\t}\n\t}\n});\n"
    },
    {
      "path": "extensions/ui-state.ts",
      "content": "import { Extension } from '@tiptap/core';\n\nexport interface UiState {\n\tisDragging: boolean;\n}\n\ndeclare module '@tiptap/core' {\n\tinterface Commands<ReturnType> {\n\t\teditorUiState: {\n\t\t\tsetIsDragging: (value: boolean) => ReturnType;\n\t\t};\n\t}\n\n\tinterface Storage {\n\t\teditorUiState: UiState;\n\t}\n}\n\nexport const DEFAULT_STATE: UiState = {\n\tisDragging: false\n};\n\nexport const EditorUiState = Extension.create({\n\tname: 'editorUiState',\n\n\taddStorage() {\n\t\treturn { ...DEFAULT_STATE };\n\t},\n\n\taddCommands() {\n\t\treturn {\n\t\t\tsetIsDragging:\n\t\t\t\t(value: boolean) =>\n\t\t\t\t({ editor }) => {\n\t\t\t\t\teditor.storage.editorUiState.isDragging = value;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t};\n\t}\n});\n"
    },
    {
      "path": "extensions/viewer.ts",
      "content": "import { Selection } from '@tiptap/extensions';\n\nimport { CodeBlockBase } from './code-block-base';\nimport { SharedExtensions } from './shared';\n\nexport const ViewerExtensions = [...SharedExtensions, CodeBlockBase, Selection];\n"
    },
    {
      "path": "hooks/use-blockquote.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport { TextQuote } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport const BLOCKQUOTE_SHORTCUT_KEY = 'mod+shift+b';\n\nexport interface UseBlockquoteConfig {\n\teditor?: Editor | null;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport function canToggleBlockquote(\n\teditor: Editor | null,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isNodeInSchema('blockquote', editor) ||\n\t\tisNodeTypeSelected(editor, ['image'])\n\t)\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\treturn editor.can().toggleWrap('blockquote');\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function toggleBlockquote(editor: Editor | null): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleBlockquote(editor)) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\tview.dispatch(tr);\n\t\t\tstate = view.state;\n\t\t}\n\n\t\tconst selection = state.selection;\n\n\t\tlet chain = editor.chain().focus();\n\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tconst toggle = editor.isActive('blockquote')\n\t\t\t? chain.lift('blockquote')\n\t\t\t: chain.wrapIn('blockquote');\n\n\t\ttoggle.run();\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema('blockquote', editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleBlockquote(editor);\n\t}\n\n\treturn true;\n}\n\nexport function useBlockquote(config?: UseBlockquoteConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config || {};\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canToggle = canToggleBlockquote(activeEditor);\n\tconst isActive = activeEditor?.isActive('blockquote') ?? false;\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, hideWhenUnavailable]);\n\n\tconst handleToggle = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleBlockquote(activeEditor);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, onToggled]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle,\n\t\tlabel: dictionary['blockquote.label' as keyof typeof dictionary],\n\t\tshortcutKeys: BLOCKQUOTE_SHORTCUT_KEY,\n\t\tIcon: TextQuote as LucideIcon\n\t};\n}\n"
    },
    {
      "path": "hooks/use-code-block.ts",
      "content": "import { CodeSquare } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport { isNodeInSchema, isNodeTypeSelected } from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport const CODE_BLOCK_SHORTCUT_KEY = 'mod+alt+c';\n\nexport interface UseCodeBlockConfig {\n\teditor?: Editor | null;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport function canToggleCodeBlock(\n\teditor: Editor | null,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isNodeInSchema('codeBlock', editor) ||\n\t\tisNodeTypeSelected(editor, ['image'])\n\t)\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\treturn editor.can().toggleCodeBlock();\n\t}\n\n\treturn true;\n}\n\nexport function toggleCodeBlock(editor: Editor | null): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleCodeBlock(editor)) return false;\n\n\ttry {\n\t\teditor.chain().focus().toggleCodeBlock().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function shouldShowCodeBlockButton(props: {\n\teditor: Editor | null;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema('codeBlock', editor)) return false;\n\n\tif (hideWhenUnavailable) {\n\t\treturn canToggleCodeBlock(editor);\n\t}\n\n\treturn true;\n}\n\nexport function useCodeBlock(config?: UseCodeBlockConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config || {};\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canToggle = canToggleCodeBlock(activeEditor);\n\tconst isActive = activeEditor?.isActive('codeBlock') ?? false;\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowCodeBlockButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, hideWhenUnavailable]);\n\n\tconst handleToggle = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleCodeBlock(activeEditor);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, onToggled]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle,\n\t\tlabel: dictionary['codeBlock.label' as keyof typeof dictionary],\n\t\tshortcutKeys: CODE_BLOCK_SHORTCUT_KEY,\n\t\tIcon: CodeSquare as LucideIcon\n\t};\n}\n"
    },
    {
      "path": "hooks/use-heading-dropdown-menu.ts",
      "content": "import { Heading } from 'lucide-react';\nimport { useEffect, useState } from 'react';\n\nimport {\n\theadingIcons,\n\ttype Level,\n\tisHeadingActive,\n\tcanToggle,\n\tshouldShowButton\n} from './use-heading';\nimport { useNotraEditor } from './use-notra-editor';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport interface UseHeadingDropdownMenuConfig {\n\teditor?: Editor | null;\n\tlevels?: Level[];\n\thideWhenUnavailable?: boolean;\n}\n\nexport function getActiveHeadingLevel(\n\teditor: Editor | null,\n\tlevels: Level[] = [1, 2, 3, 4, 5, 6]\n): Level | undefined {\n\tif (!editor || !editor.isEditable) return undefined;\n\n\treturn levels.find((level) => isHeadingActive(editor, level));\n}\n\nexport function useHeadingDropdownMenu(config?: UseHeadingDropdownMenuConfig): {\n\tisVisible: boolean;\n\tactiveLevel: Level | undefined;\n\tisActive: boolean;\n\tcanToggle: boolean;\n\tlevels: Level[];\n\tIcon: LucideIcon;\n} {\n\tconst {\n\t\teditor: providedEditor,\n\t\tlevels = [1, 2, 3, 4, 5, 6],\n\t\thideWhenUnavailable = false\n\t} = config || {};\n\n\tconst { editor } = useNotraEditor(providedEditor);\n\tconst [isVisible, setIsVisible] = useState(true);\n\n\tconst activeLevel = getActiveHeadingLevel(editor, levels);\n\tconst isActive = isHeadingActive(editor);\n\tconst canToggleState = canToggle(editor);\n\n\tuseEffect(() => {\n\t\tif (!editor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({ editor, hideWhenUnavailable, level: levels })\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\teditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\teditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [editor, hideWhenUnavailable, levels]);\n\n\treturn {\n\t\tisVisible,\n\t\tactiveLevel,\n\t\tisActive,\n\t\tcanToggle: canToggleState,\n\t\tlevels,\n\t\tIcon: activeLevel ? headingIcons[activeLevel] : Heading\n\t};\n}\n"
    },
    {
      "path": "hooks/use-heading.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport {\n\tHeading1,\n\tHeading2,\n\tHeading3,\n\tHeading4,\n\tHeading5,\n\tHeading6\n} from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6;\n\nexport interface UseHeadingConfig {\n\teditor?: Editor | null;\n\tlevel: Level;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const headingIcons: Record<Level, LucideIcon> = {\n\t1: Heading1,\n\t2: Heading2,\n\t3: Heading3,\n\t4: Heading4,\n\t5: Heading5,\n\t6: Heading6\n};\n\n/**\n * Checks if heading can be toggled in the current editor state\n */\nexport function canToggle(\n\teditor: Editor | null,\n\tlevel?: Level,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isNodeInSchema('heading', editor) ||\n\t\tisNodeTypeSelected(editor, ['image'])\n\t)\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\treturn level\n\t\t\t? editor.can().setNode('heading', { level })\n\t\t\t: editor.can().setNode('heading');\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Checks if heading is currently active\n */\nexport function isHeadingActive(\n\teditor: Editor | null,\n\tlevel?: Level | Level[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (Array.isArray(level)) {\n\t\treturn level.some((l) => editor.isActive('heading', { level: l }));\n\t}\n\n\treturn level\n\t\t? editor.isActive('heading', { level })\n\t\t: editor.isActive('heading');\n}\n\n/**\n * Toggles heading in the editor\n */\nexport function toggleHeading(\n\teditor: Editor | null,\n\tlevel: Level | Level[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tconst levels = Array.isArray(level) ? level : [level];\n\tconst toggleLevel = levels.find((l) => canToggle(editor, l));\n\n\tif (!toggleLevel) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\t// Convert cursor/text selection to NodeSelection for complex nodes like list items\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\tview.dispatch(tr);\n\t\t\tstate = view.state;\n\t\t}\n\n\t\tconst selection = state.selection;\n\t\tlet chain = editor.chain().focus();\n\n\t\t// Expand selection to cover full text range for NodeSelection\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tconst isActive = levels.some((l) =>\n\t\t\teditor.isActive('heading', { level: l })\n\t\t);\n\n\t\tconst toggle = isActive\n\t\t\t? chain.setNode('paragraph')\n\t\t\t: chain.setNode('heading', { level: toggleLevel });\n\n\t\ttoggle.run();\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Determines if the heading button should be shown\n */\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\tlevel?: Level | Level[];\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, level, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema('heading', editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\tif (Array.isArray(level)) {\n\t\t\treturn level.some((l) => canToggle(editor, l));\n\t\t}\n\n\t\treturn canToggle(editor, level);\n\t}\n\n\treturn true;\n}\n\nexport function useHeading(config: UseHeadingConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\tlevel,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canToggleState = canToggle(activeEditor, level);\n\tconst isActive = isHeadingActive(activeEditor, level);\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\tlevel,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, level, hideWhenUnavailable]);\n\n\tconst handleToggle = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleHeading(activeEditor, level);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, level, onToggled]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle: canToggleState,\n\t\tlabel: dictionary[`heading.${level}`],\n\t\tIcon: headingIcons[level]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-link-popover.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useUiState } from './use-ui-state';\nimport { isMarkInSchema, sanitizeUrl } from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\n\nexport type PopoverMode = 'closed' | 'preview' | 'edit';\n\nexport interface UseLinkPopoverConfig {\n\teditor?: Editor | null;\n\thideWhenUnavailable?: boolean;\n}\n\nexport interface AnchorCoords {\n\tleft: number;\n\ttop: number;\n}\n\nexport interface UseLinkPopoverReturn {\n\teditor: Editor | null;\n\tisVisible: boolean;\n\tcanSetLink: boolean;\n\tisActive: boolean;\n\tpopoverMode: PopoverMode;\n\tsetPopoverMode: (mode: PopoverMode) => void;\n\turl: string;\n\tsetUrl: (url: string) => void;\n\ttext: string;\n\tsetText: (text: string) => void;\n\turlError: string | null;\n\tsubmitLink: () => void;\n\tremoveLink: () => void;\n\topenLink: () => void;\n\tanchorCoords: AnchorCoords | null;\n}\n\nexport function canSetLink(editor: Editor | null): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isMarkInSchema('link', editor)) return false;\n\n\treturn editor.can().setMark('link');\n}\n\nexport function isLinkActive(editor: Editor | null): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn editor.isActive('link');\n}\n\nexport function shouldShowLinkButton(props: {\n\teditor: Editor | null;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isMarkInSchema('link', editor)) return false;\n\n\tif (hideWhenUnavailable) {\n\t\treturn canSetLink(editor);\n\t}\n\n\treturn true;\n}\n\nfunction getSelectedText(editor: Editor): string {\n\tconst { from, to } = editor.state.selection;\n\n\treturn editor.state.doc.textBetween(from, to, '');\n}\n\nfunction getActiveLinkAttrs(editor: Editor): { href: string } | null {\n\tif (!editor.isActive('link')) return null;\n\n\tconst attrs = editor.getAttributes('link');\n\n\treturn attrs?.href ? { href: attrs.href as string } : null;\n}\n\nfunction getLinkRange(editor: Editor): { from: number; to: number } {\n\tconst { doc, selection } = editor.state;\n\tconst linkType = editor.schema.marks.link;\n\n\tif (!linkType) return { from: selection.from, to: selection.from };\n\n\tconst $pos = doc.resolve(selection.from);\n\tconst parent = $pos.parent;\n\tlet offset = 0;\n\n\tfor (let i = 0; i < parent.childCount; i++) {\n\t\tconst child = parent.child(i);\n\t\tconst childStart = $pos.start() + offset;\n\t\tconst childEnd = childStart + child.nodeSize;\n\n\t\t// Use <= for childEnd so cursor at the link boundary still matches\n\t\tif (\n\t\t\tchildStart <= selection.from &&\n\t\t\tselection.from <= childEnd &&\n\t\t\tchild.marks.some((m) => m.type === linkType)\n\t\t) {\n\t\t\treturn { from: childStart, to: childEnd };\n\t\t}\n\n\t\toffset += child.nodeSize;\n\t}\n\n\treturn { from: selection.from, to: selection.from };\n}\n\nexport function useLinkPopover(\n\tconfig: UseLinkPopoverConfig = {}\n): UseLinkPopoverReturn {\n\tconst { editor: providedEditor, hideWhenUnavailable = false } = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst { isDragging } = useUiState(activeEditor);\n\tconst [popoverMode, setPopoverModeRaw] = useState<PopoverMode>('closed');\n\tconst [url, setUrl] = useState('');\n\tconst [text, setText] = useState('');\n\tconst [urlError, setUrlError] = useState<string | null>(null);\n\tconst [isVisible, setIsVisible] = useState(true);\n\tconst [anchorCoords, setAnchorCoords] = useState<AnchorCoords | null>(null);\n\n\tconst can = canSetLink(activeEditor);\n\tconst active = isLinkActive(activeEditor);\n\n\tconst setPopoverMode = useCallback(\n\t\t(mode: PopoverMode) => {\n\t\t\tif (!activeEditor) return;\n\n\t\t\tsetUrlError(null);\n\n\t\t\tif (mode === 'edit') {\n\t\t\t\tconst linkAttrs = getActiveLinkAttrs(activeEditor);\n\n\t\t\t\tif (linkAttrs) {\n\t\t\t\t\tsetUrl(linkAttrs.href);\n\t\t\t\t\tsetText(getSelectedText(activeEditor));\n\t\t\t\t} else {\n\t\t\t\t\tsetUrl('');\n\t\t\t\t\tsetText(getSelectedText(activeEditor));\n\n\t\t\t\t\t// Toolbar-initiated new link: anchor to current cursor position\n\t\t\t\t\tconst coords = activeEditor.view.coordsAtPos(\n\t\t\t\t\t\tactiveEditor.state.selection.from\n\t\t\t\t\t);\n\n\t\t\t\t\tsetAnchorCoords({ left: coords.left, top: coords.bottom });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetPopoverModeRaw(mode);\n\t\t},\n\t\t[activeEditor]\n\t);\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowLinkButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// edit mode lifecycle is managed by focusout, not selectionUpdate\n\t\t\tif (popoverMode === 'edit') return;\n\n\t\t\tif (isDragging || activeEditor.state.selection instanceof NodeSelection) {\n\t\t\t\tsetPopoverModeRaw('closed');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (activeEditor.isActive('link')) {\n\t\t\t\tconst linkAttrs = getActiveLinkAttrs(activeEditor);\n\n\t\t\t\tif (linkAttrs) {\n\t\t\t\t\tsetUrl(linkAttrs.href);\n\t\t\t\t\tsetText(getSelectedText(activeEditor));\n\t\t\t\t}\n\n\t\t\t\tconst { from: anchorPos } = getLinkRange(activeEditor);\n\t\t\t\tconst coords = activeEditor.view.coordsAtPos(anchorPos);\n\n\t\t\t\tsetAnchorCoords({ left: coords.left, top: coords.bottom });\n\t\t\t\tsetPopoverModeRaw('preview');\n\t\t\t} else {\n\t\t\t\tsetPopoverModeRaw('closed');\n\t\t\t}\n\t\t};\n\n\t\thandleSelectionUpdate();\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, hideWhenUnavailable, isDragging, popoverMode]);\n\n\tconst submitLink = useCallback(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst trimmedUrl = url.trim();\n\n\t\tif (!trimmedUrl) {\n\t\t\tsetUrlError('URL cannot be empty');\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst safeUrl = sanitizeUrl(trimmedUrl, window.location.href);\n\n\t\tif (safeUrl === '#') {\n\t\t\tsetUrlError('Invalid or disallowed URL');\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst displayText = text.trim();\n\t\tconst existingLink = getActiveLinkAttrs(activeEditor);\n\n\t\tif (existingLink) {\n\t\t\t// Editing an existing link: replace the entire link range\n\t\t\tconst { from, to } = getLinkRange(activeEditor);\n\t\t\tconst currentText = activeEditor.state.doc.textBetween(from, to, '');\n\t\t\tconst newText = displayText || currentText;\n\n\t\t\tactiveEditor\n\t\t\t\t.chain()\n\t\t\t\t.focus()\n\t\t\t\t.setTextSelection({ from, to })\n\t\t\t\t.deleteSelection()\n\t\t\t\t.insertContent({\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\ttext: newText,\n\t\t\t\t\tmarks: [{ type: 'link', attrs: { href: safeUrl } }]\n\t\t\t\t})\n\t\t\t\t.run();\n\t\t} else {\n\t\t\t// Creating a new link\n\t\t\tconst { from, to } = activeEditor.state.selection;\n\t\t\tconst hasSelection = from !== to;\n\n\t\t\tif (hasSelection) {\n\t\t\t\tif (displayText && displayText !== getSelectedText(activeEditor)) {\n\t\t\t\t\tactiveEditor\n\t\t\t\t\t\t.chain()\n\t\t\t\t\t\t.focus()\n\t\t\t\t\t\t.deleteSelection()\n\t\t\t\t\t\t.insertContent({\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\ttext: displayText,\n\t\t\t\t\t\t\tmarks: [{ type: 'link', attrs: { href: safeUrl } }]\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.run();\n\t\t\t\t} else {\n\t\t\t\t\tactiveEditor.chain().focus().setMark('link', { href: safeUrl }).run();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tactiveEditor\n\t\t\t\t\t.chain()\n\t\t\t\t\t.focus()\n\t\t\t\t\t.insertContent({\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\ttext: displayText || safeUrl,\n\t\t\t\t\t\tmarks: [{ type: 'link', attrs: { href: safeUrl } }]\n\t\t\t\t\t})\n\t\t\t\t\t.run();\n\t\t\t}\n\t\t}\n\n\t\tsetPopoverModeRaw('closed');\n\t\tsetUrl('');\n\t\tsetText('');\n\t\tsetUrlError(null);\n\t}, [activeEditor, url, text]);\n\n\tconst removeLink = useCallback(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst { from, to } = getLinkRange(activeEditor);\n\n\t\tactiveEditor\n\t\t\t.chain()\n\t\t\t.focus()\n\t\t\t.setTextSelection({ from, to })\n\t\t\t.unsetMark('link')\n\t\t\t.run();\n\t\tsetPopoverModeRaw('closed');\n\t\tsetUrl('');\n\t\tsetText('');\n\t\tsetUrlError(null);\n\t}, [activeEditor]);\n\n\tconst openLink = useCallback(() => {\n\t\tif (!url) return;\n\n\t\ttry {\n\t\t\tconst safeUrl = sanitizeUrl(url, window.location.href);\n\n\t\t\tif (safeUrl !== '#') {\n\t\t\t\twindow.open(safeUrl, '_blank', 'noopener,noreferrer');\n\t\t\t}\n\t\t} catch {\n\t\t\t// Popup blockers may prevent window.open\n\t\t}\n\t}, [url]);\n\n\treturn {\n\t\teditor: activeEditor,\n\t\tisVisible,\n\t\tcanSetLink: can,\n\t\tisActive: active,\n\t\tpopoverMode,\n\t\tsetPopoverMode,\n\t\turl,\n\t\tsetUrl,\n\t\ttext,\n\t\tsetText,\n\t\turlError,\n\t\tsubmitLink,\n\t\tremoveLink,\n\t\topenLink,\n\t\tanchorCoords\n\t};\n}\n"
    },
    {
      "path": "hooks/use-list-dropdown-menu.ts",
      "content": "import { List } from 'lucide-react';\nimport { useEffect, useMemo, useState } from 'react';\n\nimport { useTranslation } from '../i18n';\nimport {\n\tcanToggleList,\n\tisListActive,\n\tlistIcons,\n\ttype ListType\n} from './use-list';\nimport { useNotraEditor } from './use-notra-editor';\nimport { isNodeInSchema } from '../lib/utils';\n\nimport type { Dictionary } from '../i18n';\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\nimport type { ElementType } from 'react';\n\nexport interface UseListDropdownMenuConfig {\n\t/**\n\t * The Tiptap editor instance.\n\t */\n\teditor?: Editor | null;\n\t/**\n\t * The list types to display in the dropdown.\n\t * @default [\"bulletList\", \"orderedList\", \"taskList\"]\n\t */\n\ttypes?: ListType[];\n\t/**\n\t * Whether the dropdown should be hidden when no list types are available\n\t * @default false\n\t */\n\thideWhenUnavailable?: boolean;\n}\n\nexport interface ListOption {\n\tlabel: string;\n\ttype: ListType;\n\ticon: ElementType;\n}\n\nconst listLabelKeys: Record<ListType, keyof Dictionary> = {\n\tbulletList: 'list.bullet',\n\torderedList: 'list.ordered',\n\ttaskList: 'list.task'\n};\n\nconst ALL_LIST_TYPES: ListType[] = [\n\t'bulletList',\n\t'orderedList',\n\t'taskList'\n] as const;\n\nexport function canToggleAnyList(\n\teditor: Editor | null,\n\tlistTypes: ListType[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn listTypes.some((type) => canToggleList(editor, type));\n}\n\nexport function isAnyListActive(\n\teditor: Editor | null,\n\tlistTypes: ListType[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn listTypes.some((type) => isListActive(editor, type));\n}\n\nexport function getFilteredListOptions(\n\toptions: ListOption[],\n\tavailableTypes: ListType[]\n): ListOption[] {\n\treturn options.filter((option) => availableTypes.includes(option.type));\n}\n\nexport function getActiveListType(\n\teditor: Editor | null,\n\tavailableTypes: ListType[]\n): ListType | undefined {\n\tif (!editor || !editor.isEditable) return undefined;\n\n\treturn availableTypes.find((type) => isListActive(editor, type));\n}\n\nexport function shouldShowListDropdown(params: {\n\teditor: Editor | null;\n\tlistTypes: ListType[];\n\thideWhenUnavailable: boolean;\n\tlistInSchema: boolean;\n\tcanToggleAny: boolean;\n}): boolean {\n\tconst { editor, hideWhenUnavailable, listInSchema, canToggleAny } = params;\n\n\tif (!listInSchema || !editor) {\n\t\treturn false;\n\t}\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleAny;\n\t}\n\n\treturn true;\n}\n\nexport function useListDropdownMenu(config?: UseListDropdownMenuConfig): {\n\tisVisible: boolean;\n\tactiveType: ListType | undefined;\n\tisActive: boolean;\n\tcanToggle: boolean;\n\ttypes: ListType[];\n\tfilteredLists: ListOption[];\n\tlabel: string;\n\tIcon: LucideIcon;\n} {\n\tconst {\n\t\teditor: providedEditor,\n\t\ttypes = ALL_LIST_TYPES,\n\t\thideWhenUnavailable = false\n\t} = config || {};\n\n\tconst { editor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState(false);\n\n\tconst listInSchema = types.some((type) => isNodeInSchema(type, editor));\n\n\tconst listOptions: ListOption[] = useMemo(\n\t\t() =>\n\t\t\tALL_LIST_TYPES.map((type) => ({\n\t\t\t\tlabel: dictionary[listLabelKeys[type]],\n\t\t\t\ttype,\n\t\t\t\ticon: listIcons[type]\n\t\t\t})),\n\t\t[dictionary]\n\t);\n\n\tconst filteredLists = useMemo(\n\t\t() => getFilteredListOptions(listOptions, types),\n\t\t[listOptions, types]\n\t);\n\n\tconst canToggleAny = canToggleAnyList(editor, types);\n\tconst isAnyActive = isAnyListActive(editor, types);\n\tconst activeType = getActiveListType(editor, types);\n\tconst activeList = filteredLists.find((option) => option.type === activeType);\n\n\tuseEffect(() => {\n\t\tif (!editor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowListDropdown({\n\t\t\t\t\teditor,\n\t\t\t\t\tlistTypes: types,\n\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\tlistInSchema,\n\t\t\t\t\tcanToggleAny\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\teditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\teditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [canToggleAny, editor, hideWhenUnavailable, listInSchema, types]);\n\n\treturn {\n\t\tisVisible,\n\t\tactiveType,\n\t\tisActive: isAnyActive,\n\t\tcanToggle: canToggleAny,\n\t\ttypes,\n\t\tfilteredLists,\n\t\tlabel: dictionary['list.dropdown.ariaLabel'],\n\t\tIcon: activeList ? listIcons[activeList.type] : List\n\t};\n}\n"
    },
    {
      "path": "hooks/use-list.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport { List, ListOrdered, ListTodo } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type ListType = 'bulletList' | 'orderedList' | 'taskList';\n\nexport interface UseListConfig {\n\teditor?: Editor | null;\n\ttype: ListType;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const listIcons: Record<ListType, LucideIcon> = {\n\tbulletList: List,\n\torderedList: ListOrdered,\n\ttaskList: ListTodo\n};\n\nexport const LIST_SHORTCUT_KEYS: Record<ListType, string> = {\n\tbulletList: 'mod+shift+8',\n\torderedList: 'mod+shift+7',\n\ttaskList: 'mod+shift+9'\n};\n\n/**\n * Checks if a list can be toggled in the current editor state\n */\nexport function canToggleList(\n\teditor: Editor | null,\n\ttype: ListType,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema(type, editor) || isNodeTypeSelected(editor, ['image']))\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\tswitch (type) {\n\t\t\tcase 'bulletList':\n\t\t\t\treturn editor.can().toggleBulletList();\n\t\t\tcase 'orderedList':\n\t\t\t\treturn editor.can().toggleOrderedList();\n\t\t\tcase 'taskList':\n\t\t\t\treturn editor.can().toggleList('taskList', 'taskItem');\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Checks if list is currently active\n */\nexport function isListActive(editor: Editor | null, type: ListType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tswitch (type) {\n\t\tcase 'bulletList':\n\t\t\treturn editor.isActive('bulletList');\n\t\tcase 'orderedList':\n\t\t\treturn editor.isActive('orderedList');\n\t\tcase 'taskList':\n\t\t\treturn editor.isActive('taskList');\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Toggles list in the editor\n */\nexport function toggleList(editor: Editor | null, type: ListType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleList(editor, type)) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\t// Node types that Tiptap can toggle to list directly\n\t\tconst directToggleTypes = new Set([\n\t\t\t'paragraph',\n\t\t\t'bulletList',\n\t\t\t'orderedList',\n\t\t\t'taskList'\n\t\t]);\n\n\t\tlet chain = editor.chain().focus();\n\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst parentNode = state.selection.$anchor.node(1);\n\n\t\t\tif (!parentNode || directToggleTypes.has(parentNode.type.name)) {\n\t\t\t\t// Skip NodeSelection conversion for simple nodes\n\t\t\t} else {\n\t\t\t\tconst pos = findNodePosition({\n\t\t\t\t\teditor,\n\t\t\t\t\tnode: parentNode\n\t\t\t\t})?.pos;\n\n\t\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\t\tview.dispatch(tr);\n\t\t\t\tstate = view.state;\n\t\t\t}\n\t\t}\n\n\t\tconst selection = state.selection;\n\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tif (editor.isActive(type)) {\n\t\t\tchain\n\t\t\t\t.liftListItem('listItem')\n\t\t\t\t.lift('bulletList')\n\t\t\t\t.lift('orderedList')\n\t\t\t\t.lift('taskList')\n\t\t\t\t.run();\n\t\t} else {\n\t\t\tconst toggleMap: Record<ListType, () => typeof chain> = {\n\t\t\t\tbulletList: () => chain.toggleBulletList(),\n\t\t\t\torderedList: () => chain.toggleOrderedList(),\n\t\t\t\ttaskList: () => chain.toggleList('taskList', 'taskItem')\n\t\t\t};\n\n\t\t\tconst toggle = toggleMap[type];\n\n\t\t\tif (!toggle) return false;\n\n\t\t\ttoggle().run();\n\t\t}\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Determines if the list button should be shown\n */\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\ttype: ListType;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, type, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema(type, editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleList(editor, type);\n\t}\n\n\treturn true;\n}\n\nexport function useList(config: UseListConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\ttype,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canToggle = canToggleList(activeEditor, type);\n\tconst isActive = isListActive(activeEditor, type);\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\ttype,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, type, hideWhenUnavailable]);\n\n\tconst handleToggle = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleList(activeEditor, type);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, type, onToggled]);\n\n\tconst listLabelKeys: Record<ListType, keyof typeof dictionary> = {\n\t\tbulletList: 'list.bullet',\n\t\torderedList: 'list.ordered',\n\t\ttaskList: 'list.task'\n\t};\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle,\n\t\tlabel: dictionary[listLabelKeys[type]],\n\t\tshortcutKeys: LIST_SHORTCUT_KEYS[type],\n\t\tIcon: listIcons[type]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-mark.ts",
      "content": "import {\n\tBold,\n\tCodeXml,\n\tItalic,\n\tStrikethrough,\n\tSubscript,\n\tSuperscript,\n\tUnderline\n} from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport { isMarkInSchema, isNodeTypeSelected } from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type MarkType =\n\t| 'bold'\n\t| 'italic'\n\t| 'underline'\n\t| 'strike'\n\t| 'code'\n\t| 'superscript'\n\t| 'subscript';\n\nexport interface UseMarkConfig {\n\teditor?: Editor | null;\n\ttype: MarkType;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const markIcons: Record<MarkType, LucideIcon> = {\n\tbold: Bold,\n\titalic: Italic,\n\tunderline: Underline,\n\tstrike: Strikethrough,\n\tcode: CodeXml,\n\tsuperscript: Superscript,\n\tsubscript: Subscript\n};\n\nexport const MARK_SHORTCUT_KEYS: Record<MarkType, string> = {\n\tbold: 'mod+b',\n\titalic: 'mod+i',\n\tunderline: 'mod+u',\n\tstrike: 'mod+shift+s',\n\tcode: 'mod+e',\n\tsuperscript: 'mod+.',\n\tsubscript: 'mod+,'\n};\n\nexport function canToggleMark(editor: Editor | null, type: MarkType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isMarkInSchema(type, editor) || isNodeTypeSelected(editor, ['image']))\n\t\treturn false;\n\n\treturn editor.can().toggleMark(type);\n}\n\nexport function isMarkActive(editor: Editor | null, type: MarkType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn editor.isActive(type);\n}\n\nexport function toggleMark(editor: Editor | null, type: MarkType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleMark(editor, type)) return false;\n\n\treturn editor.chain().focus().toggleMark(type).run();\n}\n\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\ttype: MarkType;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, type, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isMarkInSchema(type, editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleMark(editor, type);\n\t}\n\n\treturn true;\n}\n\nexport function useMark(config: UseMarkConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\ttype,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canToggle = canToggleMark(activeEditor, type);\n\tconst isActive = isMarkActive(activeEditor, type);\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\ttype,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, type, hideWhenUnavailable]);\n\n\tconst handleMark = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleMark(activeEditor, type);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, type, onToggled]);\n\n\tconst markLabelKeys: Record<MarkType, string> = {\n\t\tbold: 'mark.bold',\n\t\titalic: 'mark.italic',\n\t\tunderline: 'mark.underline',\n\t\tstrike: 'mark.strike',\n\t\tcode: 'mark.code',\n\t\tsuperscript: 'mark.superscript',\n\t\tsubscript: 'mark.subscript'\n\t};\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleMark,\n\t\tcanToggle,\n\t\tlabel: dictionary[markLabelKeys[type] as keyof typeof dictionary],\n\t\tshortcutKeys: MARK_SHORTCUT_KEYS[type],\n\t\tIcon: markIcons[type]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-notra-editor.ts",
      "content": "import { useCurrentEditor, useEditorState } from '@tiptap/react';\nimport { useMemo } from 'react';\n\nimport type { Editor } from '@tiptap/core';\n\n/**\n * Hook that provides access to a Tiptap editor instance.\n *\n * Accepts an optional editor instance directly, or falls back to retrieving\n * the editor from the Tiptap context if available. This allows components\n * to work both when given an editor directly and when used within a Tiptap\n * editor context.\n *\n * @param providedEditor - Optional editor instance to use instead of the context editor\n * @returns The provided editor or the editor from context, whichever is available\n */\nexport function useNotraEditor(providedEditor?: Editor | null): {\n\teditor: Editor | null;\n\teditorState?: Editor['state'];\n} {\n\tconst { editor: contextEditor } = useCurrentEditor();\n\tconst editor = useMemo(\n\t\t() => providedEditor ?? contextEditor,\n\t\t[providedEditor, contextEditor]\n\t);\n\n\treturn (\n\t\tuseEditorState({\n\t\t\teditor,\n\t\t\tselector(context) {\n\t\t\t\treturn {\n\t\t\t\t\teditor: context.editor,\n\t\t\t\t\teditorState: context.editor?.state\n\t\t\t\t};\n\t\t\t}\n\t\t}) || { editor: null }\n\t);\n}\n"
    },
    {
      "path": "hooks/use-text-align.ts",
      "content": "import { AlignCenter, AlignJustify, AlignLeft, AlignRight } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport { isExtensionAvailable, isNodeTypeSelected } from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type AlignmentType = 'left' | 'center' | 'right' | 'justify';\n\nexport interface UseTextAlignConfig {\n\teditor?: Editor | null;\n\talignment: AlignmentType;\n\thideWhenUnavailable?: boolean;\n\tonAligned?: () => void;\n}\n\nexport const alignmentIcons: Record<AlignmentType, LucideIcon> = {\n\tleft: AlignLeft,\n\tcenter: AlignCenter,\n\tright: AlignRight,\n\tjustify: AlignJustify\n};\n\nconst alignmentLabelKeys = {\n\tleft: 'textAlign.left',\n\tcenter: 'textAlign.center',\n\tright: 'textAlign.right',\n\tjustify: 'textAlign.justify'\n} as const;\n\nexport function canSetTextAlign(\n\teditor: Editor | null,\n\talignment: AlignmentType\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isExtensionAvailable(editor, 'textAlign') ||\n\t\tisNodeTypeSelected(editor, ['image', 'horizontalRule'])\n\t)\n\t\treturn false;\n\n\treturn editor.can().setTextAlign(alignment);\n}\n\nexport function isTextAlignActive(\n\teditor: Editor | null,\n\talignment: AlignmentType\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn editor.isActive({ textAlign: alignment });\n}\n\n// Runtime guard: ensures setTextAlign command exists before calling it\nfunction hasSetTextAlign(\n\tchain: ReturnType<Editor['chain']>\n): chain is ReturnType<Editor['chain']> & {\n\tsetTextAlign: (alignment: AlignmentType) => ReturnType<Editor['chain']>;\n} {\n\treturn 'setTextAlign' in chain;\n}\n\nexport function setTextAlign(\n\teditor: Editor | null,\n\talignment: AlignmentType\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canSetTextAlign(editor, alignment)) return false;\n\n\tconst chain = editor.chain().focus();\n\n\tif (hasSetTextAlign(chain)) {\n\t\treturn chain.setTextAlign(alignment).run();\n\t}\n\n\treturn false;\n}\n\nexport function shouldShowTextAlignButton(props: {\n\teditor: Editor | null;\n\talignment: AlignmentType;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, alignment, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isExtensionAvailable(editor, 'textAlign')) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canSetTextAlign(editor, alignment);\n\t}\n\n\treturn true;\n}\n\nexport function useTextAlign(config: UseTextAlignConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\talignment,\n\t\thideWhenUnavailable = false,\n\t\tonAligned\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canAlign = canSetTextAlign(activeEditor, alignment);\n\tconst isActive = isTextAlignActive(activeEditor, alignment);\n\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowTextAlignButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\talignment,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, alignment, hideWhenUnavailable]);\n\n\tconst handleAlign = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = setTextAlign(activeEditor, alignment);\n\n\t\tif (success) {\n\t\t\tonAligned?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, alignment, onAligned]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\tcanAlign,\n\t\thandleAlign,\n\t\tlabel: dictionary[alignmentLabelKeys[alignment]],\n\t\tIcon: alignmentIcons[alignment]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-ui-state.ts",
      "content": "import { useEditorState } from '@tiptap/react';\n\nimport { DEFAULT_STATE } from '../extensions/ui-state';\n\nimport type { UiState } from '../extensions/ui-state';\nimport type { Editor } from '@tiptap/core';\n\nexport function useUiState(editor: Editor | null): UiState {\n\treturn (\n\t\tuseEditorState({\n\t\t\teditor,\n\t\t\tselector: ({ editor }) => {\n\t\t\t\tif (!editor) return DEFAULT_STATE;\n\n\t\t\t\tconst state = editor.storage.editorUiState as UiState | undefined;\n\n\t\t\t\tif (!state) return DEFAULT_STATE;\n\n\t\t\t\treturn { ...DEFAULT_STATE, ...state };\n\t\t\t}\n\t\t}) ?? DEFAULT_STATE\n\t);\n}\n"
    },
    {
      "path": "hooks/use-undo-redo.ts",
      "content": "import { Redo2, Undo2 } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport { isNodeTypeSelected } from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type UndoRedoAction = 'undo' | 'redo';\n\nexport interface UseUndoRedoConfig {\n\teditor?: Editor | null;\n\taction: UndoRedoAction;\n\thideWhenUnavailable?: boolean;\n\tonExecuted?: () => void;\n}\n\nexport const UNDO_REDO_SHORTCUT_KEYS: Record<UndoRedoAction, string> = {\n\tundo: 'mod+z',\n\tredo: 'mod+shift+z'\n};\n\nconst actionIcons: Record<UndoRedoAction, LucideIcon> = {\n\tundo: Undo2,\n\tredo: Redo2\n};\n\nconst actionLabelKeys = {\n\tundo: 'undoRedo.undo',\n\tredo: 'undoRedo.redo'\n} as const;\n\n// Undo/redo should be blocked when an image node is selected\nexport function canExecuteAction(\n\teditor: Editor | null,\n\taction: UndoRedoAction\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (isNodeTypeSelected(editor, ['image'])) return false;\n\n\treturn action === 'undo' ? editor.can().undo() : editor.can().redo();\n}\n\nexport function executeAction(\n\teditor: Editor | null,\n\taction: UndoRedoAction\n): boolean {\n\tif (!editor || !canExecuteAction(editor, action)) return false;\n\n\tconst chain = editor.chain().focus();\n\n\treturn action === 'undo' ? chain.undo().run() : chain.redo().run();\n}\n\nexport function shouldShowUndoRedoButton(props: {\n\teditor: Editor | null;\n\taction: UndoRedoAction;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, action, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (hideWhenUnavailable) {\n\t\treturn canExecuteAction(editor, action);\n\t}\n\n\treturn true;\n}\n\nexport function useUndoRedo(config: UseUndoRedoConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\taction,\n\t\thideWhenUnavailable = false,\n\t\tonExecuted\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = useState<boolean>(true);\n\tconst canExecute = canExecuteAction(activeEditor, action);\n\n\t// Undo/redo availability depends on history stack, not just selection\n\tuseEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowUndoRedoButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\taction,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleUpdate();\n\n\t\tactiveEditor.on('transaction', handleUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('transaction', handleUpdate);\n\t\t};\n\t}, [activeEditor, action, hideWhenUnavailable]);\n\n\tconst handleAction = useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = executeAction(activeEditor, action);\n\n\t\tif (success) {\n\t\t\tonExecuted?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, action, onExecuted]);\n\n\treturn {\n\t\tisVisible,\n\t\tcanExecute,\n\t\thandleAction,\n\t\tlabel: dictionary[actionLabelKeys[action]],\n\t\tshortcutKeys: UNDO_REDO_SHORTCUT_KEYS[action],\n\t\tIcon: actionIcons[action]\n\t};\n}\n"
    },
    {
      "path": "hooks/__tests__/use-blockquote.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggleBlockquote, toggleBlockquote } from '../use-blockquote';\n\n//  Property 3: canToggleBlockquote and toggleBlockquote guard conditions \n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but blockquote node type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 3: canToggleBlockquote and toggleBlockquote guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 3.1, 3.2, 3.5, 3.6**\n\t */\n\ttest('canToggleBlockquote returns false when editor is null, not editable, or blockquote not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(canToggleGuardArbitrary, (editorState) => {\n\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\tconst result = canToggleBlockquote(editor as never);\n\n\t\t\t\texpect(result).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('when canToggleBlockquote returns false, toggleBlockquote also returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(canToggleGuardArbitrary, (editorState) => {\n\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\tconst canToggleResult = canToggleBlockquote(editor as never);\n\t\t\t\tconst toggleResult = toggleBlockquote(editor as never);\n\n\t\t\t\t// Guard states always make canToggleBlockquote return false\n\t\t\t\texpect(canToggleResult).toBe(false);\n\t\t\t\t// When canToggleBlockquote is false, toggleBlockquote must also be false\n\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-code-block.test.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggleCodeBlock } from '../use-code-block';\n\n//  Unit tests: canToggleCodeBlock edge cases \n\ndescribe('canToggleCodeBlock unit tests', () => {\n\ttest('returns false when editor is null', () => {\n\t\texpect(canToggleCodeBlock(null)).toBe(false);\n\t});\n\n\ttest('returns false when editor is not editable', () => {\n\t\tconst editor = {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: { get: () => ({}) }\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\texpect(canToggleCodeBlock(editor as never)).toBe(false);\n\t});\n\n\ttest('returns false when codeBlock is not in schema', () => {\n\t\tconst editor = {\n\t\t\tisEditable: true,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: { get: () => undefined }\n\t\t\t\t}\n\t\t\t},\n\t\t\tstate: {\n\t\t\t\tselection: { empty: true }\n\t\t\t}\n\t\t};\n\n\t\texpect(canToggleCodeBlock(editor as never)).toBe(false);\n\t});\n\n\ttest('returns false when an image node is selected', () => {\n\t\tconst nodeSelection = Object.create(NodeSelection.prototype, {\n\t\t\tempty: { value: false, writable: false },\n\t\t\tnode: {\n\t\t\t\tvalue: { type: { name: 'image' } },\n\t\t\t\twritable: false\n\t\t\t}\n\t\t});\n\n\t\tconst editor = {\n\t\t\tisEditable: true,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'codeBlock' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tstate: {\n\t\t\t\tselection: nodeSelection\n\t\t\t}\n\t\t};\n\n\t\texpect(canToggleCodeBlock(editor as never)).toBe(false);\n\t});\n\n\ttest('returns true when editor is editable, codeBlock in schema, and no image selected', () => {\n\t\tconst editor = {\n\t\t\tisEditable: true,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'codeBlock' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tstate: {\n\t\t\t\tselection: { empty: true }\n\t\t\t}\n\t\t};\n\n\t\texpect(canToggleCodeBlock(editor as never)).toBe(true);\n\t});\n});\n\n//  Property 3: canToggle guard conditions \n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' }\n\t| { type: 'image-selected' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' },\n\t\t{ type: 'image-selected' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'codeBlock' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tif (state.type === 'not-in-schema') {\n\t\treturn {\n\t\t\tisEditable: true,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: { get: () => undefined }\n\t\t\t\t}\n\t\t\t},\n\t\t\tstate: {\n\t\t\t\tselection: { empty: true }\n\t\t\t}\n\t\t};\n\t}\n\n\t// image-selected: editable, codeBlock in schema, but image node is selected\n\tconst nodeSelection = Object.create(NodeSelection.prototype, {\n\t\tempty: { value: false, writable: false },\n\t\tnode: {\n\t\t\tvalue: { type: { name: 'image' } },\n\t\t\twritable: false\n\t\t}\n\t});\n\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: (name: string) => (name === 'codeBlock' ? {} : undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: nodeSelection\n\t\t}\n\t};\n}\n\ndescribe('Feature: code-block, Property 3: canToggle guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 5.3, 5.4, 5.5**\n\t */\n\ttest('canToggleCodeBlock returns false when editor is null, not editable, codeBlock not in schema, or image is selected', () => {\n\t\tfc.assert(\n\t\t\tfc.property(canToggleGuardArbitrary, (editorState) => {\n\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\tconst result = canToggleCodeBlock(editor as never);\n\n\t\t\t\texpect(result).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-heading.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggle, toggleHeading } from '../use-heading';\nimport { getActiveHeadingLevel } from '../use-heading-dropdown-menu';\n\nimport type { Level } from '../use-heading';\n\n//  Shared arbitraries \n\nconst levelArbitrary: fc.Arbitrary<Level> = fc.constantFrom(\n\t1 as Level,\n\t2 as Level,\n\t3 as Level,\n\t4 as Level,\n\t5 as Level,\n\t6 as Level\n);\n\nconst levelsSubsetArbitrary: fc.Arbitrary<Level[]> = fc\n\t.subarray([1, 2, 3, 4, 5, 6] as Level[], { minLength: 0, maxLength: 6 })\n\t.map((arr) => [...arr].sort((a, b) => a - b));\n\n//  Property 5: canToggle guard conditions \n\ntype CanToggleEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'no-heading-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleEditorState> =\n\tfc.constantFrom<CanToggleEditorState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'no-heading-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'heading' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// no-heading-in-schema: editable but heading not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 5: canToggle ', () => {\n\t/**\n\t * **Validates: Requirements 6.4, 6.5**\n\t */\n\ttest('canToggle returns false when editor is null, not editable, or heading not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggle(editor as never, level);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 6: toggleHeading toggle behavior \n\ntype ToggleEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'no-heading-in-schema' };\n\nconst toggleGuardArbitrary: fc.Arbitrary<ToggleEditorState> =\n\tfc.constantFrom<ToggleEditorState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'no-heading-in-schema' }\n\t);\n\nfunction buildToggleGuardEditor(state: ToggleEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'heading' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// no-heading-in-schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 6: toggleHeading ', () => {\n\t/**\n\t * **Validates: Requirements 6.2, 6.3**\n\t *\n\t * toggleHeading relies on editor.view, editor.chain(), NodeSelection, etc.\n\t * Full Tiptap chain API mocking is impractical, so we verify the guard\n\t * invariant: toggleHeading returns false for all invalid editor states.\n\t */\n\ttest('toggleHeading returns false when editor is null, not editable, or heading not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = toggleHeading(editor as never, level);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 6.2, 6.3**\n\t *\n\t * When canToggle returns false, toggleHeading must also return false.\n\t * This verifies the guard consistency between the two functions.\n\t */\n\ttest('toggleHeading returns false whenever canToggle returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggle(editor as never, level);\n\t\t\t\t\tconst toggleResult = toggleHeading(editor as never, level);\n\n\t\t\t\t\tif (!canToggleResult) {\n\t\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 7: getActiveHeadingLevel icon selection \n\ntype ActiveHeadingEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeLevel: Level | undefined };\n\nconst activeHeadingEditorArbitrary: fc.Arbitrary<ActiveHeadingEditorState> =\n\tfc.oneof(\n\t\tfc.constant<ActiveHeadingEditorState>({ type: 'null' }),\n\t\tfc.constant<ActiveHeadingEditorState>({ type: 'not-editable' }),\n\t\tfc.record<ActiveHeadingEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveLevel: fc.option(levelArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildActiveHeadingEditor(state: ActiveHeadingEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string, attrs?: { level: Level }) => {\n\t\t\tif (name !== 'heading') return false;\n\n\t\t\tif (!attrs || state.activeLevel === undefined) return false;\n\n\t\t\treturn attrs.level === state.activeLevel;\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 7: getActiveHeadingLevel ', () => {\n\t/**\n\t * **Validates: Requirements 7.2, 7.3**\n\t */\n\ttest('returns the first level in the array that is active, or undefined if none', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tactiveHeadingEditorArbitrary,\n\t\t\t\tlevelsSubsetArbitrary,\n\t\t\t\t(editorState, levels) => {\n\t\t\t\t\tconst editor = buildActiveHeadingEditor(editorState);\n\t\t\t\t\tconst result = getActiveHeadingLevel(editor as never, levels);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBeUndefined();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, find the expected first matching level\n\t\t\t\t\tconst expected = levels.find((l) => l === editorState.activeLevel);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 7.2, 7.3**\n\t */\n\ttest('returns undefined when no heading level is active', () => {\n\t\tfc.assert(\n\t\t\tfc.property(levelsSubsetArbitrary, (levels) => {\n\t\t\t\t// Editor where no heading is active\n\t\t\t\tconst editor = {\n\t\t\t\t\tisEditable: true,\n\t\t\t\t\tisActive: () => false\n\t\t\t\t};\n\n\t\t\t\tconst result = getActiveHeadingLevel(editor as never, levels);\n\n\t\t\t\texpect(result).toBeUndefined();\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-link-popover.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport {\n\tcanSetLink,\n\tisLinkActive,\n\tshouldShowLinkButton\n} from '../use-link-popover';\n\n//  Mock editor builders \n\ninterface MockEditorConfig {\n\tisEditable: boolean;\n\thasLinkMark: boolean;\n\tcanSetMark: boolean;\n\tisActiveLinkResult: boolean;\n}\n\nfunction buildMockEditor(config: MockEditorConfig) {\n\tconst marks = new Map<string, unknown>();\n\n\tif (config.hasLinkMark) {\n\t\tmarks.set('link', {});\n\t}\n\n\treturn {\n\t\tisEditable: config.isEditable,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tmarks: {\n\t\t\t\t\tget: (name: string) => marks.get(name)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcan: () => ({\n\t\t\tsetMark: (name: string) => name === 'link' && config.canSetMark\n\t\t}),\n\t\tisActive: (name: string) => name === 'link' && config.isActiveLinkResult\n\t};\n}\n\nconst editorConfigArbitrary: fc.Arbitrary<MockEditorConfig> = fc.record({\n\tisEditable: fc.boolean(),\n\thasLinkMark: fc.boolean(),\n\tcanSetMark: fc.boolean(),\n\tisActiveLinkResult: fc.boolean()\n});\n\n//  Property 1: Link button state guards \n\n// Feature: link-popover, Property 1: Link button state guards\ndescribe('Feature: link-popover, Property 1: Link button state guards', () => {\n\t/**\n\t * **Validates: Requirements 2.2, 2.3, 2.4**\n\t */\n\n\ttest('shouldShowLinkButton returns false when link mark is not in schema', () => {\n\t\tconst configWithoutLink = fc.record({\n\t\t\tisEditable: fc.constant(true),\n\t\t\thasLinkMark: fc.constant(false),\n\t\t\tcanSetMark: fc.boolean(),\n\t\t\tisActiveLinkResult: fc.boolean()\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(configWithoutLink, fc.boolean(), (config, hide) => {\n\t\t\t\tconst editor = buildMockEditor(config);\n\n\t\t\t\texpect(\n\t\t\t\t\tshouldShowLinkButton({\n\t\t\t\t\t\teditor: editor as never,\n\t\t\t\t\t\thideWhenUnavailable: hide\n\t\t\t\t\t})\n\t\t\t\t).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('canSetLink returns false when editor is null', () => {\n\t\texpect(canSetLink(null)).toBe(false);\n\t});\n\n\ttest('canSetLink returns false when editor is not editable', () => {\n\t\tconst nonEditableConfig = fc.record({\n\t\t\tisEditable: fc.constant(false),\n\t\t\thasLinkMark: fc.boolean(),\n\t\t\tcanSetMark: fc.boolean(),\n\t\t\tisActiveLinkResult: fc.boolean()\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(nonEditableConfig, (config) => {\n\t\t\t\tconst editor = buildMockEditor(config);\n\n\t\t\t\texpect(canSetLink(editor as never)).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('isLinkActive returns false when editor is null', () => {\n\t\texpect(isLinkActive(null)).toBe(false);\n\t});\n\n\ttest('isLinkActive returns false when editor is not editable', () => {\n\t\tconst nonEditableConfig = fc.record({\n\t\t\tisEditable: fc.constant(false),\n\t\t\thasLinkMark: fc.boolean(),\n\t\t\tcanSetMark: fc.boolean(),\n\t\t\tisActiveLinkResult: fc.boolean()\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(nonEditableConfig, (config) => {\n\t\t\t\tconst editor = buildMockEditor(config);\n\n\t\t\t\texpect(isLinkActive(editor as never)).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('isLinkActive returns true when editor reports isActive(\"link\") as true', () => {\n\t\tconst activeLinkConfig = fc.record({\n\t\t\tisEditable: fc.constant(true),\n\t\t\thasLinkMark: fc.boolean(),\n\t\t\tcanSetMark: fc.boolean(),\n\t\t\tisActiveLinkResult: fc.constant(true)\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(activeLinkConfig, (config) => {\n\t\t\t\tconst editor = buildMockEditor(config);\n\n\t\t\t\texpect(isLinkActive(editor as never)).toBe(true);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('all state guards hold simultaneously for any editor config', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorConfigArbitrary,\n\t\t\t\tfc.boolean(),\n\t\t\t\t(config, hideWhenUnavailable) => {\n\t\t\t\t\tconst editor = buildMockEditor(config);\n\n\t\t\t\t\t// Guard 1: no link mark in schema  shouldShowLinkButton false\n\t\t\t\t\tif (!config.hasLinkMark) {\n\t\t\t\t\t\texpect(\n\t\t\t\t\t\t\tshouldShowLinkButton({\n\t\t\t\t\t\t\t\teditor: editor as never,\n\t\t\t\t\t\t\t\thideWhenUnavailable\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t).toBe(false);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guard 2: not editable  canSetLink false\n\t\t\t\t\tif (!config.isEditable) {\n\t\t\t\t\t\texpect(canSetLink(editor as never)).toBe(false);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guard 3: not editable  isLinkActive false\n\t\t\t\t\tif (!config.isEditable) {\n\t\t\t\t\t\texpect(isLinkActive(editor as never)).toBe(false);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guard 4: isActive('link') true + editable  isLinkActive true\n\t\t\t\t\tif (config.isEditable && config.isActiveLinkResult) {\n\t\t\t\t\t\texpect(isLinkActive(editor as never)).toBe(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-list.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggleList, isListActive, toggleList } from '../use-list';\nimport {\n\tcanToggleAnyList,\n\tgetActiveListType,\n\tgetFilteredListOptions,\n\tisAnyListActive,\n\tshouldShowListDropdown\n} from '../use-list-dropdown-menu';\n\nimport type { ListType } from '../use-list';\nimport type { ListOption } from '../use-list-dropdown-menu';\n\n//  Shared arbitraries \n\nconst listTypeArbitrary: fc.Arbitrary<ListType> = fc.constantFrom(\n\t'bulletList' as ListType,\n\t'orderedList' as ListType,\n\t'taskList' as ListType\n);\n\n//  Property 1: canToggleList guard conditions \n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but list node type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: list-dropdown-menu, Property 1: canToggleList guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 1.1, 1.2**\n\t */\n\ttest('canToggleList returns false when editor is null, not editable, or list node type not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tlistTypeArbitrary,\n\t\t\t\t(editorState, listType) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggleList(editor as never, listType);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 2: isListActive guard and delegation \n\ntype IsListActiveEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeType: ListType | undefined };\n\nconst isListActiveEditorArbitrary: fc.Arbitrary<IsListActiveEditorState> =\n\tfc.oneof(\n\t\tfc.constant<IsListActiveEditorState>({ type: 'null' }),\n\t\tfc.constant<IsListActiveEditorState>({ type: 'not-editable' }),\n\t\tfc.record<IsListActiveEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveType: fc.option(listTypeArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildIsListActiveEditor(state: IsListActiveEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string) => {\n\t\t\tif (state.activeType === undefined) return false;\n\n\t\t\treturn name === state.activeType;\n\t\t}\n\t};\n}\n\ndescribe('Feature: list-dropdown-menu, Property 2: isListActive guard and delegation', () => {\n\t/**\n\t * **Validates: Requirements 1.4, 1.5**\n\t */\n\ttest('isListActive returns false when editor is null or not editable, and correctly delegates to editor.isActive when editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tisListActiveEditorArbitrary,\n\t\t\t\tlistTypeArbitrary,\n\t\t\t\t(editorState, listType) => {\n\t\t\t\t\tconst editor = buildIsListActiveEditor(editorState);\n\t\t\t\t\tconst result = isListActive(editor as never, listType);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBe(false);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, verify delegation to editor.isActive\n\t\t\t\t\tconst expected = editorState.activeType === listType;\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 3: toggleList and canToggleList consistency \n\ntype ToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst toggleGuardArbitrary: fc.Arbitrary<ToggleGuardState> =\n\tfc.constantFrom<ToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildToggleGuardEditor(state: ToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but list node type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: list-dropdown-menu, Property 3: toggleList and canToggleList consistency', () => {\n\t/**\n\t * **Validates: Requirements 1.6, 1.7**\n\t */\n\ttest('when canToggleList returns false, toggleList also returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlistTypeArbitrary,\n\t\t\t\t(editorState, listType) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggleList(editor as never, listType);\n\t\t\t\t\tconst toggleResult = toggleList(editor as never, listType);\n\n\t\t\t\t\t// Guard states always make canToggleList return false\n\t\t\t\t\texpect(canToggleResult).toBe(false);\n\t\t\t\t\t// When canToggleList is false, toggleList must also be false\n\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Shared arbitraries for Properties 4-8 \n\nconst ALL_LIST_TYPES: ListType[] = ['bulletList', 'orderedList', 'taskList'];\n\nconst listTypesSubsetArbitrary: fc.Arbitrary<ListType[]> = fc.subarray(\n\tALL_LIST_TYPES,\n\t{ minLength: 0, maxLength: 3 }\n);\n\ntype EditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeType: ListType | undefined };\n\nconst editorStateArbitrary: fc.Arbitrary<EditorState> = fc.oneof(\n\tfc.constant<EditorState>({ type: 'null' }),\n\tfc.constant<EditorState>({ type: 'not-editable' }),\n\tfc.record<EditorState & { type: 'editable' }>({\n\t\ttype: fc.constant('editable' as const),\n\t\tactiveType: fc.option(listTypeArbitrary, { nil: undefined })\n\t})\n);\n\nfunction buildMockEditor(state: EditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string) => {\n\t\t\tif (state.activeType === undefined) return false;\n\n\t\t\treturn name === state.activeType;\n\t\t},\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => ({})\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: true }\n\t\t}\n\t};\n}\n\n//  Property 4: canToggleAnyList aggregation \n\ndescribe('Feature: list-dropdown-menu, Property 4: canToggleAnyList aggregation', () => {\n\t/**\n\t * **Validates: Requirements 2.1, 2.2**\n\t */\n\ttest('canToggleAnyList returns true iff at least one type canToggleList returns true', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorStateArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = canToggleAnyList(editor as never, listTypes);\n\t\t\t\t\tconst expected = listTypes.some((type) =>\n\t\t\t\t\t\tcanToggleList(editor as never, type)\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('canToggleAnyList returns false when editor is null or not editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constantFrom<EditorState>(\n\t\t\t\t\t{ type: 'null' },\n\t\t\t\t\t{ type: 'not-editable' }\n\t\t\t\t),\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = canToggleAnyList(editor as never, listTypes);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 5: isAnyListActive aggregation \n\ndescribe('Feature: list-dropdown-menu, Property 5: isAnyListActive aggregation', () => {\n\t/**\n\t * **Validates: Requirements 2.3, 2.4**\n\t */\n\ttest('isAnyListActive returns true iff at least one type isListActive returns true', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorStateArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = isAnyListActive(editor as never, listTypes);\n\t\t\t\t\tconst expected = listTypes.some((type) =>\n\t\t\t\t\t\tisListActive(editor as never, type)\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('isAnyListActive returns false when editor is null or not editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constantFrom<EditorState>(\n\t\t\t\t\t{ type: 'null' },\n\t\t\t\t\t{ type: 'not-editable' }\n\t\t\t\t),\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = isAnyListActive(editor as never, listTypes);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 6: getFilteredListOptions filtering \n\nconst listOptionArbitrary: fc.Arbitrary<ListOption> = fc\n\t.record({\n\t\tlabel: fc.string({ minLength: 1, maxLength: 20 }),\n\t\ttype: listTypeArbitrary,\n\t\ticon: fc.constant(() => null)\n\t})\n\t.map((r) => r as unknown as ListOption);\n\nconst listOptionsArbitrary: fc.Arbitrary<ListOption[]> = fc.array(\n\tlistOptionArbitrary,\n\t{ minLength: 0, maxLength: 10 }\n);\n\ndescribe('Feature: list-dropdown-menu, Property 6: getFilteredListOptions filtering', () => {\n\t/**\n\t * **Validates: Requirements 2.5**\n\t */\n\ttest('returns only options whose type is in the subset, preserving original order', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlistOptionsArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(options, availableTypes) => {\n\t\t\t\t\tconst result = getFilteredListOptions(options, availableTypes);\n\n\t\t\t\t\t// Every returned option's type must be in availableTypes\n\t\t\t\t\tfor (const option of result) {\n\t\t\t\t\t\texpect(availableTypes).toContain(option.type);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Every option in the input whose type is in availableTypes must appear\n\t\t\t\t\tconst expectedOptions = options.filter((o) =>\n\t\t\t\t\t\tavailableTypes.includes(o.type)\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toHaveLength(expectedOptions.length);\n\n\t\t\t\t\t// Order must be preserved\n\t\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\t\texpect(result[i]).toBe(expectedOptions[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 7: getActiveListType selection \n\ndescribe('Feature: list-dropdown-menu, Property 7: getActiveListType selection', () => {\n\t/**\n\t * **Validates: Requirements 2.6, 2.7**\n\t */\n\ttest('returns the first active type in the array, or undefined if none match', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorStateArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, availableTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = getActiveListType(editor as never, availableTypes);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBeUndefined();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, find the expected first matching type\n\t\t\t\t\tconst expected = availableTypes.find(\n\t\t\t\t\t\t(type) => type === editorState.activeType\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('returns undefined when no list type is active', () => {\n\t\tfc.assert(\n\t\t\tfc.property(listTypesSubsetArbitrary, (availableTypes) => {\n\t\t\t\tconst editor = {\n\t\t\t\t\tisEditable: true,\n\t\t\t\t\tisActive: () => false\n\t\t\t\t};\n\n\t\t\t\tconst result = getActiveListType(editor as never, availableTypes);\n\n\t\t\t\texpect(result).toBeUndefined();\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 8: shouldShowListDropdown guard \n\ndescribe('Feature: list-dropdown-menu, Property 8: shouldShowListDropdown guard', () => {\n\t/**\n\t * **Validates: Requirements 2.8**\n\t */\n\ttest('returns false when listInSchema is false or editor is null', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\tfc.boolean(),\n\t\t\t\tfc.boolean(),\n\t\t\t\t(listTypes, hideWhenUnavailable, canToggleAny) => {\n\t\t\t\t\t// Case 1: listInSchema is false (editor can be anything)\n\t\t\t\t\tconst editorObj = buildMockEditor({\n\t\t\t\t\t\ttype: 'editable',\n\t\t\t\t\t\tactiveType: undefined\n\t\t\t\t\t});\n\n\t\t\t\t\tconst resultNoSchema = shouldShowListDropdown({\n\t\t\t\t\t\teditor: editorObj as never,\n\t\t\t\t\t\tlistTypes,\n\t\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\t\tlistInSchema: false,\n\t\t\t\t\t\tcanToggleAny\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(resultNoSchema).toBe(false);\n\n\t\t\t\t\t// Case 2: editor is null (listInSchema can be anything)\n\t\t\t\t\tconst resultNullEditor = shouldShowListDropdown({\n\t\t\t\t\t\teditor: null,\n\t\t\t\t\t\tlistTypes,\n\t\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\t\tlistInSchema: true,\n\t\t\t\t\t\tcanToggleAny\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(resultNullEditor).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('returns false when both listInSchema is false and editor is null', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\tfc.boolean(),\n\t\t\t\tfc.boolean(),\n\t\t\t\t(listTypes, hideWhenUnavailable, canToggleAny) => {\n\t\t\t\t\tconst result = shouldShowListDropdown({\n\t\t\t\t\t\teditor: null,\n\t\t\t\t\t\tlistTypes,\n\t\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\t\tlistInSchema: false,\n\t\t\t\t\t\tcanToggleAny\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-mark.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { Subscript, Superscript } from 'lucide-react';\nimport { describe, expect, test } from 'vitest';\n\nimport { en } from '../../i18n/messages/en';\nimport {\n\tcanToggleMark,\n\tisMarkActive,\n\tMARK_SHORTCUT_KEYS,\n\tmarkIcons,\n\ttoggleMark\n} from '../use-mark';\n\nimport type { Dictionary } from '../../i18n/types';\nimport type { MarkType } from '../use-mark';\n\n//  All MarkType values \n\nconst ALL_MARK_TYPES: MarkType[] = [\n\t'bold',\n\t'italic',\n\t'underline',\n\t'strike',\n\t'code',\n\t'superscript',\n\t'subscript'\n];\n\n//  Shared arbitraries \n\nconst markTypeArbitrary: fc.Arbitrary<MarkType> = fc.constantFrom(\n\t...ALL_MARK_TYPES\n);\n\n//  Property 1: canToggleMark and toggleMark guard conditions \n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tmarks: { get: () => ({}) },\n\t\t\t\t\tnodes: { get: () => ({}) }\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but mark type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tmarks: { get: () => undefined },\n\t\t\t\tnodes: { get: () => ({}) }\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 1: canToggleMark and toggleMark guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 1.1, 1.2, 1.7, 1.8**\n\t */\n\ttest('canToggleMark returns false when editor is null, not editable, or mark type not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tmarkTypeArbitrary,\n\t\t\t\t(editorState, markType) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggleMark(editor as never, markType);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('when canToggleMark returns false, toggleMark also returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tmarkTypeArbitrary,\n\t\t\t\t(editorState, markType) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggleMark(editor as never, markType);\n\t\t\t\t\tconst toggleResult = toggleMark(editor as never, markType);\n\n\t\t\t\t\t// Guard states always make canToggleMark return false\n\t\t\t\t\texpect(canToggleResult).toBe(false);\n\t\t\t\t\t// When canToggleMark is false, toggleMark must also be false\n\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 2: isMarkActive guard and delegation \n\ntype IsMarkActiveEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeType: MarkType | undefined };\n\nconst isMarkActiveEditorArbitrary: fc.Arbitrary<IsMarkActiveEditorState> =\n\tfc.oneof(\n\t\tfc.constant<IsMarkActiveEditorState>({ type: 'null' }),\n\t\tfc.constant<IsMarkActiveEditorState>({ type: 'not-editable' }),\n\t\tfc.record<IsMarkActiveEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveType: fc.option(markTypeArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildIsMarkActiveEditor(state: IsMarkActiveEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string) => {\n\t\t\tif (state.activeType === undefined) return false;\n\n\t\t\treturn name === state.activeType;\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 2: isMarkActive guard and delegation', () => {\n\t/**\n\t * **Validates: Requirements 1.5, 1.6**\n\t */\n\ttest('isMarkActive returns false when editor is null or not editable, and correctly delegates to editor.isActive when editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tisMarkActiveEditorArbitrary,\n\t\t\t\tmarkTypeArbitrary,\n\t\t\t\t(editorState, markType) => {\n\t\t\t\t\tconst editor = buildIsMarkActiveEditor(editorState);\n\t\t\t\t\tconst result = isMarkActive(editor as never, markType);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBe(false);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, verify delegation to editor.isActive\n\t\t\t\t\tconst expected = editorState.activeType === markType;\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Feature: superscript-subscript \n\n// The expected i18n key pattern for each mark type\nconst MARK_LABEL_KEY_PATTERN: Record<MarkType, keyof Dictionary> = {\n\tbold: 'mark.bold',\n\titalic: 'mark.italic',\n\tunderline: 'mark.underline',\n\tstrike: 'mark.strike',\n\tcode: 'mark.code',\n\tsuperscript: 'mark.superscript',\n\tsubscript: 'mark.subscript'\n};\n\ndescribe('Feature: superscript-subscript, Property 1: Mark configuration completeness invariant', () => {\n\t/**\n\t * **Validates: Requirements 2.1, 2.2, 2.3, 2.4, 2.5**\n\t */\n\ttest('every MarkType value has a corresponding entry in markIcons, MARK_SHORTCUT_KEYS, and i18n dictionary', () => {\n\t\tfc.assert(\n\t\t\tfc.property(markTypeArbitrary, (markType) => {\n\t\t\t\t// markIcons must have an entry for this mark type\n\t\t\t\texpect(markIcons[markType]).toBeDefined();\n\t\t\t\texpect(markIcons[markType]).not.toBeNull();\n\n\t\t\t\t// MARK_SHORTCUT_KEYS must have an entry for this mark type\n\t\t\t\texpect(MARK_SHORTCUT_KEYS[markType]).toBeDefined();\n\t\t\t\texpect(typeof MARK_SHORTCUT_KEYS[markType]).toBe('string');\n\t\t\t\texpect(MARK_SHORTCUT_KEYS[markType].length).toBeGreaterThan(0);\n\n\t\t\t\t// The i18n dictionary key for this mark type must exist in the en dictionary\n\t\t\t\tconst labelKey = MARK_LABEL_KEY_PATTERN[markType];\n\n\t\t\t\texpect(labelKey).toBeDefined();\n\t\t\t\texpect(en[labelKey]).toBeDefined();\n\t\t\t\texpect(typeof en[labelKey]).toBe('string');\n\t\t\t\texpect(en[labelKey].length).toBeGreaterThan(0);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\ndescribe('Feature: superscript-subscript, Unit tests: superscript and subscript mark configuration', () => {\n\t/**\n\t * **Validates: Requirements 2.2, 2.3**\n\t */\n\ttest('markIcons maps superscript to the Superscript icon', () => {\n\t\texpect(markIcons.superscript).toBe(Superscript);\n\t});\n\n\ttest('markIcons maps subscript to the Subscript icon', () => {\n\t\texpect(markIcons.subscript).toBe(Subscript);\n\t});\n\n\t/**\n\t * **Validates: Requirements 2.4, 2.5**\n\t */\n\ttest('MARK_SHORTCUT_KEYS maps superscript to mod+.', () => {\n\t\texpect(MARK_SHORTCUT_KEYS.superscript).toBe('mod+.');\n\t});\n\n\ttest('MARK_SHORTCUT_KEYS maps subscript to mod+,', () => {\n\t\texpect(MARK_SHORTCUT_KEYS.subscript).toBe('mod+,');\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-text-align.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canSetTextAlign, shouldShowTextAlignButton } from '../use-text-align';\n\nimport type { AlignmentType } from '../use-text-align';\n\nconst alignmentArbitrary: fc.Arbitrary<AlignmentType> = fc.constantFrom(\n\t'left',\n\t'center',\n\t'right',\n\t'justify'\n);\n\nfunction buildNonEditableEditor() {\n\treturn {\n\t\tisEditable: false,\n\t\textensionManager: {\n\t\t\textensions: [{ name: 'textAlign' }]\n\t\t},\n\t\tstate: { selection: { empty: true } },\n\t\tcan: () => ({\n\t\t\tsetTextAlign: () => true\n\t\t})\n\t};\n}\n\ndescribe('Feature: editor-extensions-text-align, Property 1: ', () => {\n\ttest('canSetTextAlign returns false for any alignment when editor is not editable', () => {\n\t\tconst editor = buildNonEditableEditor();\n\n\t\tfc.assert(\n\t\t\tfc.property(alignmentArbitrary, (alignment) => {\n\t\t\t\texpect(canSetTextAlign(editor as never, alignment)).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\nfunction buildEditorWithoutTextAlign() {\n\treturn {\n\t\tisEditable: true,\n\t\textensionManager: {\n\t\t\textensions: []\n\t\t},\n\t\tstate: { selection: { empty: true } },\n\t\tisActive: () => false\n\t};\n}\n\nconst hideWhenUnavailableArbitrary = fc.boolean();\n\ndescribe('Feature: editor-extensions-text-align, Property 2:  TextAlign ', () => {\n\ttest('shouldShowTextAlignButton returns false for any alignment when TextAlign extension is missing', () => {\n\t\tconst editor = buildEditorWithoutTextAlign();\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\talignmentArbitrary,\n\t\t\t\thideWhenUnavailableArbitrary,\n\t\t\t\t(alignment, hideWhenUnavailable) => {\n\t\t\t\t\tconst result = shouldShowTextAlignButton({\n\t\t\t\t\t\teditor: editor as never,\n\t\t\t\t\t\talignment,\n\t\t\t\t\t\thideWhenUnavailable\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "i18n/context.tsx",
      "content": "import { createContext, useContext, useMemo } from 'react';\n\nimport { de } from './messages/de';\nimport { en } from './messages/en';\nimport { es } from './messages/es';\nimport { fr } from './messages/fr';\nimport { ja } from './messages/ja';\nimport { ko } from './messages/ko';\nimport { pt } from './messages/pt';\nimport { ru } from './messages/ru';\nimport { zh } from './messages/zh';\n\nimport type { Dictionary, Locale } from './types';\nimport type { ReactNode } from 'react';\n\ninterface I18nProviderProps {\n\tlocale?: Locale;\n\tchildren: ReactNode;\n}\n\nconst builtinDictionaries: Record<Locale, Dictionary> = {\n\ten,\n\tzh,\n\tja,\n\tko,\n\tes,\n\tfr,\n\tde,\n\tpt,\n\tru\n};\n\nconst I18nContext = createContext<Dictionary>(en);\n\nexport function getDictionary(locale: string): Dictionary {\n\t// Avoid prototype keys like \"toString\" matching via `in` operator\n\treturn Object.prototype.hasOwnProperty.call(builtinDictionaries, locale)\n\t\t? builtinDictionaries[locale as Locale]\n\t\t: builtinDictionaries.en;\n}\n\nexport function I18nProvider({ locale = 'en', children }: I18nProviderProps) {\n\tconst dictionary = useMemo(() => getDictionary(locale), [locale]);\n\n\treturn (\n\t\t<I18nContext.Provider value={dictionary}>{children}</I18nContext.Provider>\n\t);\n}\n\nexport function useTranslation(): Dictionary {\n\treturn useContext(I18nContext);\n}\n"
    },
    {
      "path": "i18n/index.ts",
      "content": "export type { Dictionary, Locale } from './types';\nexport { I18nProvider, useTranslation, getDictionary } from './context';\nexport { de } from './messages/de';\nexport { en } from './messages/en';\nexport { es } from './messages/es';\nexport { fr } from './messages/fr';\nexport { ja } from './messages/ja';\nexport { ko } from './messages/ko';\nexport { pt } from './messages/pt';\nexport { ru } from './messages/ru';\nexport { zh } from './messages/zh';\n"
    },
    {
      "path": "i18n/messages/de.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const de = {\n\t'heading.1': 'berschrift 1',\n\t'heading.2': 'berschrift 2',\n\t'heading.3': 'berschrift 3',\n\t'heading.4': 'berschrift 4',\n\t'heading.5': 'berschrift 5',\n\t'heading.6': 'berschrift 6',\n\t'heading.dropdown.ariaLabel': 'Text als berschrift formatieren',\n\t'list.bullet': 'Aufzhlungsliste',\n\t'list.ordered': 'Nummerierte Liste',\n\t'list.task': 'Aufgabenliste',\n\t'list.dropdown.ariaLabel': 'Text als Liste formatieren',\n\t'mark.bold': 'Fett',\n\t'mark.italic': 'Kursiv',\n\t'mark.underline': 'Unterstrichen',\n\t'mark.strike': 'Durchgestrichen',\n\t'mark.code': 'Code',\n\t'mark.superscript': 'Hochgestellt',\n\t'mark.subscript': 'Tiefgestellt',\n\t'blockquote.label': 'Zitat',\n\t'codeBlock.label': 'Codeblock',\n\t'codeBlock.languageSelect.placeholder': 'Sprache auswhlen',\n\t'codeBlock.languageSelect.searchPlaceholder': 'Sprache suchen...',\n\t'codeBlock.languageSelect.noResult': 'Keine Sprache gefunden.',\n\t'codeBlock.languageSelect.auto': 'Automatisch',\n\t'codeBlock.languageSelect.plaintext': 'Klartext',\n\t'undoRedo.undo': 'Rckgngig',\n\t'undoRedo.redo': 'Wiederherstellen',\n\t'editor.ariaLabel': 'Hauptinhaltsbereich, beginnen Sie mit der Eingabe.',\n\t'dragHandle.ariaLabel': 'Ziehen zum Neuanordnen',\n\t'textAlign.left': 'Linksbndig',\n\t'textAlign.center': 'Zentriert',\n\t'textAlign.right': 'Rechtsbndig',\n\t'textAlign.justify': 'Blocksatz',\n\t'placeholder.default': 'Schreiben Sie los...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/en.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const en = {\n\t'heading.1': 'Heading 1',\n\t'heading.2': 'Heading 2',\n\t'heading.3': 'Heading 3',\n\t'heading.4': 'Heading 4',\n\t'heading.5': 'Heading 5',\n\t'heading.6': 'Heading 6',\n\t'heading.dropdown.ariaLabel': 'Format text as heading',\n\t'list.bullet': 'Bullet List',\n\t'list.ordered': 'Ordered List',\n\t'list.task': 'Task List',\n\t'list.dropdown.ariaLabel': 'Format text as list',\n\t'mark.bold': 'Bold',\n\t'mark.italic': 'Italic',\n\t'mark.underline': 'Underline',\n\t'mark.strike': 'Strikethrough',\n\t'mark.code': 'Code',\n\t'mark.superscript': 'Superscript',\n\t'mark.subscript': 'Subscript',\n\t'blockquote.label': 'Blockquote',\n\t'codeBlock.label': 'Code Block',\n\t'codeBlock.languageSelect.placeholder': 'Select language',\n\t'codeBlock.languageSelect.searchPlaceholder': 'Search language...',\n\t'codeBlock.languageSelect.noResult': 'No language found.',\n\t'codeBlock.languageSelect.auto': 'Auto',\n\t'codeBlock.languageSelect.plaintext': 'Plain Text',\n\t'undoRedo.undo': 'Undo',\n\t'undoRedo.redo': 'Redo',\n\t'editor.ariaLabel': 'Main content area, start typing to enter text.',\n\t'dragHandle.ariaLabel': 'Drag to reorder',\n\t'textAlign.left': 'Align Left',\n\t'textAlign.center': 'Align Center',\n\t'textAlign.right': 'Align Right',\n\t'textAlign.justify': 'Justify',\n\t'placeholder.default': 'Start writing...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/es.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const es = {\n\t'heading.1': 'Encabezado 1',\n\t'heading.2': 'Encabezado 2',\n\t'heading.3': 'Encabezado 3',\n\t'heading.4': 'Encabezado 4',\n\t'heading.5': 'Encabezado 5',\n\t'heading.6': 'Encabezado 6',\n\t'heading.dropdown.ariaLabel': 'Formatear texto como encabezado',\n\t'list.bullet': 'Lista con vietas',\n\t'list.ordered': 'Lista numerada',\n\t'list.task': 'Lista de tareas',\n\t'list.dropdown.ariaLabel': 'Formatear texto como lista',\n\t'mark.bold': 'Negrita',\n\t'mark.italic': 'Cursiva',\n\t'mark.underline': 'Subrayado',\n\t'mark.strike': 'Tachado',\n\t'mark.code': 'Cdigo',\n\t'mark.superscript': 'Superndice',\n\t'mark.subscript': 'Subndice',\n\t'blockquote.label': 'Cita',\n\t'codeBlock.label': 'Bloque de cdigo',\n\t'codeBlock.languageSelect.placeholder': 'Seleccionar idioma',\n\t'codeBlock.languageSelect.searchPlaceholder': 'Buscar idioma...',\n\t'codeBlock.languageSelect.noResult': 'No se encontr ningn idioma.',\n\t'codeBlock.languageSelect.auto': 'Automtico',\n\t'codeBlock.languageSelect.plaintext': 'Texto plano',\n\t'undoRedo.undo': 'Deshacer',\n\t'undoRedo.redo': 'Rehacer',\n\t'editor.ariaLabel': 'rea de contenido principal, comience a escribir.',\n\t'dragHandle.ariaLabel': 'Arrastrar para reordenar',\n\t'textAlign.left': 'Alinear a la izquierda',\n\t'textAlign.center': 'Centrar',\n\t'textAlign.right': 'Alinear a la derecha',\n\t'textAlign.justify': 'Justificar',\n\t'placeholder.default': 'Empieza a escribir...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/fr.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const fr = {\n\t'heading.1': 'Titre 1',\n\t'heading.2': 'Titre 2',\n\t'heading.3': 'Titre 3',\n\t'heading.4': 'Titre 4',\n\t'heading.5': 'Titre 5',\n\t'heading.6': 'Titre 6',\n\t'heading.dropdown.ariaLabel': 'Formater le texte en titre',\n\t'list.bullet': 'Liste  puces',\n\t'list.ordered': 'Liste numrote',\n\t'list.task': 'Liste de tches',\n\t'list.dropdown.ariaLabel': 'Formater le texte en liste',\n\t'mark.bold': 'Gras',\n\t'mark.italic': 'Italique',\n\t'mark.underline': 'Soulign',\n\t'mark.strike': 'Barr',\n\t'mark.code': 'Code',\n\t'mark.superscript': 'Exposant',\n\t'mark.subscript': 'Indice',\n\t'blockquote.label': 'Citation',\n\t'codeBlock.label': 'Bloc de code',\n\t'codeBlock.languageSelect.placeholder': 'Slectionner la langue',\n\t'codeBlock.languageSelect.searchPlaceholder': 'Rechercher une langue...',\n\t'codeBlock.languageSelect.noResult': 'Aucune langue trouve.',\n\t'codeBlock.languageSelect.auto': 'Automatique',\n\t'codeBlock.languageSelect.plaintext': 'Texte brut',\n\t'undoRedo.undo': 'Annuler',\n\t'undoRedo.redo': 'Rtablir',\n\t'editor.ariaLabel':\n\t\t'Zone de contenu principale, commencez  saisir du texte.',\n\t'dragHandle.ariaLabel': 'Glisser pour rorganiser',\n\t'textAlign.left': 'Aligner  gauche',\n\t'textAlign.center': 'Centrer',\n\t'textAlign.right': 'Aligner  droite',\n\t'textAlign.justify': 'Justifier',\n\t'placeholder.default': 'Commencez  crire...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/ja.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const ja = {\n\t'heading.1': ' 1',\n\t'heading.2': ' 2',\n\t'heading.3': ' 3',\n\t'heading.4': ' 4',\n\t'heading.5': ' 5',\n\t'heading.6': ' 6',\n\t'heading.dropdown.ariaLabel': '',\n\t'list.bullet': '',\n\t'list.ordered': '',\n\t'list.task': '',\n\t'list.dropdown.ariaLabel': '',\n\t'mark.bold': '',\n\t'mark.italic': '',\n\t'mark.underline': '',\n\t'mark.strike': '',\n\t'mark.code': '',\n\t'mark.superscript': '',\n\t'mark.subscript': '',\n\t'blockquote.label': '',\n\t'codeBlock.label': '',\n\t'codeBlock.languageSelect.placeholder': '',\n\t'codeBlock.languageSelect.searchPlaceholder': '...',\n\t'codeBlock.languageSelect.noResult': '',\n\t'codeBlock.languageSelect.auto': '',\n\t'codeBlock.languageSelect.plaintext': '',\n\t'undoRedo.undo': '',\n\t'undoRedo.redo': '',\n\t'editor.ariaLabel': '',\n\t'dragHandle.ariaLabel': '',\n\t'textAlign.left': '',\n\t'textAlign.center': '',\n\t'textAlign.right': '',\n\t'textAlign.justify': '',\n\t'placeholder.default': '...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/ko.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const ko = {\n\t'heading.1': ' 1',\n\t'heading.2': ' 2',\n\t'heading.3': ' 3',\n\t'heading.4': ' 4',\n\t'heading.5': ' 5',\n\t'heading.6': ' 6',\n\t'heading.dropdown.ariaLabel': '   ',\n\t'list.bullet': '  ',\n\t'list.ordered': '  ',\n\t'list.task': ' ',\n\t'list.dropdown.ariaLabel': '   ',\n\t'mark.bold': '',\n\t'mark.italic': '',\n\t'mark.underline': '',\n\t'mark.strike': '',\n\t'mark.code': '',\n\t'mark.superscript': ' ',\n\t'mark.subscript': ' ',\n\t'blockquote.label': '',\n\t'codeBlock.label': ' ',\n\t'codeBlock.languageSelect.placeholder': ' ',\n\t'codeBlock.languageSelect.searchPlaceholder': ' ...',\n\t'codeBlock.languageSelect.noResult': '   .',\n\t'codeBlock.languageSelect.auto': '',\n\t'codeBlock.languageSelect.plaintext': ' ',\n\t'undoRedo.undo': ' ',\n\t'undoRedo.redo': ' ',\n\t'editor.ariaLabel': ' ,  .',\n\t'dragHandle.ariaLabel': '  ',\n\t'textAlign.left': ' ',\n\t'textAlign.center': ' ',\n\t'textAlign.right': ' ',\n\t'textAlign.justify': ' ',\n\t'placeholder.default': ' ...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/pt.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const pt = {\n\t'heading.1': 'Ttulo 1',\n\t'heading.2': 'Ttulo 2',\n\t'heading.3': 'Ttulo 3',\n\t'heading.4': 'Ttulo 4',\n\t'heading.5': 'Ttulo 5',\n\t'heading.6': 'Ttulo 6',\n\t'heading.dropdown.ariaLabel': 'Formatar texto como ttulo',\n\t'list.bullet': 'Lista com marcadores',\n\t'list.ordered': 'Lista numerada',\n\t'list.task': 'Lista de tarefas',\n\t'list.dropdown.ariaLabel': 'Formatar texto como lista',\n\t'mark.bold': 'Negrito',\n\t'mark.italic': 'Itlico',\n\t'mark.underline': 'Sublinhado',\n\t'mark.strike': 'Tachado',\n\t'mark.code': 'Cdigo',\n\t'mark.superscript': 'Sobrescrito',\n\t'mark.subscript': 'Subscrito',\n\t'blockquote.label': 'Citao',\n\t'codeBlock.label': 'Bloco de cdigo',\n\t'codeBlock.languageSelect.placeholder': 'Selecionar idioma',\n\t'codeBlock.languageSelect.searchPlaceholder': 'Pesquisar idioma...',\n\t'codeBlock.languageSelect.noResult': 'Nenhum idioma encontrado.',\n\t'codeBlock.languageSelect.auto': 'Automtico',\n\t'codeBlock.languageSelect.plaintext': 'Texto simples',\n\t'undoRedo.undo': 'Desfazer',\n\t'undoRedo.redo': 'Refazer',\n\t'editor.ariaLabel': 'rea de contedo principal, comece a digitar.',\n\t'dragHandle.ariaLabel': 'Arrastar para reordenar',\n\t'textAlign.left': 'Alinhar  esquerda',\n\t'textAlign.center': 'Centralizar',\n\t'textAlign.right': 'Alinhar  direita',\n\t'textAlign.justify': 'Justificar',\n\t'placeholder.default': 'Comece a escrever...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/ru.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const ru = {\n\t'heading.1': ' 1',\n\t'heading.2': ' 2',\n\t'heading.3': ' 3',\n\t'heading.4': ' 4',\n\t'heading.5': ' 5',\n\t'heading.6': ' 6',\n\t'heading.dropdown.ariaLabel': '   ',\n\t'list.bullet': ' ',\n\t'list.ordered': ' ',\n\t'list.task': ' ',\n\t'list.dropdown.ariaLabel': '   ',\n\t'mark.bold': '',\n\t'mark.italic': '',\n\t'mark.underline': '',\n\t'mark.strike': '',\n\t'mark.code': '',\n\t'mark.superscript': '',\n\t'mark.subscript': '',\n\t'blockquote.label': '',\n\t'codeBlock.label': ' ',\n\t'codeBlock.languageSelect.placeholder': ' ',\n\t'codeBlock.languageSelect.searchPlaceholder': ' ...',\n\t'codeBlock.languageSelect.noResult': '  .',\n\t'codeBlock.languageSelect.auto': '',\n\t'codeBlock.languageSelect.plaintext': ' ',\n\t'undoRedo.undo': '',\n\t'undoRedo.redo': '',\n\t'editor.ariaLabel': '  ,   .',\n\t'dragHandle.ariaLabel': '   ',\n\t'textAlign.left': '  ',\n\t'textAlign.center': ' ',\n\t'textAlign.right': '  ',\n\t'textAlign.justify': ' ',\n\t'placeholder.default': ' ...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/zh.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const zh = {\n\t'heading.1': '',\n\t'heading.2': '',\n\t'heading.3': '',\n\t'heading.4': '',\n\t'heading.5': '',\n\t'heading.6': '',\n\t'heading.dropdown.ariaLabel': '',\n\t'list.bullet': '',\n\t'list.ordered': '',\n\t'list.task': '',\n\t'list.dropdown.ariaLabel': '',\n\t'mark.bold': '',\n\t'mark.italic': '',\n\t'mark.underline': '',\n\t'mark.strike': '',\n\t'mark.code': '',\n\t'mark.superscript': '',\n\t'mark.subscript': '',\n\t'blockquote.label': '',\n\t'codeBlock.label': '',\n\t'codeBlock.languageSelect.placeholder': '',\n\t'codeBlock.languageSelect.searchPlaceholder': '...',\n\t'codeBlock.languageSelect.noResult': '',\n\t'codeBlock.languageSelect.auto': '',\n\t'codeBlock.languageSelect.plaintext': '',\n\t'undoRedo.undo': '',\n\t'undoRedo.redo': '',\n\t'editor.ariaLabel': '',\n\t'dragHandle.ariaLabel': '',\n\t'textAlign.left': '',\n\t'textAlign.center': '',\n\t'textAlign.right': '',\n\t'textAlign.justify': '',\n\t'placeholder.default': '...'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/types.ts",
      "content": "export interface Dictionary {\n\t'heading.1': string;\n\t'heading.2': string;\n\t'heading.3': string;\n\t'heading.4': string;\n\t'heading.5': string;\n\t'heading.6': string;\n\t'heading.dropdown.ariaLabel': string;\n\t'list.bullet': string;\n\t'list.ordered': string;\n\t'list.task': string;\n\t'list.dropdown.ariaLabel': string;\n\t'mark.bold': string;\n\t'mark.italic': string;\n\t'mark.underline': string;\n\t'mark.strike': string;\n\t'mark.code': string;\n\t'mark.superscript': string;\n\t'mark.subscript': string;\n\t'blockquote.label': string;\n\t'codeBlock.label': string;\n\t'codeBlock.languageSelect.placeholder': string;\n\t'codeBlock.languageSelect.searchPlaceholder': string;\n\t'codeBlock.languageSelect.noResult': string;\n\t'codeBlock.languageSelect.auto': string;\n\t'codeBlock.languageSelect.plaintext': string;\n\t'undoRedo.undo': string;\n\t'undoRedo.redo': string;\n\t'editor.ariaLabel': string;\n\t'dragHandle.ariaLabel': string;\n\t'textAlign.left': string;\n\t'textAlign.center': string;\n\t'textAlign.right': string;\n\t'textAlign.justify': string;\n\t'placeholder.default': string;\n}\n\nexport type Locale =\n\t| 'en'\n\t| 'zh'\n\t| 'ja'\n\t| 'ko'\n\t| 'es'\n\t| 'fr'\n\t| 'de'\n\t| 'pt'\n\t| 'ru';\n"
    },
    {
      "path": "i18n/__tests__/i18n.test.ts",
      "content": "import fc from 'fast-check';\nimport { describe, expect, it } from 'vitest';\n\nimport { getDictionary } from '../context';\nimport { de } from '../messages/de';\nimport { en } from '../messages/en';\nimport { es } from '../messages/es';\nimport { fr } from '../messages/fr';\nimport { ja } from '../messages/ja';\nimport { ko } from '../messages/ko';\nimport { pt } from '../messages/pt';\nimport { ru } from '../messages/ru';\nimport { zh } from '../messages/zh';\n\nimport type { Dictionary, Locale } from '../types';\n\n/**\n * **Feature: editor-i18n, Property 1: **\n * **Validates: Requirements 1.2, 1.3, 1.4**\n */\n\nconst expectedKeys: (keyof Dictionary)[] = [\n\t'heading.1',\n\t'heading.2',\n\t'heading.3',\n\t'heading.4',\n\t'heading.5',\n\t'heading.6',\n\t'heading.dropdown.ariaLabel',\n\t'undoRedo.undo',\n\t'undoRedo.redo',\n\t'editor.ariaLabel'\n];\n\nconst builtinDictionaries: Record<string, Dictionary> = {\n\ten,\n\tzh,\n\tja,\n\tko,\n\tes,\n\tfr,\n\tde,\n\tpt,\n\tru\n};\n\ndescribe('Property 1: ', () => {\n\tit.each(Object.entries(builtinDictionaries))(\n\t\t'%s dictionary contains all required keys',\n\t\t(_locale, dict) => {\n\t\t\tconst keys = Object.keys(dict);\n\n\t\t\tfor (const key of expectedKeys) {\n\t\t\t\texpect(keys).toContain(key);\n\t\t\t}\n\t\t}\n\t);\n\n\tit.each(Object.entries(builtinDictionaries))(\n\t\t'%s dictionary has only non-empty string values',\n\t\t(_locale, dict) => {\n\t\t\tfor (const key of expectedKeys) {\n\t\t\t\tconst value = dict[key];\n\n\t\t\t\texpect(typeof value).toBe('string');\n\t\t\t\texpect(value.length).toBeGreaterThan(0);\n\t\t\t}\n\t\t}\n\t);\n});\n\n/**\n * **Feature: editor-i18n, Property 2: Locale **\n * **Validates: Requirements 2.2**\n */\n\nconst localeArbitrary: fc.Arbitrary<Locale> = fc.constantFrom(\n\t'en',\n\t'zh',\n\t'ja',\n\t'ko',\n\t'es',\n\t'fr',\n\t'de',\n\t'pt',\n\t'ru'\n);\n\nconst localeDictionaryMap: Record<Locale, Dictionary> = {\n\ten,\n\tzh,\n\tja,\n\tko,\n\tes,\n\tfr,\n\tde,\n\tpt,\n\tru\n};\n\ndescribe('Property 2: Locale ', () => {\n\tit('getDictionary(locale) returns the exact built-in dictionary for that locale', () => {\n\t\tfc.assert(\n\t\t\tfc.property(localeArbitrary, (locale) => {\n\t\t\t\tconst result = getDictionary(locale);\n\t\t\t\tconst expected = localeDictionaryMap[locale];\n\n\t\t\t\texpect(result).toEqual(expected);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: editor-i18n, Property 3:  Locale **\n * **Validates: Requirements 2.4**\n */\n\nconst invalidLocaleArbitrary: fc.Arbitrary<string> = fc\n\t.string()\n\t.filter(\n\t\t(s) => !['en', 'zh', 'ja', 'ko', 'es', 'fr', 'de', 'pt', 'ru'].includes(s)\n\t);\n\ndescribe('Property 3:  Locale ', () => {\n\tit('getDictionary returns the English dictionary for any unsupported locale', () => {\n\t\tfc.assert(\n\t\t\tfc.property(invalidLocaleArbitrary, (locale) => {\n\t\t\t\tconst result = getDictionary(locale);\n\n\t\t\t\texpect(result).toEqual(en);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: editor-i18n, Property 4: Dictionary JSON **\n * **Validates: Requirements 5.1**\n */\n\nconst dictionaryKeys: (keyof Dictionary)[] = [\n\t'heading.1',\n\t'heading.2',\n\t'heading.3',\n\t'heading.4',\n\t'heading.5',\n\t'heading.6',\n\t'heading.dropdown.ariaLabel',\n\t'undoRedo.undo',\n\t'undoRedo.redo',\n\t'editor.ariaLabel'\n];\n\nconst dictionaryArbitrary: fc.Arbitrary<Dictionary> = fc.record(\n\tObject.fromEntries(\n\t\tdictionaryKeys.map((key) => [key, fc.string({ minLength: 1 })])\n\t) as Record<keyof Dictionary, fc.Arbitrary<string>>\n);\n\ndescribe('Property 5: Dictionary JSON ', () => {\n\tit('JSON.parse(JSON.stringify(dict)) produces a deeply equal result', () => {\n\t\tfc.assert(\n\t\t\tfc.property(dictionaryArbitrary, (dict) => {\n\t\t\t\tconst roundTripped = JSON.parse(JSON.stringify(dict));\n\n\t\t\t\texpect(roundTripped).toEqual(dict);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: editor-extensions-text-align, Property 3: **\n * **Validates: Requirements 6.1, 6.2, 6.3, 6.4**\n */\n\nconst textAlignKeys: (keyof Dictionary)[] = [\n\t'textAlign.left',\n\t'textAlign.center',\n\t'textAlign.right',\n\t'textAlign.justify'\n];\n\nconst localeEntries = Object.entries(builtinDictionaries) as [\n\tstring,\n\tDictionary\n][];\n\nconst localeNameArbitrary: fc.Arbitrary<string> = fc.constantFrom(\n\t...localeEntries.map(([name]) => name)\n);\n\ndescribe('Property 3: ', () => {\n\tit('every built-in locale dictionary contains all textAlign keys with non-empty string values', () => {\n\t\tfc.assert(\n\t\t\tfc.property(localeNameArbitrary, (localeName) => {\n\t\t\t\tconst dict = builtinDictionaries[localeName];\n\n\t\t\t\tfor (const key of textAlignKeys) {\n\t\t\t\t\tconst value = dict[key];\n\n\t\t\t\t\texpect(typeof value).toBe('string');\n\t\t\t\t\texpect(value.length).toBeGreaterThan(0);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: trailing-node-and-placeholder, Property 1: All supported locales have placeholder text**\n * **Validates: Requirements 3.5**\n */\n\ndescribe('Property 1: All supported locales have placeholder text', () => {\n\tit('getDictionary(locale) returns a dictionary with a non-empty placeholder.default for any supported locale', () => {\n\t\tfc.assert(\n\t\t\tfc.property(localeArbitrary, (locale) => {\n\t\t\t\tconst dict = getDictionary(locale);\n\t\t\t\tconst value = dict['placeholder.default'];\n\n\t\t\t\texpect(typeof value).toBe('string');\n\t\t\t\texpect(value.length).toBeGreaterThan(0);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\ndescribe('Placeholder i18n unit tests', () => {\n\tit('en placeholder.default returns \"Start writing...\"', () => {\n\t\texpect(getDictionary('en')['placeholder.default']).toBe('Start writing...');\n\t});\n\n\tit('zh placeholder.default returns \"...\"', () => {\n\t\texpect(getDictionary('zh')['placeholder.default']).toBe('...');\n\t});\n\n\tit('ja placeholder.default returns \"...\"', () => {\n\t\texpect(getDictionary('ja')['placeholder.default']).toBe('...');\n\t});\n});\n"
    },
    {
      "path": "lib/utils.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nimport type { Editor } from '@tiptap/core';\nimport type { Node as TiptapNode } from '@tiptap/pm/model';\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n\nexport function isExtensionAvailable(\n\teditor: Editor | null,\n\textensionNames: string | string[]\n): boolean {\n\tif (!editor) return false;\n\n\tconst names = Array.isArray(extensionNames)\n\t\t? extensionNames\n\t\t: [extensionNames];\n\n\tconst found = names.some((name) =>\n\t\teditor.extensionManager.extensions.some((ext) => ext.name === name)\n\t);\n\n\tif (!found) {\n\t\tconsole.warn(\n\t\t\t`None of the extensions [${names.join(', ')}] were found in the editor schema. Ensure they are included in the editor configuration.`\n\t\t);\n\t}\n\n\treturn found;\n}\n\nexport function isNodeInSchema(\n\tnodeName: string,\n\teditor: Editor | null\n): boolean {\n\tif (!editor?.schema) return false;\n\n\treturn editor.schema.spec.nodes.get(nodeName) !== undefined;\n}\n\nexport function isMarkInSchema(\n\tmarkName: string,\n\teditor: Editor | null\n): boolean {\n\tif (!editor?.schema) return false;\n\n\treturn editor.schema.spec.marks.get(markName) !== undefined;\n}\n\nexport function isNodeTypeSelected(\n\teditor: Editor | null,\n\ttypes: string[] = []\n): boolean {\n\tif (!editor || !editor.state.selection) return false;\n\n\tconst { state } = editor;\n\tconst { selection } = state;\n\n\tif (selection.empty) return false;\n\n\tif (selection instanceof NodeSelection) {\n\t\tconst node = selection.node;\n\n\t\treturn node ? types.includes(node.type.name) : false;\n\t}\n\n\treturn false;\n}\n\nexport function isValidPosition(pos: number | null | undefined): pos is number {\n\treturn typeof pos === 'number' && pos >= 0;\n}\n\nexport function findNodeAtPosition(editor: Editor, position: number) {\n\ttry {\n\t\tconst node = editor.state.doc.nodeAt(position);\n\n\t\tif (!node) {\n\t\t\tconsole.warn(`No node found at position ${position}`);\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn node;\n\t} catch (error) {\n\t\tconsole.error(`Error getting node at position ${position}:`, error);\n\n\t\treturn null;\n\t}\n}\n\nexport function findNodePosition(props: {\n\teditor: Editor | null;\n\tnode?: TiptapNode | null;\n\tnodePos?: number | null;\n}): { pos: number; node: TiptapNode } | null {\n\tconst { editor, node, nodePos } = props;\n\n\tif (!editor || !editor.state?.doc) return null;\n\n\tconst hasValidNode = node !== undefined && node !== null;\n\tconst hasValidPos = isValidPosition(nodePos);\n\n\tif (!hasValidNode && !hasValidPos) {\n\t\treturn null;\n\t}\n\n\tif (hasValidNode) {\n\t\tlet foundPos = -1;\n\t\tlet foundNode: TiptapNode | null = null;\n\n\t\teditor.state.doc.descendants((currentNode, pos) => {\n\t\t\tif (currentNode === node) {\n\t\t\t\tfoundPos = pos;\n\t\t\t\tfoundNode = currentNode;\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (foundPos !== -1 && foundNode !== null) {\n\t\t\treturn { pos: foundPos, node: foundNode };\n\t\t}\n\t}\n\n\tif (hasValidPos) {\n\t\tconst nodeAtPos = findNodeAtPosition(editor, nodePos!);\n\n\t\tif (nodeAtPos) {\n\t\t\treturn { pos: nodePos!, node: nodeAtPos };\n\t\t}\n\t}\n\n\treturn null;\n}\n\ntype ProtocolOptions = {\n\tscheme: string;\n\toptionalSlashes?: boolean;\n};\n\ntype ProtocolConfig = Array<ProtocolOptions | string>;\n\n// Strip invisible Unicode whitespace that can bypass protocol detection\n\nconst ATTR_WHITESPACE =\n\t/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\n\nexport function isAllowedUri(\n\turi: string | undefined,\n\tprotocols?: ProtocolConfig\n): boolean {\n\tconst allowedProtocols: string[] = [\n\t\t'http',\n\t\t'https',\n\t\t'ftp',\n\t\t'ftps',\n\t\t'mailto',\n\t\t'tel',\n\t\t'callto',\n\t\t'sms',\n\t\t'cid',\n\t\t'xmpp'\n\t];\n\n\tif (protocols) {\n\t\tprotocols.forEach((protocol) => {\n\t\t\tconst nextProtocol =\n\t\t\t\ttypeof protocol === 'string' ? protocol : protocol.scheme;\n\n\t\t\tif (nextProtocol) {\n\t\t\t\tallowedProtocols.push(nextProtocol);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn (\n\t\t!uri ||\n\t\t!!uri\n\t\t\t.replace(ATTR_WHITESPACE, '')\n\t\t\t.match(\n\t\t\t\tnew RegExp(\n\t\t\t\t\t`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\\\-]+(?:[^a-z+.\\\\-:]|$))`,\n\t\t\t\t\t'i'\n\t\t\t\t)\n\t\t\t)\n\t);\n}\n\nexport function sanitizeUrl(\n\tinputUrl: string,\n\tbaseUrl: string,\n\tprotocols?: ProtocolConfig\n): string {\n\ttry {\n\t\tconst url = new URL(inputUrl, baseUrl);\n\n\t\tif (isAllowedUri(url.href, protocols)) {\n\t\t\treturn url.href;\n\t\t}\n\t} catch {\n\t\t// Invalid URL\n\t}\n\n\treturn '#';\n}\n"
    },
    {
      "path": "lib/__tests__/utils.test.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport {\n\tisAllowedUri,\n\tisMarkInSchema,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition,\n\tsanitizeUrl\n} from '../utils';\n\n//  Property 2: isValidPosition \n\ndescribe('Feature: toolbar-components, Property 2: isValidPosition ', () => {\n\t/**\n\t * **Validates: Requirements 5.4**\n\t */\n\ttest('returns true if and only if value is a number >= 0', () => {\n\t\tconst valueArbitrary: fc.Arbitrary<number | null | undefined> = fc.oneof(\n\t\t\tfc.integer(),\n\t\t\tfc.double({ noNaN: false }),\n\t\t\tfc.constant(null),\n\t\t\tfc.constant(undefined)\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(valueArbitrary, (v) => {\n\t\t\t\tconst result = isValidPosition(v);\n\t\t\t\tconst expected = typeof v === 'number' && v >= 0;\n\n\t\t\t\texpect(result).toBe(expected);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 3: isNodeInSchema \n\n// Minimal mock for the Editor.schema.spec.nodes interface\ninterface MockEditor {\n\tschema: {\n\t\tspec: {\n\t\t\tnodes: { get: (name: string) => unknown };\n\t\t};\n\t};\n}\n\ntype EditorInput = { type: 'null' } | { type: 'present'; nodeNames: string[] };\n\nconst editorInputArbitrary: fc.Arbitrary<EditorInput> = fc.oneof(\n\tfc.constant<EditorInput>({ type: 'null' }),\n\tfc.record<EditorInput & { type: 'present' }>({\n\t\ttype: fc.constant('present' as const),\n\t\tnodeNames: fc.array(fc.string({ minLength: 1, maxLength: 20 }), {\n\t\t\tminLength: 0,\n\t\t\tmaxLength: 10\n\t\t})\n\t})\n);\n\nfunction buildMockEditorForSchema(input: EditorInput): MockEditor | null {\n\tif (input.type === 'null') return null;\n\n\tconst nodeSet = new Set(input.nodeNames);\n\n\treturn {\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: (name: string) => (nodeSet.has(name) ? {} : undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 3: isNodeInSchema ', () => {\n\t/**\n\t * **Validates: Requirements 5.1**\n\t */\n\ttest('returns true iff editor is non-null and schema.spec.nodes contains the name', () => {\n\t\tconst nodeNameArbitrary = fc.string({ minLength: 1, maxLength: 20 });\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorInputArbitrary,\n\t\t\t\tnodeNameArbitrary,\n\t\t\t\t(editorInput, nodeName) => {\n\t\t\t\t\tconst editor = buildMockEditorForSchema(editorInput);\n\t\t\t\t\tconst result = isNodeInSchema(nodeName, editor as never);\n\n\t\t\t\t\tif (editorInput.type === 'null') {\n\t\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst expected = editorInput.nodeNames.includes(nodeName);\n\n\t\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 4: isNodeTypeSelected \n\ntype SelectionKind =\n\t| { kind: 'null-editor' }\n\t| { kind: 'empty' }\n\t| { kind: 'text' }\n\t| { kind: 'node'; nodeTypeName: string };\n\nconst selectionKindArbitrary: fc.Arbitrary<SelectionKind> = fc.oneof(\n\tfc.constant<SelectionKind>({ kind: 'null-editor' }),\n\tfc.constant<SelectionKind>({ kind: 'empty' }),\n\tfc.constant<SelectionKind>({ kind: 'text' }),\n\tfc.record<SelectionKind & { kind: 'node' }>({\n\t\tkind: fc.constant('node' as const),\n\t\tnodeTypeName: fc.string({ minLength: 1, maxLength: 20 })\n\t})\n);\n\nfunction buildMockEditorForSelection(sel: SelectionKind) {\n\tif (sel.kind === 'null-editor') return null;\n\n\tif (sel.kind === 'empty') {\n\t\treturn {\n\t\t\tstate: {\n\t\t\t\tselection: { empty: true }\n\t\t\t}\n\t\t};\n\t}\n\n\tif (sel.kind === 'text') {\n\t\t// Non-empty, non-NodeSelection\n\t\treturn {\n\t\t\tstate: {\n\t\t\t\tselection: { empty: false }\n\t\t\t}\n\t\t};\n\t}\n\n\t// NodeSelection  create an object that passes `instanceof NodeSelection`\n\tconst nodeSelection = Object.create(NodeSelection.prototype, {\n\t\tempty: { value: false, writable: false },\n\t\tnode: {\n\t\t\tvalue: { type: { name: sel.nodeTypeName } },\n\t\t\twritable: false\n\t\t}\n\t});\n\n\treturn {\n\t\tstate: { selection: nodeSelection }\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 4: isNodeTypeSelected ', () => {\n\t/**\n\t * **Validates: Requirements 5.2**\n\t */\n\ttest('returns true iff selection is a NodeSelection and node type name is in the types array', () => {\n\t\tconst typesArbitrary = fc.array(\n\t\t\tfc.string({ minLength: 1, maxLength: 20 }),\n\t\t\t{ minLength: 0, maxLength: 10 }\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(selectionKindArbitrary, typesArbitrary, (sel, types) => {\n\t\t\t\tconst editor = buildMockEditorForSelection(sel);\n\t\t\t\tconst result = isNodeTypeSelected(editor as never, types);\n\n\t\t\t\tif (sel.kind === 'null-editor') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else if (sel.kind === 'empty' || sel.kind === 'text') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else {\n\t\t\t\t\t// NodeSelection case\n\t\t\t\t\tconst expected = types.includes(sel.nodeTypeName);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  Property 4 (toolbar-formatting-buttons): isMarkInSchema \n\ntype MarkEditorInput =\n\t| { type: 'null' }\n\t| { type: 'no-schema' }\n\t| { type: 'present'; markNames: string[] };\n\nconst markEditorInputArbitrary: fc.Arbitrary<MarkEditorInput> = fc.oneof(\n\tfc.constant<MarkEditorInput>({ type: 'null' }),\n\tfc.constant<MarkEditorInput>({ type: 'no-schema' }),\n\tfc.record<MarkEditorInput & { type: 'present' }>({\n\t\ttype: fc.constant('present' as const),\n\t\tmarkNames: fc.array(fc.string({ minLength: 1, maxLength: 20 }), {\n\t\t\tminLength: 0,\n\t\t\tmaxLength: 10\n\t\t})\n\t})\n);\n\nfunction buildMockEditorForMarkSchema(\n\tinput: MarkEditorInput\n): Record<string, unknown> | null {\n\tif (input.type === 'null') return null;\n\n\tif (input.type === 'no-schema') return {};\n\n\tconst markSet = new Set(input.markNames);\n\n\treturn {\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tmarks: {\n\t\t\t\t\tget: (name: string) => (markSet.has(name) ? {} : undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 4: isMarkInSchema correctness', () => {\n\t/**\n\t * **Validates: Requirements 8.1, 8.2, 8.3**\n\t */\n\ttest('returns false when editor is null or schema does not exist', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constantFrom<MarkEditorInput>(\n\t\t\t\t\t{ type: 'null' },\n\t\t\t\t\t{ type: 'no-schema' }\n\t\t\t\t),\n\t\t\t\tfc.string({ minLength: 1, maxLength: 20 }),\n\t\t\t\t(editorInput, markName) => {\n\t\t\t\t\tconst editor = buildMockEditorForMarkSchema(editorInput);\n\t\t\t\t\tconst result = isMarkInSchema(markName, editor as never);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 8.2, 8.3**\n\t */\n\ttest('returns true iff editor is non-null with schema and marks spec contains the name', () => {\n\t\tconst markNameArbitrary = fc.string({ minLength: 1, maxLength: 20 });\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tmarkEditorInputArbitrary,\n\t\t\t\tmarkNameArbitrary,\n\t\t\t\t(editorInput, markName) => {\n\t\t\t\t\tconst editor = buildMockEditorForMarkSchema(editorInput);\n\t\t\t\t\tconst result = isMarkInSchema(markName, editor as never);\n\n\t\t\t\t\tif (editorInput.type === 'null' || editorInput.type === 'no-schema') {\n\t\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst expected = editorInput.markNames.includes(markName);\n\n\t\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n//  isAllowedUri \n\ndescribe('isAllowedUri', () => {\n\ttest('allows http and https URLs', () => {\n\t\texpect(isAllowedUri('https://example.com')).toBe(true);\n\t\texpect(isAllowedUri('http://example.com/path')).toBe(true);\n\t});\n\n\ttest('allows mailto, tel, and other safe protocols', () => {\n\t\texpect(isAllowedUri('mailto:user@example.com')).toBe(true);\n\t\texpect(isAllowedUri('tel:+1234567890')).toBe(true);\n\t\texpect(isAllowedUri('ftp://files.example.com')).toBe(true);\n\t});\n\n\ttest('blocks javascript: protocol', () => {\n\t\texpect(isAllowedUri('javascript:alert(1)')).toBe(false);\n\t});\n\n\ttest('blocks data: protocol', () => {\n\t\texpect(isAllowedUri('data:text/html,<script>alert(1)</script>')).toBe(\n\t\t\tfalse\n\t\t);\n\t});\n\n\ttest('blocks vbscript: protocol', () => {\n\t\texpect(isAllowedUri('vbscript:MsgBox(\"XSS\")')).toBe(false);\n\t});\n\n\ttest('allows undefined/empty input', () => {\n\t\texpect(isAllowedUri(undefined)).toBe(true);\n\t\texpect(isAllowedUri('')).toBe(true);\n\t});\n\n\ttest('allows relative paths', () => {\n\t\texpect(isAllowedUri('/about')).toBe(true);\n\t\texpect(isAllowedUri('./page')).toBe(true);\n\t\texpect(isAllowedUri('#section')).toBe(true);\n\t});\n\n\ttest('allows custom protocols via config', () => {\n\t\texpect(isAllowedUri('custom:something', ['custom'])).toBe(true);\n\t\texpect(isAllowedUri('myapp:open', [{ scheme: 'myapp' }])).toBe(true);\n\t});\n\n\ttest('strips invisible Unicode whitespace before checking', () => {\n\t\texpect(isAllowedUri('java\\u200Bscript:alert(1)')).toBe(false);\n\t});\n});\n\n//  sanitizeUrl \n\nconst BASE_URL = 'https://example.com';\n\ndescribe('sanitizeUrl', () => {\n\ttest('resolves absolute URLs', () => {\n\t\texpect(sanitizeUrl('https://example.com/page', BASE_URL)).toBe(\n\t\t\t'https://example.com/page'\n\t\t);\n\t});\n\n\ttest('resolves relative paths against baseUrl', () => {\n\t\texpect(sanitizeUrl('/about', BASE_URL)).toBe('https://example.com/about');\n\t\texpect(sanitizeUrl('./page', BASE_URL + '/docs/')).toBe(\n\t\t\t'https://example.com/docs/page'\n\t\t);\n\t});\n\n\ttest('returns \"#\" for dangerous protocols', () => {\n\t\texpect(sanitizeUrl('javascript:alert(1)', BASE_URL)).toBe('#');\n\t\texpect(sanitizeUrl('data:text/html,<h1>XSS</h1>', BASE_URL)).toBe('#');\n\t\texpect(sanitizeUrl('vbscript:run', BASE_URL)).toBe('#');\n\t});\n});\n\n//  Property: dangerous protocol sanitization \n\ndescribe('Property: dangerous URL sanitization', () => {\n\tconst dangerousProtocolArbitrary = fc.constantFrom(\n\t\t'javascript',\n\t\t'JavaScript',\n\t\t'JAVASCRIPT',\n\t\t'data',\n\t\t'Data',\n\t\t'DATA',\n\t\t'vbscript',\n\t\t'VBScript',\n\t\t'VBSCRIPT'\n\t);\n\n\tconst payloadArbitrary = fc.string({ minLength: 0, maxLength: 50 });\n\n\ttest('returns \"#\" for any URL with a dangerous protocol', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tdangerousProtocolArbitrary,\n\t\t\t\tpayloadArbitrary,\n\t\t\t\t(protocol, payload) => {\n\t\t\t\t\tconst url = `${protocol}:${payload}`;\n\n\t\t\t\t\texpect(sanitizeUrl(url, BASE_URL)).toBe('#');\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n//  Property: safe URL round-trip \n\ndescribe('Property: safe URL round-trip', () => {\n\tconst safeUrlArbitrary = fc\n\t\t.constantFrom('http', 'https')\n\t\t.chain((protocol) =>\n\t\t\tfc\n\t\t\t\t.domain()\n\t\t\t\t.chain((domain) =>\n\t\t\t\t\tfc\n\t\t\t\t\t\t.webPath()\n\t\t\t\t\t\t.map((path) =>\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t\t? `${protocol}://${domain}${path}`\n\t\t\t\t\t\t\t\t: `${protocol}://${domain}`\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\ttest('preserves any safe http/https URL after normalization', () => {\n\t\tfc.assert(\n\t\t\tfc.property(safeUrlArbitrary, (url) => {\n\t\t\t\tconst result = sanitizeUrl(url, BASE_URL);\n\t\t\t\tconst normalized = new URL(url).href;\n\n\t\t\t\texpect(result).toBe(normalized);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "styles/base.css",
      "content": ".notra-editor .tiptap {\n\twhite-space: pre-wrap;\n\toutline: none;\n\tcolor: var(--notra-text);\n\tcaret-color: var(--notra-brand-500);\n\n\t.dark &,\n\t&.dark {\n\t\tcaret-color: var(--notra-brand-400);\n\t}\n\n\t@media (prefers-color-scheme: dark) {\n\t\t&:not(.light) {\n\t\t\tcaret-color: var(--notra-brand-400);\n\t\t}\n\t}\n\n\t& > * {\n\t\tposition: relative;\n\t}\n\n\t&:not(.ProseMirror-hideselection) {\n\t\t::selection {\n\t\t\tbackground-color: var(--notra-selection);\n\t\t}\n\n\t\t.selection::selection {\n\t\t\tbackground: transparent;\n\t\t}\n\t}\n\n\t.selection {\n\t\tdisplay: inline;\n\t\tbackground-color: var(--notra-selection);\n\t}\n\n\t.ProseMirror-selectednode:not(img, pre, .react-renderer) {\n\t\tborder-radius: 0.375rem;\n\t\tbackground-color: var(--notra-selection);\n\t}\n\n\t.ProseMirror-hideselection {\n\t\tcaret-color: transparent;\n\t}\n}\n"
    },
    {
      "path": "styles/blockquote.css",
      "content": ".notra-editor {\n\tblockquote {\n\t\tposition: relative;\n\t\tpadding-left: 1em;\n\t\tpadding-top: 0.375em;\n\t\tpadding-bottom: 0.375em;\n\t\tmargin: 1.5rem 0;\n\n\t\tp {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t/* Decorative left bar via pseudo-element */\n\t\t&::before {\n\t\t\tposition: absolute;\n\t\t\tbottom: 0;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\theight: 100%;\n\t\t\twidth: 0.25em;\n\t\t\tbackground-color: var(--notra-blockquote-bar);\n\t\t\tcontent: '';\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/code-block.css",
      "content": "/*\n * Atom One Dark by Daniel Gamage\n * Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax\n *\n * base:    #282c34\n * mono-1:  #abb2bf\n * mono-2:  #818896\n * mono-3:  #5c6370\n * hue-1:   #56b6c2\n * hue-2:   #61aeee\n * hue-3:   #c678dd\n * hue-4:   #98c379\n * hue-5:   #e06c75\n * hue-5-2: #be5046\n * hue-6:   #d19a66\n * hue-6-2: #e6c07b\n */\n\n/* Atom One Dark syntax highlighting theme */\n.hljs {\n\tcolor: #abb2bf;\n}\n\n.hljs-comment,\n.hljs-quote {\n\tcolor: #5c6370;\n\tfont-style: italic;\n}\n\n.hljs-doctag,\n.hljs-keyword,\n.hljs-formula {\n\tcolor: #c678dd;\n}\n\n.hljs-section,\n.hljs-name,\n.hljs-selector-tag,\n.hljs-deletion,\n.hljs-subst {\n\tcolor: #e06c75;\n}\n\n.hljs-literal {\n\tcolor: #56b6c2;\n}\n\n.hljs-string,\n.hljs-regexp,\n.hljs-addition,\n.hljs-attribute,\n.hljs-meta .hljs-string {\n\tcolor: #98c379;\n}\n\n.hljs-attr,\n.hljs-variable,\n.hljs-template-variable,\n.hljs-type,\n.hljs-selector-class,\n.hljs-selector-attr,\n.hljs-selector-pseudo,\n.hljs-number {\n\tcolor: #d19a66;\n}\n\n.hljs-symbol,\n.hljs-bullet,\n.hljs-link,\n.hljs-meta,\n.hljs-selector-id,\n.hljs-title {\n\tcolor: #61aeee;\n}\n\n.hljs-built_in,\n.hljs-title.class_,\n.hljs-class .hljs-title {\n\tcolor: #e6c07b;\n}\n\n.hljs-emphasis {\n\tfont-style: italic;\n}\n\n.hljs-strong {\n\tfont-weight: bold;\n}\n\n.hljs-link {\n\ttext-decoration: underline;\n}\n"
    },
    {
      "path": "styles/code.css",
      "content": ".notra-editor {\n\tcode {\n\t\tbackground-color: var(--notra-code-bg);\n\t\tcolor: var(--notra-code-text);\n\t\tborder: 1px solid var(--notra-code-border);\n\t\tfont-family:\n\t\t\tui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;\n\t\tfont-size: 0.875em;\n\t\tline-height: 1.4;\n\t\tborder-radius: 0.375rem;\n\t\tpadding: 0.1em 0.2em;\n\t}\n\n\tpre {\n\t\tbackground-color: var(--notra-codeblock-bg);\n\t\tcolor: var(--notra-codeblock-text);\n\t\tborder: 1px solid var(--notra-codeblock-border);\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 1.5em;\n\t\tpadding: 1em;\n\t\tfont-size: 1rem;\n\t\tborder-radius: 0.375rem;\n\t\toverflow-x: auto;\n\n\t\tcode {\n\t\t\tbackground-color: transparent;\n\t\t\tborder: none;\n\t\t\tborder-radius: 0;\n\t\t\tcolor: inherit;\n\t\t\tpadding: 0;\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/drag-handle.css",
      "content": ".drag-handle {\n\ttransition-property: top;\n\ttransition-duration: 200ms;\n\ttransition-timing-function: ease-out;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: absolute;\n\t\tleft: 100%;\n\t\ttop: 0;\n\t\twidth: 16px;\n\t\theight: 100%;\n\t\tpointer-events: auto;\n\t}\n}\n\n.prosemirror-dropcursor-block,\n.prosemirror-dropcursor-inline {\n\tbackground: var(--notra-brand-400) !important;\n\tborder-radius: 0.25rem;\n\tmargin-left: -1px;\n\tmargin-right: -1px;\n\twidth: 100%;\n\theight: 0.188rem;\n\tcursor: grabbing;\n}\n\n.notra-drag-handle {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\twidth: 1.25rem;\n\theight: 1.5rem;\n\tborder-radius: 0.25rem;\n\tborder: none;\n\tbackground: transparent;\n\tcolor: var(--notra-gray-a-400);\n\tcursor: grab;\n\tpadding: 0;\n\ttransition:\n\t\tbackground-color 150ms,\n\t\tcolor 150ms;\n}\n\n.notra-drag-handle:hover {\n\tbackground-color: var(--notra-gray-a-100);\n\tcolor: var(--notra-gray-a-600);\n}\n\n.notra-drag-handle:active {\n\tcursor: grabbing;\n}\n"
    },
    {
      "path": "styles/editor.css",
      "content": "@import './variables.css';\n@import './base.css';\n@import './heading.css';\n@import './text.css';\n@import './list.css';\n@import './code.css';\n@import './code-block.css';\n@import './blockquote.css';\n@import './horizontal-rule.css';\n@import './image.css';\n@import './drag-handle.css';\n@import './placeholder.css';\n"
    },
    {
      "path": "styles/heading.css",
      "content": "/* Vertical rhythm values from Tailwind Typography */\n.notra-editor {\n\th1,\n\th2,\n\th3,\n\th4 {\n\t\tposition: relative;\n\t\tcolor: inherit;\n\t\tfont-style: inherit;\n\n\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n\t}\n\n\th1 {\n\t\tmargin-top: 0;\n\t\tmargin-bottom: 0.888889em;\n\t\tfont-size: 2.25em;\n\t\tfont-weight: 700;\n\t\tline-height: 1.11111;\n\t}\n\n\th2 {\n\t\tmargin-top: 2em;\n\t\tmargin-bottom: 1em;\n\t\tfont-size: 1.5em;\n\t\tfont-weight: 700;\n\t\tline-height: 1.33333;\n\t}\n\n\th3 {\n\t\tmargin-top: 1.6em;\n\t\tmargin-bottom: 0.6em;\n\t\tfont-size: 1.25em;\n\t\tfont-weight: 600;\n\t\tline-height: 1.6;\n\t}\n\n\th4 {\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 0.5em;\n\t\tfont-weight: 600;\n\t\tline-height: 1.5;\n\t}\n}\n"
    },
    {
      "path": "styles/horizontal-rule.css",
      "content": ".notra-editor {\n\thr {\n\t\tborder: none;\n\t\theight: 1px;\n\t\tbackground-color: var(--notra-hr);\n\t\tmargin-top: 2.25em;\n\t\tmargin-bottom: 2.25em;\n\t}\n}\n"
    },
    {
      "path": "styles/image.css",
      "content": ".notra-editor {\n\timg {\n\t\tmax-width: 100%;\n\t\theight: auto;\n\t\tdisplay: block;\n\t\tmargin: 2rem 0;\n\t\tborder-radius: 0.25rem;\n\t}\n}\n"
    },
    {
      "path": "styles/list.css",
      "content": ".notra-editor {\n\t--notra-checklist-bg: var(--notra-gray-a-100);\n\t--notra-checklist-bg-active: var(--notra-gray-a-900);\n\t--notra-checklist-border: var(--notra-gray-a-200);\n\t--notra-checklist-border-active: var(--notra-gray-a-900);\n\t--notra-checklist-check-icon: white;\n\t--notra-checklist-text-active: var(--notra-gray-a-500);\n}\n\n.dark .notra-editor,\n.notra-editor.dark {\n\t--notra-checklist-check-icon: black;\n}\n\n@media (prefers-color-scheme: dark) {\n\t.notra-editor:not(.light) {\n\t\t--notra-checklist-check-icon: black;\n\t}\n}\n\n.notra-editor {\n\tol,\n\tul {\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 1.5em;\n\t\tpadding-left: 1.5em;\n\n\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t&:last-child {\n\t\t\tmargin-bottom: 0;\n\t\t}\n\n\t\tol,\n\t\tul {\n\t\t\tmargin-top: 0;\n\t\t\tmargin-bottom: 0;\n\t\t}\n\t}\n\n\tli {\n\t\tp {\n\t\t\tmargin-top: 0;\n\t\t\tline-height: 1.6;\n\t\t}\n\t}\n\n\tol {\n\t\tlist-style: decimal;\n\n\t\tol {\n\t\t\tlist-style: lower-alpha;\n\n\t\t\tol {\n\t\t\t\tlist-style: lower-roman;\n\t\t\t}\n\t\t}\n\t}\n\n\tul:not([data-type='taskList']) {\n\t\tlist-style: disc;\n\n\t\tul {\n\t\t\tlist-style: circle;\n\n\t\t\tul {\n\t\t\t\tlist-style: square;\n\t\t\t}\n\t\t}\n\t}\n\n\tul[data-type='taskList'] {\n\t\tpadding-left: 0.25em;\n\n\t\tli {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\talign-items: flex-start;\n\n\t\t\t&:not(:has(> p:first-child)) {\n\t\t\t\tlist-style-type: none;\n\t\t\t}\n\n\t\t\t&[data-checked='true'] {\n\t\t\t\t> div > p {\n\t\t\t\t\topacity: 0.5;\n\t\t\t\t\ttext-decoration: line-through;\n\t\t\t\t}\n\n\t\t\t\t> div > p span {\n\t\t\t\t\ttext-decoration: line-through;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlabel {\n\t\t\t\tposition: relative;\n\t\t\t\tpadding-top: 0.375rem;\n\t\t\t\tpadding-right: 0.5rem;\n\n\t\t\t\tinput[type='checkbox'] {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\topacity: 0;\n\t\t\t\t\twidth: 0;\n\t\t\t\t\theight: 0;\n\t\t\t\t}\n\n\t\t\t\tspan {\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\twidth: 1em;\n\t\t\t\t\theight: 1em;\n\t\t\t\t\tborder: 1px solid var(--notra-checklist-border);\n\t\t\t\t\tborder-radius: 0.25rem;\n\t\t\t\t\tposition: relative;\n\t\t\t\t\tcursor: pointer;\n\t\t\t\t\tbackground-color: var(--notra-checklist-bg);\n\t\t\t\t\ttransition:\n\t\t\t\t\t\tbackground-color 80ms ease-out,\n\t\t\t\t\t\tborder-color 80ms ease-out;\n\n\t\t\t\t\t&::before {\n\t\t\t\t\t\tcontent: '';\n\t\t\t\t\t\tposition: absolute;\n\t\t\t\t\t\tleft: 50%;\n\t\t\t\t\t\ttop: 50%;\n\t\t\t\t\t\ttransform: translate(-50%, -50%);\n\t\t\t\t\t\twidth: 0.75em;\n\t\t\t\t\t\theight: 0.75em;\n\t\t\t\t\t\tbackground-color: var(--notra-checklist-check-icon);\n\t\t\t\t\t\topacity: 0;\n\t\t\t\t\t\tmask: url('data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22currentColor%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M21.4142%204.58579C22.1953%205.36683%2022.1953%206.63317%2021.4142%207.41421L10.4142%2018.4142C9.63317%2019.1953%208.36684%2019.1953%207.58579%2018.4142L2.58579%2013.4142C1.80474%2012.6332%201.80474%2011.3668%202.58579%2010.5858C3.36683%209.80474%204.63317%209.80474%205.41421%2010.5858L9%2014.1716L18.5858%204.58579C19.3668%203.80474%2020.6332%203.80474%2021.4142%204.58579Z%22%20fill%3D%22currentColor%22%2F%3E%3C%2Fsvg%3E')\n\t\t\t\t\t\t\tcenter / contain no-repeat;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinput[type='checkbox']:checked + span {\n\t\t\t\t\tbackground: var(--notra-checklist-bg-active);\n\t\t\t\t\tborder-color: var(--notra-checklist-border-active);\n\n\t\t\t\t\t&::before {\n\t\t\t\t\t\topacity: 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdiv {\n\t\t\t\tflex: 1 1 0%;\n\t\t\t\tmin-width: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/placeholder.css",
      "content": ".notra-editor .tiptap p.is-empty::before {\n\tcolor: var(--notra-gray-a-400);\n\tcontent: attr(data-placeholder);\n\tfloat: left;\n\theight: 0;\n\tpointer-events: none;\n}\n"
    },
    {
      "path": "styles/text.css",
      "content": ".notra-editor {\n\tp:not(:first-child) {\n\t\tfont-size: 1rem;\n\t\tline-height: 1.6;\n\t\tfont-weight: normal;\n\t\tmargin-top: 1.25em;\n\t}\n\n\tstrong {\n\t\tfont-weight: 700;\n\t}\n\n\tem {\n\t\tfont-style: italic;\n\t}\n\n\ta {\n\t\tcolor: var(--notra-link);\n\t\ttext-decoration: underline;\n\t}\n\n\ta span {\n\t\ttext-decoration: underline;\n\t}\n\n\ts span {\n\t\ttext-decoration: line-through;\n\t}\n\n\tu span {\n\t\ttext-decoration: underline;\n\t}\n}\n"
    },
    {
      "path": "styles/variables.css",
      "content": "/* Palette - override these to change the theme */\n.notra-editor {\n\t/* Gray alpha scale */\n\t--notra-gray-a-50: rgb(56 56 56 / 4%);\n\t--notra-gray-a-100: rgb(15 22 36 / 5%);\n\t--notra-gray-a-200: rgb(37 39 45 / 10%);\n\t--notra-gray-a-300: rgb(47 50 55 / 20%);\n\t--notra-gray-a-400: rgb(40 44 51 / 42%);\n\t--notra-gray-a-500: rgb(52 55 60 / 64%);\n\t--notra-gray-a-600: rgb(36 39 46 / 78%);\n\t--notra-gray-a-700: rgb(35 37 42 / 87%);\n\t--notra-gray-a-800: rgb(30 32 36 / 95%);\n\t--notra-gray-a-900: rgb(29 30 32 / 98%);\n\n\t/* Brand */\n\t--notra-brand-50: rgb(239 238 255);\n\t--notra-brand-100: rgb(222 219 255);\n\t--notra-brand-200: rgb(195 189 255);\n\t--notra-brand-300: rgb(157 138 255);\n\t--notra-brand-400: rgb(122 82 255);\n\t--notra-brand-500: rgb(98 41 255);\n\t--notra-brand-600: rgb(84 0 229);\n\t--notra-brand-700: rgb(75 0 204);\n\t--notra-brand-800: rgb(56 0 153);\n\t--notra-brand-900: rgb(43 25 102);\n\t--notra-brand-950: hsl(257deg 100% 9%);\n\n\t/* Selection */\n\t--notra-selection: rgb(157 138 255 / 20%);\n\n\t/* Semantic tokens */\n\t--notra-text: var(--notra-gray-a-900);\n\t--notra-link: var(--notra-brand-500);\n\t--notra-code-bg: var(--notra-gray-a-100);\n\t--notra-code-text: var(--notra-gray-a-700);\n\t--notra-code-border: var(--notra-gray-a-200);\n\t--notra-codeblock-bg: var(--notra-gray-a-50);\n\t--notra-codeblock-text: var(--notra-gray-a-800);\n\t--notra-codeblock-border: var(--notra-gray-a-200);\n\t--notra-blockquote-bar: var(--notra-gray-a-900);\n\t--notra-hr: var(--notra-gray-a-200);\n}\n\n/* Dark mode via .dark ancestor or class on editor itself */\n.dark .notra-editor,\n.notra-editor.dark {\n\t--notra-gray-a-50: rgb(232 232 253 / 5%);\n\t--notra-gray-a-100: rgb(231 231 243 / 7%);\n\t--notra-gray-a-200: rgb(238 238 246 / 11%);\n\t--notra-gray-a-300: rgb(239 239 245 / 22%);\n\t--notra-gray-a-400: rgb(244 244 255 / 37%);\n\t--notra-gray-a-500: rgb(236 238 253 / 50%);\n\t--notra-gray-a-600: rgb(247 247 253 / 64%);\n\t--notra-gray-a-700: rgb(251 251 254 / 75%);\n\t--notra-gray-a-800: rgb(253 253 253 / 88%);\n\t--notra-gray-a-900: rgb(255 255 255 / 96%);\n\t--notra-selection: rgb(122 82 255 / 20%);\n\t--notra-link: var(--notra-brand-400);\n}\n\n/* Dark mode via system preference (opt-out with .light class) */\n@media (prefers-color-scheme: dark) {\n\t.notra-editor:not(.light) {\n\t\t--notra-gray-a-50: rgb(232 232 253 / 5%);\n\t\t--notra-gray-a-100: rgb(231 231 243 / 7%);\n\t\t--notra-gray-a-200: rgb(238 238 246 / 11%);\n\t\t--notra-gray-a-300: rgb(239 239 245 / 22%);\n\t\t--notra-gray-a-400: rgb(244 244 255 / 37%);\n\t\t--notra-gray-a-500: rgb(236 238 253 / 50%);\n\t\t--notra-gray-a-600: rgb(247 247 253 / 64%);\n\t\t--notra-gray-a-700: rgb(251 251 254 / 75%);\n\t\t--notra-gray-a-800: rgb(253 253 253 / 88%);\n\t\t--notra-gray-a-900: rgb(255 255 255 / 96%);\n\t\t--notra-selection: rgb(122 82 255 / 20%);\n\t\t--notra-link: var(--notra-brand-400);\n\t}\n}\n"
    },
    {
      "path": "ui/blockquote-button.tsx",
      "content": "import { useCallback } from 'react';\n\nimport { useBlockquote } from '../hooks/use-blockquote';\nimport { Button } from './primitives/button';\n\nimport type { MouseEvent } from 'react';\n\nexport function BlockquoteButton() {\n\tconst { isVisible, isActive, canToggle, handleToggle, label, Icon } =\n\t\tuseBlockquote();\n\n\tconst handleClick = useCallback(\n\t\t(event: MouseEvent<HTMLButtonElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canToggle}\n\t\t\tisActive={isActive}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleClick}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/code-block-button.tsx",
      "content": "import { useCallback } from 'react';\n\nimport { useCodeBlock } from '../hooks/use-code-block';\nimport { Button } from './primitives/button';\n\nimport type { MouseEvent } from 'react';\n\nexport function CodeBlockButton() {\n\tconst { isVisible, isActive, canToggle, handleToggle, label, Icon } =\n\t\tuseCodeBlock();\n\n\tconst handleClick = useCallback(\n\t\t(event: MouseEvent<HTMLButtonElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canToggle}\n\t\t\tisActive={isActive}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleClick}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/code-block-copy-button.tsx",
      "content": "import { Check, Copy } from 'lucide-react';\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { Button } from './primitives/button';\n\ninterface CopyButtonProps {\n\tvalue: string;\n}\n\nexport function CopyButton({ value }: Readonly<CopyButtonProps>) {\n\tconst [isCopied, setIsCopied] = useState(false);\n\tconst timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n\tuseEffect(() => {\n\t\treturn () => {\n\t\t\tif (timeoutRef.current) {\n\t\t\t\tclearTimeout(timeoutRef.current);\n\t\t\t}\n\t\t};\n\t}, []);\n\n\tconst handleCopy = useCallback(() => {\n\t\tif (!value) return;\n\n\t\tnavigator.clipboard.writeText(value).then(\n\t\t\t() => {\n\t\t\t\tsetIsCopied(true);\n\n\t\t\t\tif (timeoutRef.current) {\n\t\t\t\t\tclearTimeout(timeoutRef.current);\n\t\t\t\t}\n\n\t\t\t\ttimeoutRef.current = setTimeout(() => {\n\t\t\t\t\tsetIsCopied(false);\n\t\t\t\t\ttimeoutRef.current = null;\n\t\t\t\t}, 2000);\n\t\t\t},\n\t\t\t() => {\n\t\t\t\t// Clipboard API error  silently ignore\n\t\t\t}\n\t\t);\n\t}, [value]);\n\n\treturn (\n\t\t<Button size=\"icon-xs\" variant=\"ghost\" onClick={handleCopy}>\n\t\t\t<span className=\"sr-only\">Copy</span>\n\t\t\t{isCopied ? <Check /> : <Copy />}\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/code-block-language-select.tsx",
      "content": "import { Check, ChevronDown } from 'lucide-react';\nimport { useState } from 'react';\n\nimport { cn } from '../lib/utils';\nimport { Button } from './primitives/button';\nimport {\n\tCommand,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList\n} from './primitives/command';\nimport { Popover, PopoverContent, PopoverTrigger } from './primitives/popover';\n\ninterface LanguageOption {\n\tlabel: string;\n\tvalue: string;\n}\n\nexport const LANGUAGES: LanguageOption[] = [\n\t{ label: 'Auto', value: 'auto' },\n\t{ label: 'Plain Text', value: 'plaintext' },\n\t{ label: 'ABAP', value: 'abap' },\n\t{ label: 'Agda', value: 'agda' },\n\t{ label: 'Arduino', value: 'arduino' },\n\t{ label: 'ASCII Art', value: 'ascii' },\n\t{ label: 'Assembly', value: 'x86asm' },\n\t{ label: 'Bash', value: 'bash' },\n\t{ label: 'BASIC', value: 'basic' },\n\t{ label: 'BNF', value: 'bnf' },\n\t{ label: 'C', value: 'c' },\n\t{ label: 'C#', value: 'csharp' },\n\t{ label: 'C++', value: 'cpp' },\n\t{ label: 'Clojure', value: 'clojure' },\n\t{ label: 'CoffeeScript', value: 'coffeescript' },\n\t{ label: 'Coq', value: 'coq' },\n\t{ label: 'CSS', value: 'css' },\n\t{ label: 'Dart', value: 'dart' },\n\t{ label: 'Dhall', value: 'dhall' },\n\t{ label: 'Diff', value: 'diff' },\n\t{ label: 'Docker', value: 'dockerfile' },\n\t{ label: 'EBNF', value: 'ebnf' },\n\t{ label: 'Elixir', value: 'elixir' },\n\t{ label: 'Elm', value: 'elm' },\n\t{ label: 'Erlang', value: 'erlang' },\n\t{ label: 'F#', value: 'fsharp' },\n\t{ label: 'Flow', value: 'flow' },\n\t{ label: 'Fortran', value: 'fortran' },\n\t{ label: 'Gherkin', value: 'gherkin' },\n\t{ label: 'GLSL', value: 'glsl' },\n\t{ label: 'Go', value: 'go' },\n\t{ label: 'GraphQL', value: 'graphql' },\n\t{ label: 'Groovy', value: 'groovy' },\n\t{ label: 'Haskell', value: 'haskell' },\n\t{ label: 'HCL', value: 'hcl' },\n\t{ label: 'HTML', value: 'html' },\n\t{ label: 'Idris', value: 'idris' },\n\t{ label: 'Java', value: 'java' },\n\t{ label: 'JavaScript', value: 'javascript' },\n\t{ label: 'JSON', value: 'json' },\n\t{ label: 'Julia', value: 'julia' },\n\t{ label: 'Kotlin', value: 'kotlin' },\n\t{ label: 'LaTeX', value: 'latex' },\n\t{ label: 'Less', value: 'less' },\n\t{ label: 'Lisp', value: 'lisp' },\n\t{ label: 'LiveScript', value: 'livescript' },\n\t{ label: 'LLVM IR', value: 'llvm' },\n\t{ label: 'Lua', value: 'lua' },\n\t{ label: 'Makefile', value: 'makefile' },\n\t{ label: 'Markdown', value: 'markdown' },\n\t{ label: 'Markup', value: 'markup' },\n\t{ label: 'MATLAB', value: 'matlab' },\n\t{ label: 'Mathematica', value: 'mathematica' },\n\t{ label: 'Mermaid', value: 'mermaid' },\n\t{ label: 'Nix', value: 'nix' },\n\t{ label: 'Notion Formula', value: 'notion' },\n\t{ label: 'Objective-C', value: 'objectivec' },\n\t{ label: 'OCaml', value: 'ocaml' },\n\t{ label: 'Pascal', value: 'pascal' },\n\t{ label: 'Perl', value: 'perl' },\n\t{ label: 'PHP', value: 'php' },\n\t{ label: 'PowerShell', value: 'powershell' },\n\t{ label: 'Prolog', value: 'prolog' },\n\t{ label: 'Protocol Buffers', value: 'protobuf' },\n\t{ label: 'PureScript', value: 'purescript' },\n\t{ label: 'Python', value: 'python' },\n\t{ label: 'R', value: 'r' },\n\t{ label: 'Racket', value: 'racket' },\n\t{ label: 'Reason', value: 'reasonml' },\n\t{ label: 'Ruby', value: 'ruby' },\n\t{ label: 'Rust', value: 'rust' },\n\t{ label: 'Sass', value: 'sass' },\n\t{ label: 'Scala', value: 'scala' },\n\t{ label: 'Scheme', value: 'scheme' },\n\t{ label: 'SCSS', value: 'scss' },\n\t{ label: 'Shell', value: 'shell' },\n\t{ label: 'Smalltalk', value: 'smalltalk' },\n\t{ label: 'Solidity', value: 'solidity' },\n\t{ label: 'SQL', value: 'sql' },\n\t{ label: 'Swift', value: 'swift' },\n\t{ label: 'TOML', value: 'toml' },\n\t{ label: 'TypeScript', value: 'typescript' },\n\t{ label: 'VB.Net', value: 'vbnet' },\n\t{ label: 'Verilog', value: 'verilog' },\n\t{ label: 'VHDL', value: 'vhdl' },\n\t{ label: 'Visual Basic', value: 'vb' },\n\t{ label: 'WebAssembly', value: 'wasm' },\n\t{ label: 'XML', value: 'xml' },\n\t{ label: 'YAML', value: 'yaml' },\n\t{ label: 'Zig', value: 'zig' }\n];\n\n// Maps common abbreviations and file extensions to canonical language values\nconst LANGUAGE_ALIASES: Record<string, string> = {\n\tjs: 'javascript',\n\tjsx: 'javascript',\n\tts: 'typescript',\n\ttsx: 'typescript',\n\tpy: 'python',\n\trb: 'ruby',\n\trs: 'rust',\n\tsh: 'bash',\n\tzsh: 'bash',\n\tyml: 'yaml',\n\tmd: 'markdown',\n\tcs: 'csharp',\n\tfs: 'fsharp',\n\tkt: 'kotlin',\n\tex: 'elixir',\n\texs: 'elixir',\n\terl: 'erlang',\n\ths: 'haskell',\n\tml: 'ocaml',\n\tpl: 'perl',\n\tps1: 'powershell',\n\tproto: 'protobuf',\n\ttf: 'hcl',\n\tasm: 'x86asm',\n\ttex: 'latex',\n\ttext: 'plaintext',\n\ttxt: 'plaintext',\n\tplain: 'plaintext',\n\tobjc: 'objectivec',\n\t'objective-c': 'objectivec',\n\t'c++': 'cpp',\n\t'f#': 'fsharp',\n\t'c#': 'csharp',\n\tgql: 'graphql',\n\tsol: 'solidity',\n\twat: 'wasm',\n\tdocker: 'dockerfile'\n};\n\nconst LANGUAGE_VALUE_SET = new Set(LANGUAGES.map((l) => l.value));\n\nexport function resolveLanguageAlias(input: string): string {\n\tif (!input) return 'auto';\n\n\tconst lower = input.toLowerCase();\n\n\tif (LANGUAGE_VALUE_SET.has(lower)) return lower;\n\n\treturn LANGUAGE_ALIASES[lower] ?? lower;\n}\n\nexport function filterLanguages(\n\tlanguages: LanguageOption[],\n\tsearch: string\n): LanguageOption[] {\n\tif (!search) return languages;\n\n\tconst lowerSearch = search.toLowerCase();\n\n\treturn languages.filter((lang) =>\n\t\tlang.label.toLowerCase().includes(lowerSearch)\n\t);\n}\n\ninterface LanguageSelectProps {\n\tlanguage: string;\n\tonLanguageChange: (language: string) => void;\n}\n\nexport function LanguageSelect({\n\tlanguage,\n\tonLanguageChange\n}: LanguageSelectProps) {\n\tconst [open, setOpen] = useState(false);\n\n\tconst currentLabel =\n\t\tLANGUAGES.find((lang) => lang.value === language)?.label ??\n\t\tLANGUAGES[0].label;\n\n\treturn (\n\t\t<Popover open={open} onOpenChange={setOpen}>\n\t\t\t<PopoverTrigger asChild onClick={(e) => e.stopPropagation()}>\n\t\t\t\t<Button\n\t\t\t\t\taria-expanded={open}\n\t\t\t\t\tclassName=\"justify-between\"\n\t\t\t\t\trole=\"combobox\"\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t>\n\t\t\t\t\t{currentLabel}\n\t\t\t\t\t<ChevronDown className=\"opacity-50\" />\n\t\t\t\t</Button>\n\t\t\t</PopoverTrigger>\n\t\t\t<PopoverContent align=\"start\" className=\"w-[200px] p-0\">\n\t\t\t\t<Command>\n\t\t\t\t\t<CommandInput placeholder=\"Search language...\" />\n\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t<CommandEmpty>No language found.</CommandEmpty>\n\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t{LANGUAGES.map((lang) => (\n\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\tkey={lang.value}\n\t\t\t\t\t\t\t\t\tvalue={lang.label}\n\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\tonLanguageChange(lang.value);\n\t\t\t\t\t\t\t\t\t\tsetOpen(false);\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{lang.label}\n\t\t\t\t\t\t\t\t\t<Check\n\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t'ml-auto',\n\t\t\t\t\t\t\t\t\t\t\tlanguage === lang.value ? 'opacity-100' : 'opacity-0'\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t</CommandList>\n\t\t\t\t</Command>\n\t\t\t</PopoverContent>\n\t\t</Popover>\n\t);\n}\n"
    },
    {
      "path": "ui/cursor-overlay.tsx",
      "content": "import { useEffect, useState } from 'react';\n\nimport type { Editor } from '@tiptap/core';\nimport type { CSSProperties } from 'react';\n\nexport interface CursorOverlayProps {\n\teditor: Editor;\n}\n\n/**\n * Renders a static caret at the current cursor position.\n * Used when the editor loses focus but we want to keep\n * showing where the cursor was (e.g. when a popover is open).\n */\nexport function CursorOverlay({ editor }: CursorOverlayProps) {\n\tconst [style, setStyle] = useState<CSSProperties | null>(null);\n\n\tuseEffect(() => {\n\t\t// Skip when editor is focused  the native caret is already visible\n\t\tif (editor.view.hasFocus()) {\n\t\t\tsetStyle(null);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst pos = editor.state.selection.from;\n\t\tconst coords = editor.view.coordsAtPos(pos);\n\t\tconst editorEl = editor.view.dom;\n\t\tconst caretColor = getComputedStyle(editorEl).caretColor || 'currentColor';\n\n\t\tsetStyle({\n\t\t\tleft: coords.left,\n\t\t\ttop: coords.top,\n\t\t\theight: coords.bottom - coords.top,\n\t\t\tbackgroundColor: caretColor\n\t\t});\n\t}, [editor]);\n\n\tif (!style) return null;\n\n\treturn (\n\t\t<div\n\t\t\taria-hidden\n\t\t\tclassName=\"pointer-events-none fixed z-50 w-px\"\n\t\t\tstyle={style}\n\t\t/>\n\t);\n}\n"
    },
    {
      "path": "ui/drag-handle.tsx",
      "content": "import { offset } from '@floating-ui/react';\nimport { DragHandle } from '@tiptap/extension-drag-handle-react';\nimport { useCurrentEditor } from '@tiptap/react';\nimport { GripVertical } from 'lucide-react';\nimport { useCallback } from 'react';\n\nimport { useTranslation } from '../i18n';\n\nconst POSITION_CONFIG = {\n\tmiddleware: [offset({ mainAxis: 16 })]\n};\n\nexport function BlockDragHandle() {\n\tconst { editor } = useCurrentEditor();\n\tconst dictionary = useTranslation();\n\n\tconst onDragStart = useCallback(() => {\n\t\tif (!editor) return;\n\n\t\teditor.commands.setIsDragging(true);\n\t}, [editor]);\n\n\tconst onDragEnd = useCallback(() => {\n\t\tif (!editor) return;\n\n\t\teditor.commands.setIsDragging(false);\n\t}, [editor]);\n\n\tif (!editor) return null;\n\n\treturn (\n\t\t<DragHandle\n\t\t\tcomputePositionConfig={POSITION_CONFIG}\n\t\t\teditor={editor}\n\t\t\tonElementDragEnd={onDragEnd}\n\t\t\tonElementDragStart={onDragStart}\n\t\t>\n\t\t\t<button\n\t\t\t\taria-label={dictionary['dragHandle.ariaLabel']}\n\t\t\t\tclassName=\"notra-drag-handle\"\n\t\t\t\tdraggable={true}\n\t\t\t\ttype=\"button\"\n\t\t\t>\n\t\t\t\t<GripVertical size={16} />\n\t\t\t</button>\n\t\t</DragHandle>\n\t);\n}\n"
    },
    {
      "path": "ui/fixed-toolbar.tsx",
      "content": "import { BlockquoteButton } from './blockquote-button';\nimport { CodeBlockButton } from './code-block-button';\nimport { HeadingDropdownMenu } from './heading-dropdown-menu';\nimport { LinkPopover } from './link-popover';\nimport { ListDropdownMenu } from './list-dropdown-menu';\nimport { MarkButton } from './mark-button';\nimport { Separator } from './primitives/separator';\nimport { Spacer } from './primitives/spacer';\nimport { TextAlignButton } from './text-align-button';\nimport { UndoRedoButton } from './undo-redo-button';\nimport { cn } from '../lib/utils';\n\nimport type { ReactNode } from 'react';\n\nfunction ToolbarGroup({ children }: { children: ReactNode }) {\n\treturn <div className=\"flex items-center gap-0.5\">{children}</div>;\n}\n\nfunction ToolbarSeparator() {\n\treturn <Separator className=\"!h-6\" orientation=\"vertical\" />;\n}\n\nexport interface FixedToolbarProps {\n\tclassName?: string;\n}\n\nexport function FixedToolbar({ className }: FixedToolbarProps) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t'h-11 flex items-center gap-1 overflow-x-auto px-2 border-b',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t>\n\t\t\t<Spacer />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<UndoRedoButton action=\"undo\" />\n\t\t\t\t<UndoRedoButton action=\"redo\" />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<HeadingDropdownMenu />\n\t\t\t\t<ListDropdownMenu />\n\t\t\t\t<BlockquoteButton />\n\t\t\t\t<CodeBlockButton />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<MarkButton type=\"bold\" />\n\t\t\t\t<MarkButton type=\"italic\" />\n\t\t\t\t<MarkButton type=\"underline\" />\n\t\t\t\t<MarkButton type=\"strike\" />\n\t\t\t\t<MarkButton type=\"code\" />\n\t\t\t\t<LinkPopover />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<MarkButton type=\"superscript\" />\n\t\t\t\t<MarkButton type=\"subscript\" />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<TextAlignButton alignment=\"left\" />\n\t\t\t\t<TextAlignButton alignment=\"center\" />\n\t\t\t\t<TextAlignButton alignment=\"right\" />\n\t\t\t\t<TextAlignButton alignment=\"justify\" />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<Spacer />\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "ui/heading-button.tsx",
      "content": "import { useCallback } from 'react';\n\nimport { DropdownMenuItem } from './primitives/dropdown-menu';\nimport { useHeading } from '../hooks/use-heading';\n\nimport type { Level } from '../hooks/use-heading';\nimport type { MouseEvent } from 'react';\n\nexport interface HeadingButtonProps {\n\tlevel: Level;\n}\n\nexport function HeadingButton({ level }: HeadingButtonProps) {\n\tconst { isVisible, handleToggle, Icon, label } = useHeading({ level });\n\n\tconst handleClick = useCallback(\n\t\t(event: MouseEvent<HTMLDivElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenuItem onClick={handleClick}>\n\t\t\t<Icon className=\"text-popover-foreground\" />\n\t\t\t{label}\n\t\t</DropdownMenuItem>\n\t);\n}\n"
    },
    {
      "path": "ui/heading-dropdown-menu.tsx",
      "content": "import { ChevronDown } from 'lucide-react';\n\nimport { HeadingButton } from './heading-button';\nimport { useHeadingDropdownMenu } from '../hooks/use-heading-dropdown-menu';\nimport { useTranslation } from '../i18n';\nimport { Button } from './primitives/button';\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuTrigger\n} from './primitives/dropdown-menu';\n\nexport function HeadingDropdownMenu() {\n\tconst dictionary = useTranslation();\n\tconst { isVisible, isActive, canToggle, Icon, levels } =\n\t\tuseHeadingDropdownMenu({\n\t\t\tlevels: [1, 2, 3, 4, 5, 6]\n\t\t});\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\taria-label={dictionary['heading.dropdown.ariaLabel']}\n\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\tdata-active-state={isActive ? 'on' : 'off'}\n\t\t\t\t\tdata-disabled={!canToggle}\n\t\t\t\t\tdata-style=\"ghost\"\n\t\t\t\t\tdisabled={!canToggle}\n\t\t\t\t\tisActive={isActive}\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t>\n\t\t\t\t\t<Icon />\n\t\t\t\t\t<ChevronDown className=\"size-2.5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\n\t\t\t<DropdownMenuContent\n\t\t\t\talign=\"start\"\n\t\t\t\tonCloseAutoFocus={(e) => e.preventDefault()}\n\t\t\t>\n\t\t\t\t{levels.map((level) => (\n\t\t\t\t\t<HeadingButton key={`heading-${level}`} level={level} />\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n"
    },
    {
      "path": "ui/link-popover.tsx",
      "content": "import {\n\tCheck,\n\tCopy,\n\tCornerDownLeft,\n\tLink,\n\tPencil,\n\tUnlink\n} from 'lucide-react';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\n\nimport { CursorOverlay } from './cursor-overlay';\nimport { useLinkPopover } from '../hooks/use-link-popover';\nimport { cn } from '../lib/utils';\nimport { Button } from './primitives/button';\n\nimport type { UseLinkPopoverConfig } from '../hooks/use-link-popover';\nimport type { FocusEvent as ReactFocusEvent, KeyboardEvent } from 'react';\n\nfunction LinkPreview({\n\turl,\n\tonEdit,\n\tonUnlink\n}: {\n\turl: string;\n\tonEdit: () => void;\n\tonUnlink: () => void;\n}) {\n\tconst [copied, setCopied] = useState(false);\n\n\tconst handleCopy = useCallback(() => {\n\t\tnavigator.clipboard.writeText(url).then(() => {\n\t\t\tsetCopied(true);\n\t\t\tsetTimeout(() => setCopied(false), 1500);\n\t\t});\n\t}, [url]);\n\n\treturn (\n\t\t<div className=\"flex items-center gap-2\">\n\t\t\t<a\n\t\t\t\tclassName=\"text-sm text-muted-foreground underline truncate max-w-48\"\n\t\t\t\thref={url}\n\t\t\t\trel=\"noopener noreferrer\"\n\t\t\t\ttarget=\"_blank\"\n\t\t\t>\n\t\t\t\t{url}\n\t\t\t</a>\n\t\t\t<div className=\"flex items-center gap-0.5\">\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Edit link\"\n\t\t\t\t\tsize=\"icon-xs\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tonClick={onEdit}\n\t\t\t\t>\n\t\t\t\t\t<Pencil size={14} />\n\t\t\t\t</Button>\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Copy link\"\n\t\t\t\t\tsize=\"icon-xs\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tonClick={handleCopy}\n\t\t\t\t>\n\t\t\t\t\t{copied ? <Check size={14} /> : <Copy size={14} />}\n\t\t\t\t</Button>\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Unlink\"\n\t\t\t\t\tsize=\"icon-xs\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tonClick={onUnlink}\n\t\t\t\t>\n\t\t\t\t\t<Unlink size={14} />\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nfunction LinkEditForm({\n\turl,\n\ttext,\n\turlError,\n\tonUrlChange,\n\tonTextChange,\n\tonSubmit,\n\tonClose\n}: {\n\turl: string;\n\ttext: string;\n\turlError: string | null;\n\tonUrlChange: (url: string) => void;\n\tonTextChange: (text: string) => void;\n\tonSubmit: () => void;\n\tonClose: () => void;\n}) {\n\tconst urlInputRef = useRef<HTMLInputElement>(null);\n\n\tuseEffect(() => {\n\t\turlInputRef.current?.focus();\n\t}, []);\n\n\tconst handleKeyDown = useCallback(\n\t\t(event: KeyboardEvent) => {\n\t\t\tif (event.key === 'Enter') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tonSubmit();\n\t\t\t}\n\n\t\t\tif (event.key === 'Escape') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tonClose();\n\t\t\t}\n\t\t},\n\t\t[onSubmit, onClose]\n\t);\n\n\treturn (\n\t\t<div className=\"flex flex-col gap-2\" onKeyDown={handleKeyDown}>\n\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t<input\n\t\t\t\t\tref={urlInputRef}\n\t\t\t\t\taria-invalid={!!urlError}\n\t\t\t\t\taria-label=\"URL\"\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t'flex-1 rounded-md border bg-transparent px-2 py-1 text-sm outline-none',\n\t\t\t\t\t\t'focus:ring-2 focus:ring-ring/50',\n\t\t\t\t\t\turlError && 'border-destructive'\n\t\t\t\t\t)}\n\t\t\t\t\tplaceholder=\"https://example.com\"\n\t\t\t\t\ttype=\"url\"\n\t\t\t\t\tvalue={url}\n\t\t\t\t\tonChange={(e) => onUrlChange(e.target.value)}\n\t\t\t\t/>\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Confirm\"\n\t\t\t\t\tsize=\"icon-xs\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tonClick={onSubmit}\n\t\t\t\t>\n\t\t\t\t\t<CornerDownLeft size={14} />\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t\t{urlError && (\n\t\t\t\t<p className=\"text-xs text-destructive\" role=\"alert\">\n\t\t\t\t\t{urlError}\n\t\t\t\t</p>\n\t\t\t)}\n\t\t\t<input\n\t\t\t\taria-label=\"Display text\"\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'rounded-md border bg-transparent px-2 py-1 text-sm outline-none',\n\t\t\t\t\t'focus:ring-2 focus:ring-ring/50'\n\t\t\t\t)}\n\t\t\t\tplaceholder=\"Display text\"\n\t\t\t\tvalue={text}\n\t\t\t\tonChange={(e) => onTextChange(e.target.value)}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\nexport type LinkPopoverProps = UseLinkPopoverConfig;\n\nexport function LinkPopover(props: LinkPopoverProps) {\n\tconst {\n\t\teditor,\n\t\tisVisible,\n\t\tcanSetLink,\n\t\tisActive,\n\t\tpopoverMode,\n\t\tsetPopoverMode,\n\t\turl,\n\t\tsetUrl,\n\t\ttext,\n\t\tsetText,\n\t\turlError,\n\t\tsubmitLink,\n\t\tremoveLink,\n\t\tanchorCoords\n\t} = useLinkPopover(props);\n\n\tconst panelRef = useRef<HTMLDivElement>(null);\n\n\tconst isOpen = popoverMode !== 'closed';\n\n\tconst handlePanelFocusOut = useCallback(\n\t\t(e: ReactFocusEvent) => {\n\t\t\tif (popoverMode !== 'edit') return;\n\n\t\t\t// Stay open when focus moves within the panel (e.g. URL  text input)\n\t\t\tif (panelRef.current?.contains(e.relatedTarget as Node)) return;\n\n\t\t\tsetPopoverMode('closed');\n\t\t},\n\t\t[popoverMode, setPopoverMode]\n\t);\n\n\tuseEffect(() => {\n\t\tif (!isOpen) return;\n\n\t\tconst handleKeyDown = (e: globalThis.KeyboardEvent) => {\n\t\t\tif (e.key === 'Escape') {\n\t\t\t\tsetPopoverMode('closed');\n\t\t\t}\n\t\t};\n\n\t\tdocument.addEventListener('keydown', handleKeyDown);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('keydown', handleKeyDown);\n\t\t};\n\t}, [isOpen, setPopoverMode]);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\tconst handleTriggerClick = () => {\n\t\t// Toolbar button has no effect when popover is already open\n\t\tif (isOpen) return;\n\n\t\tif (isActive) {\n\t\t\tsetPopoverMode('preview');\n\t\t} else {\n\t\t\tsetPopoverMode('edit');\n\t\t}\n\t};\n\n\treturn (\n\t\t<>\n\t\t\t<Button\n\t\t\t\taria-label=\"Link\"\n\t\t\t\tdisabled={!canSetLink}\n\t\t\t\tisActive={isActive}\n\t\t\t\tsize=\"icon-xs\"\n\t\t\t\ttabIndex={-1}\n\t\t\t\tvariant=\"ghost\"\n\t\t\t\tonClick={handleTriggerClick}\n\t\t\t\tonMouseDown={(e) => e.preventDefault()}\n\t\t\t>\n\t\t\t\t<Link size={16} />\n\t\t\t</Button>\n\n\t\t\t{isOpen && editor && <CursorOverlay editor={editor} />}\n\n\t\t\t{isOpen &&\n\t\t\t\tanchorCoords &&\n\t\t\t\tcreatePortal(\n\t\t\t\t\t<div\n\t\t\t\t\t\tref={panelRef}\n\t\t\t\t\t\tclassName=\"bg-popover text-popover-foreground z-50 w-auto rounded-md border p-3 shadow-md\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tposition: 'fixed',\n\t\t\t\t\t\t\tleft: anchorCoords.left,\n\t\t\t\t\t\t\ttop: anchorCoords.top + 4\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tonBlur={handlePanelFocusOut}\n\t\t\t\t\t>\n\t\t\t\t\t\t{popoverMode === 'preview' && (\n\t\t\t\t\t\t\t<LinkPreview\n\t\t\t\t\t\t\t\turl={url}\n\t\t\t\t\t\t\t\tonEdit={() => setPopoverMode('edit')}\n\t\t\t\t\t\t\t\tonUnlink={removeLink}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{popoverMode === 'edit' && (\n\t\t\t\t\t\t\t<LinkEditForm\n\t\t\t\t\t\t\t\ttext={text}\n\t\t\t\t\t\t\t\turl={url}\n\t\t\t\t\t\t\t\turlError={urlError}\n\t\t\t\t\t\t\t\tonClose={() => setPopoverMode('closed')}\n\t\t\t\t\t\t\t\tonSubmit={submitLink}\n\t\t\t\t\t\t\t\tonTextChange={setText}\n\t\t\t\t\t\t\t\tonUrlChange={setUrl}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>,\n\t\t\t\t\tdocument.body\n\t\t\t\t)}\n\t\t</>\n\t);\n}\n"
    },
    {
      "path": "ui/list-button.tsx",
      "content": "import { useCallback } from 'react';\n\nimport { DropdownMenuItem } from './primitives/dropdown-menu';\nimport { useList } from '../hooks/use-list';\n\nimport type { ListType } from '../hooks/use-list';\nimport type { MouseEvent } from 'react';\n\nexport interface ListButtonProps {\n\ttype: ListType;\n}\n\nexport function ListButton({ type }: ListButtonProps) {\n\tconst { isVisible, handleToggle, Icon, label } = useList({ type });\n\n\tconst handleClick = useCallback(\n\t\t(event: MouseEvent<HTMLDivElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenuItem onClick={handleClick}>\n\t\t\t<Icon className=\"text-popover-foreground\" />\n\t\t\t{label}\n\t\t</DropdownMenuItem>\n\t);\n}\n"
    },
    {
      "path": "ui/list-dropdown-menu.tsx",
      "content": "import { ChevronDown } from 'lucide-react';\n\nimport { ListButton } from './list-button';\nimport { useListDropdownMenu } from '../hooks/use-list-dropdown-menu';\nimport { useTranslation } from '../i18n';\nimport { Button } from './primitives/button';\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuTrigger\n} from './primitives/dropdown-menu';\n\nexport function ListDropdownMenu() {\n\tconst dictionary = useTranslation();\n\tconst { isVisible, isActive, canToggle, Icon, filteredLists } =\n\t\tuseListDropdownMenu();\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\taria-label={dictionary['list.dropdown.ariaLabel']}\n\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\tdata-active-state={isActive ? 'on' : 'off'}\n\t\t\t\t\tdata-disabled={!canToggle}\n\t\t\t\t\tdata-style=\"ghost\"\n\t\t\t\t\tdisabled={!canToggle}\n\t\t\t\t\tisActive={isActive}\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t>\n\t\t\t\t\t<Icon />\n\t\t\t\t\t<ChevronDown className=\"size-2.5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\n\t\t\t<DropdownMenuContent\n\t\t\t\talign=\"start\"\n\t\t\t\tonCloseAutoFocus={(e) => e.preventDefault()}\n\t\t\t>\n\t\t\t\t{filteredLists.map((list) => (\n\t\t\t\t\t<ListButton key={list.type} type={list.type} />\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n"
    },
    {
      "path": "ui/mark-button.tsx",
      "content": "import { useCallback } from 'react';\n\nimport { useMark } from '../hooks/use-mark';\nimport { Button } from './primitives/button';\n\nimport type { MarkType } from '../hooks/use-mark';\nimport type { MouseEvent } from 'react';\n\nexport interface MarkButtonProps {\n\ttype: MarkType;\n}\n\nexport function MarkButton({ type }: MarkButtonProps) {\n\tconst { isVisible, isActive, canToggle, handleMark, label, Icon } = useMark({\n\t\ttype\n\t});\n\n\tconst handleClick = useCallback(\n\t\t(event: MouseEvent<HTMLButtonElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleMark();\n\t\t},\n\t\t[handleMark]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canToggle}\n\t\t\tisActive={isActive}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleClick}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/primitives/button.tsx",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\nimport { Slot } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nconst buttonVariants = cva(\n\t\"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: 'bg-primary text-primary-foreground hover:bg-primary/90',\n\t\t\t\tdestructive:\n\t\t\t\t\t'bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n\t\t\t\toutline:\n\t\t\t\t\t'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',\n\t\t\t\tsecondary:\n\t\t\t\t\t'bg-secondary text-secondary-foreground hover:bg-secondary/80',\n\t\t\t\tghost:\n\t\t\t\t\t'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',\n\t\t\t\tlink: 'text-primary underline-offset-4 hover:underline'\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tdefault: 'h-9 px-4 py-2 has-[>svg]:px-3',\n\t\t\t\txs: 'h-7 gap-0 px-1.5',\n\t\t\t\tsm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',\n\t\t\t\tlg: 'h-10 rounded-md px-6 has-[>svg]:px-4',\n\t\t\t\ticon: 'size-9',\n\t\t\t\t'icon-xs': 'size-7',\n\t\t\t\t'icon-sm': 'size-8',\n\t\t\t\t'icon-lg': 'size-10'\n\t\t\t},\n\t\t\tisActive: {\n\t\t\t\ttrue: 'bg-accent text-accent-foreground dark:bg-accent/50'\n\t\t\t}\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: 'default',\n\t\t\tsize: 'default'\n\t\t}\n\t}\n);\n\nfunction Button({\n\tclassName,\n\tvariant = 'default',\n\tsize = 'default',\n\tasChild = false,\n\tisActive = false,\n\t...props\n}: Readonly<React.ComponentProps<'button'>> &\n\tVariantProps<typeof buttonVariants> & {\n\t\tasChild?: boolean;\n\t}) {\n\tconst Comp = asChild ? Slot.Root : 'button';\n\n\treturn (\n\t\t<Comp\n\t\t\tclassName={cn(buttonVariants({ variant, size, className, isActive }))}\n\t\t\tdata-size={size}\n\t\t\tdata-slot=\"button\"\n\t\t\tdata-variant={variant}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport { Button, buttonVariants };\n"
    },
    {
      "path": "ui/primitives/command.tsx",
      "content": "import { Command as CommandPrimitive } from 'cmdk';\nimport { SearchIcon } from 'lucide-react';\nimport * as React from 'react';\n\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogHeader,\n\tDialogTitle\n} from './dialog';\nimport { cn } from '../../lib/utils';\n\nfunction Command({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive>) {\n\treturn (\n\t\t<CommandPrimitive\n\t\t\tclassName={cn(\n\t\t\t\t'bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"command\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction CommandDialog({\n\ttitle = 'Command Palette',\n\tdescription = 'Search for a command to run...',\n\tchildren,\n\tclassName,\n\tshowCloseButton = true,\n\t...props\n}: React.ComponentProps<typeof Dialog> & {\n\ttitle?: string;\n\tdescription?: string;\n\tclassName?: string;\n\tshowCloseButton?: boolean;\n}) {\n\treturn (\n\t\t<Dialog {...props}>\n\t\t\t<DialogHeader className=\"sr-only\">\n\t\t\t\t<DialogTitle>{title}</DialogTitle>\n\t\t\t\t<DialogDescription>{description}</DialogDescription>\n\t\t\t</DialogHeader>\n\t\t\t<DialogContent\n\t\t\t\tclassName={cn('overflow-hidden p-0', className)}\n\t\t\t\tshowCloseButton={showCloseButton}\n\t\t\t>\n\t\t\t\t<Command className=\"[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n\t\t\t\t\t{children}\n\t\t\t\t</Command>\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t);\n}\n\nfunction CommandInput({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive.Input>) {\n\treturn (\n\t\t<div\n\t\t\tclassName=\"flex h-9 items-center gap-2 border-b px-3\"\n\t\t\tdata-slot=\"command-input-wrapper\"\n\t\t>\n\t\t\t<SearchIcon className=\"size-4 shrink-0 opacity-50\" />\n\t\t\t<CommandPrimitive.Input\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50',\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\tdata-slot=\"command-input\"\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\nfunction CommandList({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive.List>) {\n\treturn (\n\t\t<CommandPrimitive.List\n\t\t\tclassName={cn(\n\t\t\t\t'max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"command-list\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction CommandEmpty({\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive.Empty>) {\n\treturn (\n\t\t<CommandPrimitive.Empty\n\t\t\tclassName=\"py-6 text-center text-sm\"\n\t\t\tdata-slot=\"command-empty\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction CommandGroup({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive.Group>) {\n\treturn (\n\t\t<CommandPrimitive.Group\n\t\t\tclassName={cn(\n\t\t\t\t'text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"command-group\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction CommandSeparator({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive.Separator>) {\n\treturn (\n\t\t<CommandPrimitive.Separator\n\t\t\tclassName={cn('bg-border -mx-1 h-px', className)}\n\t\t\tdata-slot=\"command-separator\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction CommandItem({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof CommandPrimitive.Item>) {\n\treturn (\n\t\t<CommandPrimitive.Item\n\t\t\tclassName={cn(\n\t\t\t\t\"data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"command-item\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction CommandShortcut({\n\tclassName,\n\t...props\n}: React.ComponentProps<'span'>) {\n\treturn (\n\t\t<span\n\t\t\tclassName={cn(\n\t\t\t\t'text-muted-foreground ml-auto text-xs tracking-widest',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"command-shortcut\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport {\n\tCommand,\n\tCommandDialog,\n\tCommandInput,\n\tCommandList,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandItem,\n\tCommandShortcut,\n\tCommandSeparator\n};\n"
    },
    {
      "path": "ui/primitives/dialog.tsx",
      "content": "import { XIcon } from 'lucide-react';\nimport { Dialog as DialogPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { Button } from './button';\nimport { cn } from '../../lib/utils';\n\nfunction Dialog({\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Root>) {\n\treturn <DialogPrimitive.Root data-slot=\"dialog\" {...props} />;\n}\n\nfunction DialogTrigger({\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {\n\treturn <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />;\n}\n\nfunction DialogPortal({\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Portal>) {\n\treturn <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />;\n}\n\nfunction DialogClose({\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Close>) {\n\treturn <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />;\n}\n\nfunction DialogOverlay({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {\n\treturn (\n\t\t<DialogPrimitive.Overlay\n\t\t\tclassName={cn(\n\t\t\t\t'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"dialog-overlay\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction DialogContent({\n\tclassName,\n\tchildren,\n\tshowCloseButton = true,\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Content> & {\n\tshowCloseButton?: boolean;\n}) {\n\treturn (\n\t\t<DialogPortal data-slot=\"dialog-portal\">\n\t\t\t<DialogOverlay />\n\t\t\t<DialogPrimitive.Content\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg',\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\tdata-slot=\"dialog-content\"\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t\t{showCloseButton && (\n\t\t\t\t\t<DialogPrimitive.Close\n\t\t\t\t\t\tclassName=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\"\n\t\t\t\t\t\tdata-slot=\"dialog-close\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<XIcon />\n\t\t\t\t\t\t<span className=\"sr-only\">Close</span>\n\t\t\t\t\t</DialogPrimitive.Close>\n\t\t\t\t)}\n\t\t\t</DialogPrimitive.Content>\n\t\t</DialogPortal>\n\t);\n}\n\nfunction DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn('flex flex-col gap-2 text-center sm:text-left', className)}\n\t\t\tdata-slot=\"dialog-header\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction DialogFooter({\n\tclassName,\n\tshowCloseButton = false,\n\tchildren,\n\t...props\n}: React.ComponentProps<'div'> & {\n\tshowCloseButton?: boolean;\n}) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"dialog-footer\"\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t\t{showCloseButton && (\n\t\t\t\t<DialogPrimitive.Close asChild>\n\t\t\t\t\t<Button variant=\"outline\">Close</Button>\n\t\t\t\t</DialogPrimitive.Close>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n\nfunction DialogTitle({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Title>) {\n\treturn (\n\t\t<DialogPrimitive.Title\n\t\t\tclassName={cn('text-lg leading-none font-semibold', className)}\n\t\t\tdata-slot=\"dialog-title\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction DialogDescription({\n\tclassName,\n\t...props\n}: React.ComponentProps<typeof DialogPrimitive.Description>) {\n\treturn (\n\t\t<DialogPrimitive.Description\n\t\t\tclassName={cn('text-muted-foreground text-sm', className)}\n\t\t\tdata-slot=\"dialog-description\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport {\n\tDialog,\n\tDialogClose,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogOverlay,\n\tDialogPortal,\n\tDialogTitle,\n\tDialogTrigger\n};\n"
    },
    {
      "path": "ui/primitives/dropdown-menu.tsx",
      "content": "import { DropdownMenu as DropdownMenuPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction DropdownMenu({\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {\n\treturn <DropdownMenuPrimitive.Root data-slot=\"dropdown-menu\" {...props} />;\n}\n\nfunction DropdownMenuTrigger({\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Trigger\n\t\t\tdata-slot=\"dropdown-menu-trigger\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction DropdownMenuContent({\n\tclassName,\n\tsideOffset = 4,\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Portal>\n\t\t\t<DropdownMenuPrimitive.Content\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\tdata-slot=\"dropdown-menu-content\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</DropdownMenuPrimitive.Portal>\n\t);\n}\n\nfunction DropdownMenuItem({\n\tclassName,\n\tinset,\n\tvariant = 'default',\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {\n\tinset?: boolean;\n\tvariant?: 'default' | 'destructive';\n}) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Item\n\t\t\tclassName={cn(\n\t\t\t\t\"focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-inset={inset}\n\t\t\tdata-slot=\"dropdown-menu-item\"\n\t\t\tdata-variant={variant}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuItem\n};\n"
    },
    {
      "path": "ui/primitives/popover.tsx",
      "content": "import { Popover as PopoverPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction Popover({\n\t...props\n}: React.ComponentProps<typeof PopoverPrimitive.Root>) {\n\treturn <PopoverPrimitive.Root data-slot=\"popover\" {...props} />;\n}\n\nfunction PopoverTrigger({\n\t...props\n}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {\n\treturn <PopoverPrimitive.Trigger data-slot=\"popover-trigger\" {...props} />;\n}\n\nfunction PopoverContent({\n\tclassName,\n\talign = 'center',\n\tsideOffset = 4,\n\t...props\n}: React.ComponentProps<typeof PopoverPrimitive.Content>) {\n\treturn (\n\t\t<PopoverPrimitive.Portal>\n\t\t\t<PopoverPrimitive.Content\n\t\t\t\talign={align}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden',\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\tdata-slot=\"popover-content\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</PopoverPrimitive.Portal>\n\t);\n}\n\nfunction PopoverAnchor({\n\t...props\n}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {\n\treturn <PopoverPrimitive.Anchor data-slot=\"popover-anchor\" {...props} />;\n}\n\nfunction PopoverHeader({ className, ...props }: React.ComponentProps<'div'>) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn('flex flex-col gap-1 text-sm', className)}\n\t\t\tdata-slot=\"popover-header\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction PopoverTitle({ className, ...props }: React.ComponentProps<'h2'>) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn('font-medium', className)}\n\t\t\tdata-slot=\"popover-title\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction PopoverDescription({\n\tclassName,\n\t...props\n}: React.ComponentProps<'p'>) {\n\treturn (\n\t\t<p\n\t\t\tclassName={cn('text-muted-foreground', className)}\n\t\t\tdata-slot=\"popover-description\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport {\n\tPopover,\n\tPopoverTrigger,\n\tPopoverContent,\n\tPopoverAnchor,\n\tPopoverHeader,\n\tPopoverTitle,\n\tPopoverDescription\n};\n"
    },
    {
      "path": "ui/primitives/separator.tsx",
      "content": "import { Separator as SeparatorPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction Separator({\n\tclassName,\n\torientation = 'horizontal',\n\tdecorative = true,\n\t...props\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\n\treturn (\n\t\t<SeparatorPrimitive.Root\n\t\t\tclassName={cn(\n\t\t\t\t'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"separator\"\n\t\t\tdecorative={decorative}\n\t\t\torientation={orientation}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport { Separator };\n"
    },
    {
      "path": "ui/primitives/spacer.tsx",
      "content": "import * as React from 'react';\n\nexport type SpacerOrientation = 'horizontal' | 'vertical';\n\nexport interface SpacerProps extends React.HTMLAttributes<HTMLDivElement> {\n\torientation?: SpacerOrientation;\n\tsize?: string | number;\n}\n\nexport function Spacer({\n\torientation = 'horizontal',\n\tsize,\n\tstyle = {},\n\t...props\n}: SpacerProps) {\n\tconst computedStyle = {\n\t\t...style,\n\t\t...(orientation === 'horizontal' && !size && { flex: 1 }),\n\t\t...(size && {\n\t\t\twidth: orientation === 'vertical' ? '1px' : size,\n\t\t\theight: orientation === 'horizontal' ? '1px' : size\n\t\t})\n\t};\n\n\treturn <div {...props} style={computedStyle} />;\n}\n"
    },
    {
      "path": "ui/text-align-button.tsx",
      "content": "import { useCallback } from 'react';\n\nimport { useTextAlign } from '../hooks/use-text-align';\nimport { Button } from './primitives/button';\n\nimport type { AlignmentType } from '../hooks/use-text-align';\nimport type { MouseEvent } from 'react';\n\nexport interface TextAlignButtonProps {\n\talignment: AlignmentType;\n}\n\nexport function TextAlignButton({ alignment }: TextAlignButtonProps) {\n\tconst { isVisible, isActive, canAlign, handleAlign, label, Icon } =\n\t\tuseTextAlign({\n\t\t\talignment\n\t\t});\n\n\tconst handleClick = useCallback(\n\t\t(event: MouseEvent<HTMLButtonElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleAlign();\n\t\t},\n\t\t[handleAlign]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canAlign}\n\t\t\tisActive={isActive}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleClick}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/undo-redo-button.tsx",
      "content": "import { useUndoRedo } from '../hooks/use-undo-redo';\nimport { Button } from './primitives/button';\n\nimport type { UndoRedoAction } from '../hooks/use-undo-redo';\n\nexport interface UndoRedoButtonProps {\n\taction: UndoRedoAction;\n}\n\nexport function UndoRedoButton({ action }: UndoRedoButtonProps) {\n\tconst { isVisible, canExecute, handleAction, label, Icon } = useUndoRedo({\n\t\taction\n\t});\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canExecute}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleAction}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/__tests__/code-block-language-select.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { filterLanguages, LANGUAGES } from '../code-block-language-select';\n\n//  Unit tests: filterLanguages \n\ndescribe('filterLanguages unit tests', () => {\n\ttest('returns full list when search is empty string', () => {\n\t\texpect(filterLanguages(LANGUAGES, '')).toEqual(LANGUAGES);\n\t});\n\n\ttest('returns full list when search is undefined-like falsy', () => {\n\t\texpect(filterLanguages(LANGUAGES, '')).toHaveLength(LANGUAGES.length);\n\t});\n\n\ttest('filters by exact label match', () => {\n\t\tconst result = filterLanguages(LANGUAGES, 'TypeScript');\n\n\t\texpect(result).toEqual([{ label: 'TypeScript', value: 'typescript' }]);\n\t});\n\n\ttest('filters case-insensitively', () => {\n\t\tconst result = filterLanguages(LANGUAGES, 'typescript');\n\n\t\texpect(result).toEqual([{ label: 'TypeScript', value: 'typescript' }]);\n\t});\n\n\ttest('filters by substring match', () => {\n\t\tconst result = filterLanguages(LANGUAGES, 'Script');\n\t\tconst labels = result.map((l) => l.label);\n\n\t\texpect(labels).toContain('JavaScript');\n\t\texpect(labels).toContain('TypeScript');\n\t\texpect(labels).toContain('CoffeeScript');\n\t\texpect(labels).toContain('LiveScript');\n\t\texpect(labels).toContain('PureScript');\n\t});\n\n\ttest('returns empty array when no match', () => {\n\t\tconst result = filterLanguages(LANGUAGES, 'zzzznotexist');\n\n\t\texpect(result).toEqual([]);\n\t});\n\n\ttest('includes Auto and Plain Text when search matches', () => {\n\t\tconst autoResult = filterLanguages(LANGUAGES, 'Auto');\n\n\t\texpect(autoResult.some((l) => l.value === 'auto')).toBe(true);\n\n\t\tconst plainResult = filterLanguages(LANGUAGES, 'Plain');\n\n\t\texpect(plainResult.some((l) => l.value === 'plaintext')).toBe(true);\n\t});\n});\n\n//  Property 1: Language filter correctness \n\ndescribe('Feature: code-block, Property 1: Language filter correctness', () => {\n\t/**\n\t * **Validates: Requirements 3.2**\n\t *\n\t * For any search string, filtering the language list returns only\n\t * languages whose label contains the search string (case-insensitive).\n\t */\n\ttest('every result label contains the search string (case-insensitive)', () => {\n\t\tfc.assert(\n\t\t\tfc.property(fc.string(), (search) => {\n\t\t\t\tconst result = filterLanguages(LANGUAGES, search);\n\t\t\t\tconst lowerSearch = search.toLowerCase();\n\n\t\t\t\tfor (const lang of result) {\n\t\t\t\t\texpect(lang.label.toLowerCase()).toContain(lowerSearch);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('no excluded language has a label containing the search string', () => {\n\t\tfc.assert(\n\t\t\tfc.property(fc.string(), (search) => {\n\t\t\t\tconst result = filterLanguages(LANGUAGES, search);\n\t\t\t\tconst resultValues = new Set(result.map((l) => l.value));\n\t\t\t\tconst lowerSearch = search.toLowerCase();\n\n\t\t\t\tfor (const lang of LANGUAGES) {\n\t\t\t\t\tif (!resultValues.has(lang.value)) {\n\t\t\t\t\t\texpect(lang.label.toLowerCase()).not.toContain(lowerSearch);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('empty search returns the full list', () => {\n\t\tfc.assert(\n\t\t\tfc.property(fc.constant(''), (search) => {\n\t\t\t\tconst result = filterLanguages(LANGUAGES, search);\n\n\t\t\t\texpect(result).toEqual(LANGUAGES);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "ui/__tests__/drag-handle.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test, vi } from 'vitest';\n\nconst { GripVerticalMock } = vi.hoisted(() => ({\n\tGripVerticalMock: vi.fn((props: Record<string, unknown>) => props)\n}));\n\nvi.mock('@tiptap/extension-drag-handle-react', () => ({\n\tDragHandle: ({ children }: { children: unknown }) => children\n}));\n\nvi.mock('lucide-react', () => ({\n\tGripVertical: GripVerticalMock\n}));\n\nvi.mock('@floating-ui/react', () => ({\n\toffset: vi.fn()\n}));\n\nlet mockEditor: unknown = {};\nlet mockDictionary: Record<string, string> = {\n\t'dragHandle.ariaLabel': 'Drag to reorder'\n};\n\nvi.mock('react', async () => {\n\tconst actual = await vi.importActual<typeof import('react')>('react');\n\n\treturn {\n\t\t...actual,\n\t\tuseCallback: (fn: unknown) => fn\n\t};\n});\n\nvi.mock('@tiptap/react', () => ({\n\tuseCurrentEditor: () => ({ editor: mockEditor })\n}));\n\nvi.mock('../../i18n', () => ({\n\tuseTranslation: () => mockDictionary\n}));\n\nimport { BlockDragHandle } from '../drag-handle';\n\ninterface MockReactElement {\n\ttype: unknown;\n\tprops: Record<string, unknown>;\n}\n\nconst ariaLabelArbitrary = fc.string({ minLength: 1, maxLength: 200 });\n\n// JSX creates React elements without executing them, so <DragHandle> produces\n// { type: mockFn, props: { children: <button>... } }. We need to unwrap.\nfunction renderDragHandle(): MockReactElement {\n\tconst wrapper = (BlockDragHandle as () => unknown)() as MockReactElement;\n\n\treturn wrapper.props['children'] as MockReactElement;\n}\n\ndescribe('Feature: block-drag-handle, Property 1: BlockDragHandle render correctness', () => {\n\ttest('Property 1: rendered element has correct button structure, aria-label, draggable, and SVG child', () => {\n\t\tfc.assert(\n\t\t\tfc.property(ariaLabelArbitrary, (ariaLabel) => {\n\t\t\t\tmockEditor = {};\n\t\t\t\tmockDictionary = { 'dragHandle.ariaLabel': ariaLabel };\n\n\t\t\t\tconst button = renderDragHandle();\n\n\t\t\t\texpect(button).not.toBeNull();\n\t\t\t\texpect(button.type).toBe('button');\n\t\t\t\texpect(button.props['className']).toBe('notra-drag-handle');\n\t\t\t\texpect(button.props['aria-label']).toBe(ariaLabel);\n\t\t\t\texpect(button.props['draggable']).toBe(true);\n\n\t\t\t\tconst svgChild = button.props['children'] as MockReactElement;\n\n\t\t\t\texpect(svgChild).toBeDefined();\n\t\t\t\texpect(svgChild.type).toBe(GripVerticalMock);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\ndescribe('Feature: block-drag-handle, Property 2: BlockDragHandle null editor safety', () => {\n\ttest('Property 2: returns null when editor is null regardless of dictionary', () => {\n\t\tfc.assert(\n\t\t\tfc.property(ariaLabelArbitrary, (ariaLabel) => {\n\t\t\t\tmockEditor = null;\n\t\t\t\tmockDictionary = { 'dragHandle.ariaLabel': ariaLabel };\n\n\t\t\t\tconst result = (BlockDragHandle as () => unknown)();\n\n\t\t\t\texpect(result).toBeNull();\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\ndescribe('BlockDragHandle unit tests', () => {\n\ttest('default aria-label is \"Drag to reorder\"', () => {\n\t\tmockEditor = {};\n\t\tmockDictionary = { 'dragHandle.ariaLabel': 'Drag to reorder' };\n\n\t\tconst button = renderDragHandle();\n\n\t\texpect(button.props['aria-label']).toBe('Drag to reorder');\n\t});\n\n\ttest('render output contains GripVertical SVG element', () => {\n\t\tmockEditor = {};\n\t\tmockDictionary = { 'dragHandle.ariaLabel': 'Drag to reorder' };\n\n\t\tconst button = renderDragHandle();\n\t\tconst svgChild = button.props['children'] as MockReactElement;\n\n\t\texpect(svgChild).toBeDefined();\n\t\texpect(svgChild.type).toBe(GripVerticalMock);\n\t});\n\n\ttest('en dictionary contains dragHandle.ariaLabel key', async () => {\n\t\tconst { en } = await import('../../i18n/messages/en');\n\n\t\texpect(en['dragHandle.ariaLabel']).toBe('Drag to reorder');\n\t});\n});\n"
    },
    {
      "path": "ui/__tests__/spacer.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport type { SpacerOrientation } from '../primitives/spacer';\nimport type { CSSProperties } from 'react';\n\n// Replicate the pure style computation from Spacer component\nfunction computeSpacerStyle(\n\torientation: SpacerOrientation = 'horizontal',\n\tsize: string | number | undefined,\n\tstyle: CSSProperties = {}\n): CSSProperties {\n\treturn {\n\t\t...style,\n\t\t...(orientation === 'horizontal' && !size && { flex: 1 }),\n\t\t...(size && {\n\t\t\twidth: orientation === 'vertical' ? '1px' : size,\n\t\t\theight: orientation === 'horizontal' ? '1px' : size\n\t\t})\n\t};\n}\n\n//  Generators \n\nconst orientationArbitrary: fc.Arbitrary<SpacerOrientation> = fc.constantFrom(\n\t'horizontal' as const,\n\t'vertical' as const\n);\n\nconst sizeArbitrary: fc.Arbitrary<string | number | undefined> = fc.oneof(\n\tfc.constant(undefined),\n\tfc.integer({ min: 1, max: 1000 }),\n\tfc.constantFrom('10px', '2rem', '50%', '1.5em', '100vh')\n);\n\n//  Property 1: Spacer  \n\ndescribe('Feature: toolbar-components, Property 1: Spacer ', () => {\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('horizontal + no size  style contains flex: 1', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constant('horizontal' as SpacerOrientation),\n\t\t\t\tfc.constant(undefined),\n\t\t\t\t(orientation, size) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\t\texpect(result).toHaveProperty('flex', 1);\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('when size is provided, horizontal sets width=size and height=1px; vertical sets width=1px and height=size', () => {\n\t\tconst definedSizeArbitrary: fc.Arbitrary<string | number> = fc.oneof(\n\t\t\tfc.integer({ min: 1, max: 1000 }),\n\t\t\tfc.constantFrom('10px', '2rem', '50%', '1.5em', '100vh')\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\torientationArbitrary,\n\t\t\t\tdefinedSizeArbitrary,\n\t\t\t\t(orientation, size) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\n\t\t\t\t\tif (orientation === 'horizontal') {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', size);\n\t\t\t\t\t\texpect(result).toHaveProperty('height', '1px');\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', '1px');\n\t\t\t\t\t\texpect(result).toHaveProperty('height', size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('for any orientation and size combination, computed style satisfies all Spacer invariants', () => {\n\t\tfc.assert(\n\t\t\tfc.property(orientationArbitrary, sizeArbitrary, (orientation, size) => {\n\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\tif (orientation === 'horizontal' && !size) {\n\t\t\t\t\t// Req 1.2: flex: 1 when horizontal and no size\n\t\t\t\t\texpect(result).toHaveProperty('flex', 1);\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t} else if (size) {\n\t\t\t\t\t// Req 1.3: size applied as width/height based on orientation\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\n\t\t\t\t\tif (orientation === 'horizontal') {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', size);\n\t\t\t\t\t\texpect(result).toHaveProperty('height', '1px');\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', '1px');\n\t\t\t\t\t\texpect(result).toHaveProperty('height', size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// vertical + no size: no special styles\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('user-provided style properties are preserved in computed style', () => {\n\t\tconst userStyleArbitrary = fc.record({\n\t\t\tcolor: fc.constantFrom('red', 'blue', 'green'),\n\t\t\tmargin: fc.constantFrom('4px', '8px', '16px')\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\torientationArbitrary,\n\t\t\t\tsizeArbitrary,\n\t\t\t\tuserStyleArbitrary,\n\t\t\t\t(orientation, size, userStyle) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size, userStyle);\n\n\t\t\t\t\t// User-provided styles should always be present\n\t\t\t\t\texpect(result).toHaveProperty('color', userStyle.color);\n\t\t\t\t\texpect(result).toHaveProperty('margin', userStyle.margin);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "ui/__tests__/undo-redo-button.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test, vi } from 'vitest';\n\nimport {\n\tcanExecuteAction,\n\texecuteAction,\n\tshouldShowUndoRedoButton\n} from '../../hooks/use-undo-redo';\n\nconst emptySelection = { empty: true };\n\ninterface MockEditor {\n\tisEditable: boolean;\n\tcan: () => { undo: () => boolean; redo: () => boolean };\n\tstate: { selection: { empty: boolean } };\n}\n\ntype EditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; canUndo: boolean; canRedo: boolean };\n\nconst editorStateArbitrary: fc.Arbitrary<EditorState> = fc.oneof(\n\tfc.constant<EditorState>({ type: 'null' }),\n\tfc.constant<EditorState>({ type: 'not-editable' }),\n\tfc.record<EditorState & { type: 'editable' }>({\n\t\ttype: fc.constant('editable' as const),\n\t\tcanUndo: fc.boolean(),\n\t\tcanRedo: fc.boolean()\n\t})\n);\n\nconst actionArbitrary: fc.Arbitrary<'undo' | 'redo'> = fc.constantFrom(\n\t'undo' as const,\n\t'redo' as const\n);\n\nfunction buildMockEditor(state: EditorState): MockEditor | null {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tcan: () => ({ undo: () => false, redo: () => false }),\n\t\t\tstate: { selection: emptySelection }\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tcan: () => ({\n\t\t\tundo: () => state.canUndo,\n\t\t\tredo: () => state.canRedo\n\t\t}),\n\t\tstate: { selection: emptySelection }\n\t};\n}\n\nfunction expectedResult(state: EditorState, action: 'undo' | 'redo'): boolean {\n\tif (state.type === 'null' || state.type === 'not-editable') return false;\n\n\treturn action === 'undo' ? state.canUndo : state.canRedo;\n}\n\ndescribe('canExecuteAction', () => {\n\ttest('returns correct result based on editor state and action', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst editor = buildMockEditor(state);\n\t\t\t\tconst result = canExecuteAction(editor as never, action);\n\n\t\t\t\texpect(result).toBe(expectedResult(state, action));\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\ninterface MockEditorWithChain extends MockEditor {\n\tchain: () => {\n\t\tfocus: () => {\n\t\t\tundo: () => { run: () => boolean };\n\t\t\tredo: () => { run: () => boolean };\n\t\t};\n\t};\n}\n\nfunction buildMockEditorWithChain(state: EditorState): {\n\teditor: MockEditorWithChain | null;\n\tspies: { undo: ReturnType<typeof vi.fn>; redo: ReturnType<typeof vi.fn> };\n} {\n\tconst undoRunSpy = vi.fn(() => true);\n\tconst redoRunSpy = vi.fn(() => true);\n\tconst spies = { undo: undoRunSpy, redo: redoRunSpy };\n\n\tif (state.type === 'null') return { editor: null, spies };\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\teditor: {\n\t\t\t\tisEditable: false,\n\t\t\t\tcan: () => ({ undo: () => false, redo: () => false }),\n\t\t\t\tstate: { selection: emptySelection },\n\t\t\t\tchain: () => ({\n\t\t\t\t\tfocus: () => ({\n\t\t\t\t\t\tundo: () => ({ run: undoRunSpy }),\n\t\t\t\t\t\tredo: () => ({ run: redoRunSpy })\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\tspies\n\t\t};\n\t}\n\n\treturn {\n\t\teditor: {\n\t\t\tisEditable: true,\n\t\t\tcan: () => ({\n\t\t\t\tundo: () => state.canUndo,\n\t\t\t\tredo: () => state.canRedo\n\t\t\t}),\n\t\t\tstate: { selection: emptySelection },\n\t\t\tchain: () => ({\n\t\t\t\tfocus: () => ({\n\t\t\t\t\tundo: () => ({ run: undoRunSpy }),\n\t\t\t\t\tredo: () => ({ run: redoRunSpy })\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\t\tspies\n\t};\n}\n\ndescribe('executeAction', () => {\n\ttest('when canExecuteAction is false, returns false and calls no commands', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst { editor, spies } = buildMockEditorWithChain(state);\n\t\t\t\tconst canExecute = canExecuteAction(editor as never, action);\n\n\t\t\t\tif (!canExecute) {\n\t\t\t\t\tconst result = executeAction(editor as never, action);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\texpect(spies.undo).not.toHaveBeenCalled();\n\t\t\t\t\texpect(spies.redo).not.toHaveBeenCalled();\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\ttest('when canExecuteAction is true, calls the corresponding command', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst { editor, spies } = buildMockEditorWithChain(state);\n\t\t\t\tconst canExecute = canExecuteAction(editor as never, action);\n\n\t\t\t\tif (canExecute) {\n\t\t\t\t\tconst result = executeAction(editor as never, action);\n\n\t\t\t\t\texpect(result).toBe(true);\n\n\t\t\t\t\tif (action === 'undo') {\n\t\t\t\t\t\texpect(spies.undo).toHaveBeenCalledOnce();\n\t\t\t\t\t\texpect(spies.redo).not.toHaveBeenCalled();\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(spies.redo).toHaveBeenCalledOnce();\n\t\t\t\t\t\texpect(spies.undo).not.toHaveBeenCalled();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\ndescribe('shouldShowUndoRedoButton', () => {\n\ttest('returns false for null editor', () => {\n\t\texpect(\n\t\t\tshouldShowUndoRedoButton({\n\t\t\t\teditor: null as never,\n\t\t\t\taction: 'undo',\n\t\t\t\thideWhenUnavailable: false\n\t\t\t})\n\t\t).toBe(false);\n\t});\n\n\ttest('returns false for non-editable editor', () => {\n\t\tconst editor = buildMockEditor({ type: 'not-editable' });\n\n\t\texpect(\n\t\t\tshouldShowUndoRedoButton({\n\t\t\t\teditor: editor as never,\n\t\t\t\taction: 'undo',\n\t\t\t\thideWhenUnavailable: false\n\t\t\t})\n\t\t).toBe(false);\n\t});\n\n\ttest('returns true for editable editor when hideWhenUnavailable is false', () => {\n\t\tconst editor = buildMockEditor({\n\t\t\ttype: 'editable',\n\t\t\tcanUndo: false,\n\t\t\tcanRedo: false\n\t\t});\n\n\t\texpect(\n\t\t\tshouldShowUndoRedoButton({\n\t\t\t\teditor: editor as never,\n\t\t\t\taction: 'undo',\n\t\t\t\thideWhenUnavailable: false\n\t\t\t})\n\t\t).toBe(true);\n\t});\n\n\ttest('when hideWhenUnavailable is true, returns based on canExecuteAction', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst editor = buildMockEditor(state);\n\t\t\t\tconst result = shouldShowUndoRedoButton({\n\t\t\t\t\teditor: editor as never,\n\t\t\t\t\taction,\n\t\t\t\t\thideWhenUnavailable: true\n\t\t\t\t});\n\n\t\t\t\tif (state.type === 'null' || state.type === 'not-editable') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else {\n\t\t\t\t\texpect(result).toBe(expectedResult(state, action));\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "vitest.config.ts",
      "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n\ttest: {\n\t\tinclude: [\n\t\t\t'ui/__tests__/**/*.test.ts',\n\t\t\t'lib/__tests__/**/*.test.ts',\n\t\t\t'hooks/__tests__/**/*.test.ts',\n\t\t\t'i18n/__tests__/**/*.test.ts'\n\t\t],\n\t\ttestTimeout: 30000\n\t}\n});\n"
    }
  ],
  "dependencies": [
    {
      "name": "@floating-ui/react",
      "version": "0.27.17"
    },
    {
      "name": "@tiptap/core",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-code-block-lowlight",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-drag-handle",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-drag-handle-react",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-highlight",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-horizontal-rule",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-link",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-subscript",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-superscript",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-task-item",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-task-list",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-text-align",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-typography",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-underline",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extensions",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/pm",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/react",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/starter-kit",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/static-renderer",
      "version": "3.19.0"
    },
    {
      "name": "class-variance-authority",
      "version": "0.7.1"
    },
    {
      "name": "clsx",
      "version": "2.1.1"
    },
    {
      "name": "cmdk",
      "version": "1.1.1"
    },
    {
      "name": "lowlight",
      "version": "3.3.0"
    },
    {
      "name": "lucide-react",
      "version": "0.511.0"
    },
    {
      "name": "radix-ui",
      "version": "1.4.2"
    },
    {
      "name": "tailwind-merge",
      "version": "3.3.0"
    }
  ]
}