{
  "name": "editor",
  "version": "0.0.0",
  "description": "Minimal Tiptap React editor component",
  "files": [
    {
      "path": "core/editor.tsx",
      "content": "import '../styles/editor.css';\n\nimport { EditorContent, EditorContext, useEditor } from '@tiptap/react';\n\nimport { EditorExtensions } from '../extensions/editor';\nimport { FixedToolbar } from '../ui/fixed-toolbar';\n\nexport interface EditorProps {\n\tcontent?: string;\n\tonChange?: (content: string) => void;\n}\n\nexport function Editor({ content = '', onChange }: EditorProps) {\n\tconst editor = useEditor({\n\t\tcontent,\n\t\teditorProps: {\n\t\t\tattributes: {\n\t\t\t\tautocomplete: 'off',\n\t\t\t\tautocorrect: 'off',\n\t\t\t\tautocapitalize: 'off',\n\t\t\t\t'aria-label': 'Main content area, start typing to enter text.',\n\t\t\t\tclass:\n\t\t\t\t\t'notra-editor flex-1 px-4 sm:px-[max(64px,calc(50%-375px))] pb-[30vh] pt-15 sm:pt-23 outline-none'\n\t\t\t}\n\t\t},\n\t\textensions: EditorExtensions,\n\t\tonUpdate: ({ editor }) => onChange?.(editor.getHTML())\n\t});\n\n\treturn (\n\t\t<EditorContext.Provider value={{ editor }}>\n\t\t\t<FixedToolbar />\n\t\t\t<EditorContent editor={editor} />\n\t\t</EditorContext.Provider>\n\t);\n}\n"
    },
    {
      "path": "core/viewer.tsx",
      "content": "import '../styles/editor.css';\n\nimport { JSONContent } from '@tiptap/core';\nimport { renderToReactElement } from '@tiptap/static-renderer/pm/react';\nimport { JSX } from 'react';\n\nimport { ViewerExtensions } from '../extensions/viewer';\n\nexport interface ViewerProps {\n\tcontent: JSONContent;\n}\n\nexport function Viewer({ content }: ViewerProps): JSX.Element {\n\treturn (\n\t\t<div className=\"notra-editor\">\n\t\t\t{renderToReactElement({ extensions: ViewerExtensions, content })}\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "extensions/editor.ts",
      "content": "import { HorizontalRule } from './horizontal-rule';\nimport { Starter } from './starter';\n\nexport const EditorExtensions = [Starter, HorizontalRule];\n"
    },
    {
      "path": "extensions/horizontal-rule.ts",
      "content": "import TiptapHorizontalRule from '@tiptap/extension-horizontal-rule';\nimport { mergeAttributes } from '@tiptap/react';\n\n// Wrapper div enables better cursor positioning around the rule\nexport const HorizontalRule = TiptapHorizontalRule.extend({\n\trenderHTML() {\n\t\treturn [\n\t\t\t'div',\n\t\t\tmergeAttributes(this.options.HTMLAttributes, { 'data-type': this.name }),\n\t\t\t['hr']\n\t\t];\n\t}\n});\n"
    },
    {
      "path": "extensions/starter.ts",
      "content": "import { StarterKit } from '@tiptap/starter-kit';\n\nexport const Starter = StarterKit.configure({\n\thorizontalRule: false,\n\tcodeBlock: false\n});\n"
    },
    {
      "path": "extensions/viewer.ts",
      "content": "import { HorizontalRule } from './horizontal-rule';\nimport { Starter } from './starter';\n\nexport const ViewerExtensions = [Starter, HorizontalRule];\n"
    },
    {
      "path": "hooks/use-heading-dropdown-menu.ts",
      "content": "import { Heading } from 'lucide-react';\nimport * as React from 'react';\n\nimport {\n\theadingIcons,\n\ttype Level,\n\tisHeadingActive,\n\tcanToggle,\n\tshouldShowButton\n} from './use-heading';\nimport { useNotraEditor } from './use-notra-editor';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport interface UseHeadingDropdownMenuConfig {\n\teditor?: Editor | null;\n\tlevels?: Level[];\n\thideWhenUnavailable?: boolean;\n}\n\nexport function getActiveHeadingLevel(\n\teditor: Editor | null,\n\tlevels: Level[] = [1, 2, 3, 4, 5, 6]\n): Level | undefined {\n\tif (!editor || !editor.isEditable) return undefined;\n\n\treturn levels.find((level) => isHeadingActive(editor, level));\n}\n\nexport function useHeadingDropdownMenu(config?: UseHeadingDropdownMenuConfig): {\n\tisVisible: boolean;\n\tactiveLevel: Level | undefined;\n\tisActive: boolean;\n\tcanToggle: boolean;\n\tlevels: Level[];\n\tIcon: LucideIcon;\n} {\n\tconst {\n\t\teditor: providedEditor,\n\t\tlevels = [1, 2, 3, 4, 5, 6],\n\t\thideWhenUnavailable = false\n\t} = config || {};\n\n\tconst { editor } = useNotraEditor(providedEditor);\n\tconst [isVisible, setIsVisible] = React.useState(true);\n\n\tconst activeLevel = getActiveHeadingLevel(editor, levels);\n\tconst isActive = isHeadingActive(editor);\n\tconst canToggleState = canToggle(editor);\n\n\tReact.useEffect(() => {\n\t\tif (!editor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({ editor, hideWhenUnavailable, level: levels })\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\teditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\teditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [editor, hideWhenUnavailable, levels]);\n\n\treturn {\n\t\tisVisible,\n\t\tactiveLevel,\n\t\tisActive,\n\t\tcanToggle: canToggleState,\n\t\tlevels,\n\t\tIcon: activeLevel ? headingIcons[activeLevel] : Heading\n\t};\n}\n"
    },
    {
      "path": "hooks/use-heading.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport {\n\tHeading1,\n\tHeading2,\n\tHeading3,\n\tHeading4,\n\tHeading5,\n\tHeading6\n} from 'lucide-react';\nimport * as React from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/tiptap-utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6;\n\nexport interface UseHeadingConfig {\n\teditor?: Editor | null;\n\tlevel: Level;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const headingLabels: Record<Level, string> = {\n\t1: 'Heading 1',\n\t2: 'Heading 2',\n\t3: 'Heading 3',\n\t4: 'Heading 4',\n\t5: 'Heading 5',\n\t6: 'Heading 6'\n};\n\nexport const headingIcons: Record<Level, LucideIcon> = {\n\t1: Heading1,\n\t2: Heading2,\n\t3: Heading3,\n\t4: Heading4,\n\t5: Heading5,\n\t6: Heading6\n};\n\n/**\n * Checks if heading can be toggled in the current editor state\n */\nexport function canToggle(\n\teditor: Editor | null,\n\tlevel?: Level,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isNodeInSchema('heading', editor) ||\n\t\tisNodeTypeSelected(editor, ['image'])\n\t)\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\treturn level\n\t\t\t? editor.can().setNode('heading', { level })\n\t\t\t: editor.can().setNode('heading');\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Checks if heading is currently active\n */\nexport function isHeadingActive(\n\teditor: Editor | null,\n\tlevel?: Level | Level[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (Array.isArray(level)) {\n\t\treturn level.some((l) => editor.isActive('heading', { level: l }));\n\t}\n\n\treturn level\n\t\t? editor.isActive('heading', { level })\n\t\t: editor.isActive('heading');\n}\n\n/**\n * Toggles heading in the editor\n */\nexport function toggleHeading(\n\teditor: Editor | null,\n\tlevel: Level | Level[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tconst levels = Array.isArray(level) ? level : [level];\n\tconst toggleLevel = levels.find((l) => canToggle(editor, l));\n\n\tif (!toggleLevel) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\t// Convert cursor/text selection to NodeSelection for complex nodes like list items\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\tview.dispatch(tr);\n\t\t\tstate = view.state;\n\t\t}\n\n\t\tconst selection = state.selection;\n\t\tlet chain = editor.chain().focus();\n\n\t\t// Expand selection to cover full text range for NodeSelection\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tconst isActive = levels.some((l) =>\n\t\t\teditor.isActive('heading', { level: l })\n\t\t);\n\n\t\tconst toggle = isActive\n\t\t\t? chain.setNode('paragraph')\n\t\t\t: chain.setNode('heading', { level: toggleLevel });\n\n\t\ttoggle.run();\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Determines if the heading button should be shown\n */\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\tlevel?: Level | Level[];\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, level, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema('heading', editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\tif (Array.isArray(level)) {\n\t\t\treturn level.some((l) => canToggle(editor, l));\n\t\t}\n\n\t\treturn canToggle(editor, level);\n\t}\n\n\treturn true;\n}\n\nexport function useHeading(config: UseHeadingConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\tlevel,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst [isVisible, setIsVisible] = React.useState<boolean>(true);\n\tconst canToggleState = canToggle(activeEditor, level);\n\tconst isActive = isHeadingActive(activeEditor, level);\n\n\tReact.useEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\tlevel,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, level, hideWhenUnavailable]);\n\n\tconst handleToggle = React.useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleHeading(activeEditor, level);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, level, onToggled]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle: canToggleState,\n\t\tlabel: headingLabels[level],\n\t\tIcon: headingIcons[level]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-notra-editor.ts",
      "content": "import { useCurrentEditor, useEditorState } from '@tiptap/react';\nimport * as React from 'react';\n\nimport type { Editor } from '@tiptap/core';\n\n/**\n * Hook that provides access to a Tiptap editor instance.\n *\n * Accepts an optional editor instance directly, or falls back to retrieving\n * the editor from the Tiptap context if available. This allows components\n * to work both when given an editor directly and when used within a Tiptap\n * editor context.\n *\n * @param providedEditor - Optional editor instance to use instead of the context editor\n * @returns The provided editor or the editor from context, whichever is available\n */\nexport function useNotraEditor(providedEditor?: Editor | null): {\n\teditor: Editor | null;\n} {\n\tconst { editor: contextEditor } = useCurrentEditor();\n\tconst editor = React.useMemo(\n\t\t() => providedEditor ?? contextEditor,\n\t\t[providedEditor, contextEditor]\n\t);\n\n\treturn (\n\t\tuseEditorState({\n\t\t\teditor,\n\t\t\tselector(context) {\n\t\t\t\treturn {\n\t\t\t\t\teditor: context.editor,\n\t\t\t\t\teditorState: context.editor?.state\n\t\t\t\t};\n\t\t\t}\n\t\t}) || { editor: null }\n\t);\n}\n"
    },
    {
      "path": "hooks/__tests__/use-heading.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggle, toggleHeading } from '../use-heading';\nimport { getActiveHeadingLevel } from '../use-heading-dropdown-menu';\n\nimport type { Level } from '../use-heading';\n\n// ── Shared arbitraries ───────────────────────────────────────────────\n\nconst levelArbitrary: fc.Arbitrary<Level> = fc.constantFrom(\n\t1 as Level,\n\t2 as Level,\n\t3 as Level,\n\t4 as Level,\n\t5 as Level,\n\t6 as Level\n);\n\nconst levelsSubsetArbitrary: fc.Arbitrary<Level[]> = fc\n\t.subarray([1, 2, 3, 4, 5, 6] as Level[], { minLength: 0, maxLength: 6 })\n\t.map((arr) => [...arr].sort((a, b) => a - b));\n\n// ── Property 5: canToggle guard conditions ───────────────────────────\n\ntype CanToggleEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'no-heading-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleEditorState> =\n\tfc.constantFrom<CanToggleEditorState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'no-heading-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'heading' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// no-heading-in-schema: editable but heading not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 5: canToggle 守卫条件', () => {\n\t/**\n\t * **Validates: Requirements 6.4, 6.5**\n\t */\n\ttest('canToggle returns false when editor is null, not editable, or heading not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggle(editor as never, level);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 6: toggleHeading toggle behavior ────────────────────────\n\ntype ToggleEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'no-heading-in-schema' };\n\nconst toggleGuardArbitrary: fc.Arbitrary<ToggleEditorState> =\n\tfc.constantFrom<ToggleEditorState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'no-heading-in-schema' }\n\t);\n\nfunction buildToggleGuardEditor(state: ToggleEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'heading' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// no-heading-in-schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 6: toggleHeading 切换行为', () => {\n\t/**\n\t * **Validates: Requirements 6.2, 6.3**\n\t *\n\t * toggleHeading relies on editor.view, editor.chain(), NodeSelection, etc.\n\t * Full Tiptap chain API mocking is impractical, so we verify the guard\n\t * invariant: toggleHeading returns false for all invalid editor states.\n\t */\n\ttest('toggleHeading returns false when editor is null, not editable, or heading not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = toggleHeading(editor as never, level);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 6.2, 6.3**\n\t *\n\t * When canToggle returns false, toggleHeading must also return false.\n\t * This verifies the guard consistency between the two functions.\n\t */\n\ttest('toggleHeading returns false whenever canToggle returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggle(editor as never, level);\n\t\t\t\t\tconst toggleResult = toggleHeading(editor as never, level);\n\n\t\t\t\t\tif (!canToggleResult) {\n\t\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 7: getActiveHeadingLevel icon selection ─────────────────\n\ntype ActiveHeadingEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeLevel: Level | undefined };\n\nconst activeHeadingEditorArbitrary: fc.Arbitrary<ActiveHeadingEditorState> =\n\tfc.oneof(\n\t\tfc.constant<ActiveHeadingEditorState>({ type: 'null' }),\n\t\tfc.constant<ActiveHeadingEditorState>({ type: 'not-editable' }),\n\t\tfc.record<ActiveHeadingEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveLevel: fc.option(levelArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildActiveHeadingEditor(state: ActiveHeadingEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string, attrs?: { level: Level }) => {\n\t\t\tif (name !== 'heading') return false;\n\n\t\t\tif (!attrs || state.activeLevel === undefined) return false;\n\n\t\t\treturn attrs.level === state.activeLevel;\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 7: getActiveHeadingLevel 图标选择', () => {\n\t/**\n\t * **Validates: Requirements 7.2, 7.3**\n\t */\n\ttest('returns the first level in the array that is active, or undefined if none', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tactiveHeadingEditorArbitrary,\n\t\t\t\tlevelsSubsetArbitrary,\n\t\t\t\t(editorState, levels) => {\n\t\t\t\t\tconst editor = buildActiveHeadingEditor(editorState);\n\t\t\t\t\tconst result = getActiveHeadingLevel(editor as never, levels);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBeUndefined();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, find the expected first matching level\n\t\t\t\t\tconst expected = levels.find((l) => l === editorState.activeLevel);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 7.2, 7.3**\n\t */\n\ttest('returns undefined when no heading level is active', () => {\n\t\tfc.assert(\n\t\t\tfc.property(levelsSubsetArbitrary, (levels) => {\n\t\t\t\t// Editor where no heading is active\n\t\t\t\tconst editor = {\n\t\t\t\t\tisEditable: true,\n\t\t\t\t\tisActive: () => false\n\t\t\t\t};\n\n\t\t\t\tconst result = getActiveHeadingLevel(editor as never, levels);\n\n\t\t\t\texpect(result).toBeUndefined();\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "lib/tiptap-utils.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\n\nimport type { Editor } from '@tiptap/core';\nimport type { Node as TiptapNode } from '@tiptap/pm/model';\n\nexport function isNodeInSchema(\n\tnodeName: string,\n\teditor: Editor | null\n): boolean {\n\tif (!editor?.schema) return false;\n\n\treturn editor.schema.spec.nodes.get(nodeName) !== undefined;\n}\n\nexport function isNodeTypeSelected(\n\teditor: Editor | null,\n\ttypes: string[] = []\n): boolean {\n\tif (!editor || !editor.state.selection) return false;\n\n\tconst { state } = editor;\n\tconst { selection } = state;\n\n\tif (selection.empty) return false;\n\n\tif (selection instanceof NodeSelection) {\n\t\tconst node = selection.node;\n\n\t\treturn node ? types.includes(node.type.name) : false;\n\t}\n\n\treturn false;\n}\n\nexport function isValidPosition(pos: number | null | undefined): pos is number {\n\treturn typeof pos === 'number' && pos >= 0;\n}\n\nfunction findNodeAtPosition(editor: Editor, position: number) {\n\ttry {\n\t\tconst node = editor.state.doc.nodeAt(position);\n\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn node;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function findNodePosition(props: {\n\teditor: Editor | null;\n\tnode?: TiptapNode | null;\n\tnodePos?: number | null;\n}): { pos: number; node: TiptapNode } | null {\n\tconst { editor, node, nodePos } = props;\n\n\tif (!editor || !editor.state?.doc) return null;\n\n\tconst hasValidNode = node !== undefined && node !== null;\n\tconst hasValidPos = isValidPosition(nodePos);\n\n\tif (!hasValidNode && !hasValidPos) {\n\t\treturn null;\n\t}\n\n\tif (hasValidNode) {\n\t\tlet foundPos = -1;\n\t\tlet foundNode: TiptapNode | null = null;\n\n\t\teditor.state.doc.descendants((currentNode, pos) => {\n\t\t\tif (currentNode === node) {\n\t\t\t\tfoundPos = pos;\n\t\t\t\tfoundNode = currentNode;\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (foundPos !== -1 && foundNode !== null) {\n\t\t\treturn { pos: foundPos, node: foundNode };\n\t\t}\n\t}\n\n\tif (hasValidPos) {\n\t\tconst nodeAtPos = findNodeAtPosition(editor, nodePos!);\n\n\t\tif (nodeAtPos) {\n\t\t\treturn { pos: nodePos!, node: nodeAtPos };\n\t\t}\n\t}\n\n\treturn null;\n}\n"
    },
    {
      "path": "lib/utils.ts",
      "content": "import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n"
    },
    {
      "path": "lib/__tests__/tiptap-utils.test.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport {\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../tiptap-utils';\n\n// ── Property 2: isValidPosition ──────────────────────────────────────\n\ndescribe('Feature: toolbar-components, Property 2: isValidPosition 正确性', () => {\n\t/**\n\t * **Validates: Requirements 5.4**\n\t */\n\ttest('returns true if and only if value is a number >= 0', () => {\n\t\tconst valueArbitrary: fc.Arbitrary<number | null | undefined> = fc.oneof(\n\t\t\tfc.integer(),\n\t\t\tfc.double({ noNaN: false }),\n\t\t\tfc.constant(null),\n\t\t\tfc.constant(undefined)\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(valueArbitrary, (v) => {\n\t\t\t\tconst result = isValidPosition(v);\n\t\t\t\tconst expected = typeof v === 'number' && v >= 0;\n\n\t\t\t\texpect(result).toBe(expected);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 3: isNodeInSchema ───────────────────────────────────────\n\n// Minimal mock for the Editor.schema.spec.nodes interface\ninterface MockEditor {\n\tschema: {\n\t\tspec: {\n\t\t\tnodes: { get: (name: string) => unknown };\n\t\t};\n\t};\n}\n\ntype EditorInput = { type: 'null' } | { type: 'present'; nodeNames: string[] };\n\nconst editorInputArbitrary: fc.Arbitrary<EditorInput> = fc.oneof(\n\tfc.constant<EditorInput>({ type: 'null' }),\n\tfc.record<EditorInput & { type: 'present' }>({\n\t\ttype: fc.constant('present' as const),\n\t\tnodeNames: fc.array(fc.string({ minLength: 1, maxLength: 20 }), {\n\t\t\tminLength: 0,\n\t\t\tmaxLength: 10\n\t\t})\n\t})\n);\n\nfunction buildMockEditorForSchema(input: EditorInput): MockEditor | null {\n\tif (input.type === 'null') return null;\n\n\tconst nodeSet = new Set(input.nodeNames);\n\n\treturn {\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: (name: string) => (nodeSet.has(name) ? {} : undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 3: isNodeInSchema 正确性', () => {\n\t/**\n\t * **Validates: Requirements 5.1**\n\t */\n\ttest('returns true iff editor is non-null and schema.spec.nodes contains the name', () => {\n\t\tconst nodeNameArbitrary = fc.string({ minLength: 1, maxLength: 20 });\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorInputArbitrary,\n\t\t\t\tnodeNameArbitrary,\n\t\t\t\t(editorInput, nodeName) => {\n\t\t\t\t\tconst editor = buildMockEditorForSchema(editorInput);\n\t\t\t\t\tconst result = isNodeInSchema(nodeName, editor as never);\n\n\t\t\t\t\tif (editorInput.type === 'null') {\n\t\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst expected = editorInput.nodeNames.includes(nodeName);\n\n\t\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 4: isNodeTypeSelected ───────────────────────────────────\n\ntype SelectionKind =\n\t| { kind: 'null-editor' }\n\t| { kind: 'empty' }\n\t| { kind: 'text' }\n\t| { kind: 'node'; nodeTypeName: string };\n\nconst selectionKindArbitrary: fc.Arbitrary<SelectionKind> = fc.oneof(\n\tfc.constant<SelectionKind>({ kind: 'null-editor' }),\n\tfc.constant<SelectionKind>({ kind: 'empty' }),\n\tfc.constant<SelectionKind>({ kind: 'text' }),\n\tfc.record<SelectionKind & { kind: 'node' }>({\n\t\tkind: fc.constant('node' as const),\n\t\tnodeTypeName: fc.string({ minLength: 1, maxLength: 20 })\n\t})\n);\n\nfunction buildMockEditorForSelection(sel: SelectionKind) {\n\tif (sel.kind === 'null-editor') return null;\n\n\tif (sel.kind === 'empty') {\n\t\treturn {\n\t\t\tstate: {\n\t\t\t\tselection: { empty: true }\n\t\t\t}\n\t\t};\n\t}\n\n\tif (sel.kind === 'text') {\n\t\t// Non-empty, non-NodeSelection\n\t\treturn {\n\t\t\tstate: {\n\t\t\t\tselection: { empty: false }\n\t\t\t}\n\t\t};\n\t}\n\n\t// NodeSelection — create an object that passes `instanceof NodeSelection`\n\tconst nodeSelection = Object.create(NodeSelection.prototype, {\n\t\tempty: { value: false, writable: false },\n\t\tnode: {\n\t\t\tvalue: { type: { name: sel.nodeTypeName } },\n\t\t\twritable: false\n\t\t}\n\t});\n\n\treturn {\n\t\tstate: { selection: nodeSelection }\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 4: isNodeTypeSelected 正确性', () => {\n\t/**\n\t * **Validates: Requirements 5.2**\n\t */\n\ttest('returns true iff selection is a NodeSelection and node type name is in the types array', () => {\n\t\tconst typesArbitrary = fc.array(\n\t\t\tfc.string({ minLength: 1, maxLength: 20 }),\n\t\t\t{ minLength: 0, maxLength: 10 }\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(selectionKindArbitrary, typesArbitrary, (sel, types) => {\n\t\t\t\tconst editor = buildMockEditorForSelection(sel);\n\t\t\t\tconst result = isNodeTypeSelected(editor as never, types);\n\n\t\t\t\tif (sel.kind === 'null-editor') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else if (sel.kind === 'empty' || sel.kind === 'text') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else {\n\t\t\t\t\t// NodeSelection case\n\t\t\t\t\tconst expected = types.includes(sel.nodeTypeName);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "styles/base.css",
      "content": ".notra-editor {\n\twhite-space: pre-wrap;\n\toutline: none;\n\tcolor: var(--notra-text);\n}\n\n.notra-editor > * {\n\tposition: relative;\n}\n"
    },
    {
      "path": "styles/blockquote.css",
      "content": ".notra-editor {\n\tblockquote {\n\t\tposition: relative;\n\t\tpadding-left: 1em;\n\t\tpadding-top: 0.375em;\n\t\tpadding-bottom: 0.375em;\n\t\tmargin: 1.5rem 0;\n\n\t\tp {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t/* Decorative left bar via pseudo-element */\n\t\t&::before {\n\t\t\tposition: absolute;\n\t\t\tbottom: 0;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\theight: 100%;\n\t\t\twidth: 0.25em;\n\t\t\tbackground-color: var(--notra-blockquote-bar);\n\t\t\tcontent: '';\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/code.css",
      "content": ".notra-editor {\n\tcode {\n\t\tbackground-color: var(--notra-code-bg);\n\t\tcolor: var(--notra-code-text);\n\t\tborder: 1px solid var(--notra-code-border);\n\t\tfont-family:\n\t\t\tui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;\n\t\tfont-size: 0.875em;\n\t\tline-height: 1.4;\n\t\tborder-radius: 0.375rem;\n\t\tpadding: 0.1em 0.2em;\n\t}\n\n\tpre {\n\t\tbackground-color: var(--notra-codeblock-bg);\n\t\tcolor: var(--notra-codeblock-text);\n\t\tborder: 1px solid var(--notra-codeblock-border);\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 1.5em;\n\t\tpadding: 1em;\n\t\tfont-size: 1rem;\n\t\tborder-radius: 0.375rem;\n\t\toverflow-x: auto;\n\n\t\tcode {\n\t\t\tbackground-color: transparent;\n\t\t\tborder: none;\n\t\t\tborder-radius: 0;\n\t\t\tcolor: inherit;\n\t\t\tpadding: 0;\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/editor.css",
      "content": "@import './variables.css';\n@import './base.css';\n@import './heading.css';\n@import './text.css';\n@import './list.css';\n@import './code.css';\n@import './blockquote.css';\n@import './horizontal-rule.css';\n@import './image.css';\n"
    },
    {
      "path": "styles/heading.css",
      "content": "/* Vertical rhythm values from Tailwind Typography */\n.notra-editor {\n\th1,\n\th2,\n\th3,\n\th4 {\n\t\tposition: relative;\n\t\tcolor: inherit;\n\t\tfont-style: inherit;\n\n\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n\t}\n\n\th1 {\n\t\tmargin-top: 0;\n\t\tmargin-bottom: 0.888889em;\n\t\tfont-size: 2.25em;\n\t\tfont-weight: 700;\n\t\tline-height: 1.11111;\n\t}\n\n\th2 {\n\t\tmargin-top: 2em;\n\t\tmargin-bottom: 1em;\n\t\tfont-size: 1.5em;\n\t\tfont-weight: 700;\n\t\tline-height: 1.33333;\n\t}\n\n\th3 {\n\t\tmargin-top: 1.6em;\n\t\tmargin-bottom: 0.6em;\n\t\tfont-size: 1.25em;\n\t\tfont-weight: 600;\n\t\tline-height: 1.6;\n\t}\n\n\th4 {\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 0.5em;\n\t\tfont-weight: 600;\n\t\tline-height: 1.5;\n\t}\n}\n"
    },
    {
      "path": "styles/horizontal-rule.css",
      "content": ".notra-editor {\n\thr {\n\t\tborder: none;\n\t\theight: 1px;\n\t\tbackground-color: var(--notra-hr);\n\t\tmargin-top: 2.25em;\n\t\tmargin-bottom: 2.25em;\n\t}\n}\n"
    },
    {
      "path": "styles/image.css",
      "content": ".notra-editor {\n\timg {\n\t\tmax-width: 100%;\n\t\theight: auto;\n\t\tdisplay: block;\n\t\tmargin: 2rem 0;\n\t\tborder-radius: 0.25rem;\n\t}\n}\n"
    },
    {
      "path": "styles/list.css",
      "content": ".notra-editor {\n\tol,\n\tul {\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 1.5em;\n\t\tpadding-left: 1.5em;\n\n\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t&:last-child {\n\t\t\tmargin-bottom: 0;\n\t\t}\n\n\t\tol,\n\t\tul {\n\t\t\tmargin-top: 0;\n\t\t\tmargin-bottom: 0;\n\t\t}\n\t}\n\n\tli {\n\t\tp {\n\t\t\tmargin-top: 0;\n\t\t\tline-height: 1.6;\n\t\t}\n\t}\n\n\tol {\n\t\tlist-style: decimal;\n\n\t\tol {\n\t\t\tlist-style: lower-alpha;\n\n\t\t\tol {\n\t\t\t\tlist-style: lower-roman;\n\t\t\t}\n\t\t}\n\t}\n\n\tul {\n\t\tlist-style: disc;\n\n\t\tul {\n\t\t\tlist-style: circle;\n\n\t\t\tul {\n\t\t\t\tlist-style: square;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/text.css",
      "content": ".notra-editor {\n\tp:not(:first-child) {\n\t\tfont-size: 1rem;\n\t\tline-height: 1.6;\n\t\tfont-weight: normal;\n\t\tmargin-top: 1.25em;\n\t}\n\n\tstrong {\n\t\tfont-weight: 700;\n\t}\n\n\tem {\n\t\tfont-style: italic;\n\t}\n\n\ta {\n\t\tcolor: var(--notra-link);\n\t\ttext-decoration: underline;\n\t}\n\n\ta span {\n\t\ttext-decoration: underline;\n\t}\n\n\ts span {\n\t\ttext-decoration: line-through;\n\t}\n\n\tu span {\n\t\ttext-decoration: underline;\n\t}\n}\n"
    },
    {
      "path": "styles/variables.css",
      "content": "/* Palette - override these to change the theme */\n.notra-editor {\n\t/* Gray alpha scale */\n\t--notra-gray-a-50: rgb(56 56 56 / 4%);\n\t--notra-gray-a-100: rgb(15 22 36 / 5%);\n\t--notra-gray-a-200: rgb(37 39 45 / 10%);\n\t--notra-gray-a-300: rgb(47 50 55 / 20%);\n\t--notra-gray-a-400: rgb(40 44 51 / 42%);\n\t--notra-gray-a-500: rgb(52 55 60 / 64%);\n\t--notra-gray-a-600: rgb(36 39 46 / 78%);\n\t--notra-gray-a-700: rgb(35 37 42 / 87%);\n\t--notra-gray-a-800: rgb(30 32 36 / 95%);\n\t--notra-gray-a-900: rgb(29 30 32 / 98%);\n\n\t/* Brand */\n\t--notra-brand-50: rgb(239 238 255);\n\t--notra-brand-100: rgb(222 219 255);\n\t--notra-brand-200: rgb(195 189 255);\n\t--notra-brand-300: rgb(157 138 255);\n\t--notra-brand-400: rgb(122 82 255);\n\t--notra-brand-500: rgb(98 41 255);\n\t--notra-brand-600: rgb(84 0 229);\n\t--notra-brand-700: rgb(75 0 204);\n\t--notra-brand-800: rgb(56 0 153);\n\t--notra-brand-900: rgb(43 25 102);\n\t--notra-brand-950: hsl(257deg 100% 9%);\n\n\t/* Semantic tokens */\n\t--notra-text: var(--notra-gray-a-900);\n\t--notra-link: var(--notra-brand-500);\n\t--notra-code-bg: var(--notra-gray-a-100);\n\t--notra-code-text: var(--notra-gray-a-700);\n\t--notra-code-border: var(--notra-gray-a-200);\n\t--notra-codeblock-bg: var(--notra-gray-a-50);\n\t--notra-codeblock-text: var(--notra-gray-a-800);\n\t--notra-codeblock-border: var(--notra-gray-a-200);\n\t--notra-blockquote-bar: var(--notra-gray-a-900);\n\t--notra-hr: var(--notra-gray-a-200);\n}\n\n/* Dark mode via .dark ancestor or class on editor itself */\n.dark .notra-editor,\n.notra-editor.dark {\n\t--notra-gray-a-50: rgb(232 232 253 / 5%);\n\t--notra-gray-a-100: rgb(231 231 243 / 7%);\n\t--notra-gray-a-200: rgb(238 238 246 / 11%);\n\t--notra-gray-a-300: rgb(239 239 245 / 22%);\n\t--notra-gray-a-400: rgb(244 244 255 / 37%);\n\t--notra-gray-a-500: rgb(236 238 253 / 50%);\n\t--notra-gray-a-600: rgb(247 247 253 / 64%);\n\t--notra-gray-a-700: rgb(251 251 254 / 75%);\n\t--notra-gray-a-800: rgb(253 253 253 / 88%);\n\t--notra-gray-a-900: rgb(255 255 255 / 96%);\n\t--notra-link: var(--notra-brand-400);\n}\n\n/* Dark mode via system preference (opt-out with .light class) */\n@media (prefers-color-scheme: dark) {\n\t.notra-editor:not(.light) {\n\t\t--notra-gray-a-50: rgb(232 232 253 / 5%);\n\t\t--notra-gray-a-100: rgb(231 231 243 / 7%);\n\t\t--notra-gray-a-200: rgb(238 238 246 / 11%);\n\t\t--notra-gray-a-300: rgb(239 239 245 / 22%);\n\t\t--notra-gray-a-400: rgb(244 244 255 / 37%);\n\t\t--notra-gray-a-500: rgb(236 238 253 / 50%);\n\t\t--notra-gray-a-600: rgb(247 247 253 / 64%);\n\t\t--notra-gray-a-700: rgb(251 251 254 / 75%);\n\t\t--notra-gray-a-800: rgb(253 253 253 / 88%);\n\t\t--notra-gray-a-900: rgb(255 255 255 / 96%);\n\t\t--notra-link: var(--notra-brand-400);\n\t}\n}\n"
    },
    {
      "path": "ui/fixed-toolbar.tsx",
      "content": "import { HeadingDropdownMenu } from './heading-dropdown-menu';\nimport { Separator } from './primitives/separator';\nimport { Spacer } from './primitives/spacer';\nimport { UndoRedoButton } from './undo-redo-button';\nimport { cn } from '../lib/utils';\n\nfunction ToolbarGroup({ children }: { children: React.ReactNode }) {\n\treturn <div className=\"flex items-center gap-0.5\">{children}</div>;\n}\n\nfunction ToolbarSeparator() {\n\treturn <Separator className=\"!h-6\" orientation=\"vertical\" />;\n}\n\nexport interface FixedToolbarProps {\n\tclassName?: string;\n}\n\nexport function FixedToolbar({ className }: FixedToolbarProps) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t'h-11 flex items-center gap-1 overflow-x-auto px-2 border-b',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t>\n\t\t\t<Spacer />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<UndoRedoButton action=\"undo\" />\n\t\t\t\t<UndoRedoButton action=\"redo\" />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<HeadingDropdownMenu />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<Spacer />\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "ui/heading-button.tsx",
      "content": "import * as React from 'react';\n\nimport { DropdownMenuItem } from './primitives/dropdown-menu';\nimport { useHeading } from '../hooks/use-heading';\n\nimport type { Level } from '../hooks/use-heading';\n\nexport interface HeadingButtonProps {\n\tlevel: Level;\n}\n\nexport function HeadingButton({ level }: HeadingButtonProps) {\n\tconst { isVisible, handleToggle, Icon, label } = useHeading({ level });\n\n\tconst handleClick = React.useCallback(\n\t\t(event: React.MouseEvent<HTMLDivElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenuItem onClick={handleClick}>\n\t\t\t<Icon className=\"text-popover-foreground\" />\n\t\t\t{label}\n\t\t</DropdownMenuItem>\n\t);\n}\n"
    },
    {
      "path": "ui/heading-dropdown-menu.tsx",
      "content": "import { ChevronDown } from 'lucide-react';\n\nimport { HeadingButton } from './heading-button';\nimport { useHeadingDropdownMenu } from '../hooks/use-heading-dropdown-menu';\nimport { Button } from './primitives/button';\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuTrigger\n} from './primitives/dropdown-menu';\n\nexport function HeadingDropdownMenu() {\n\tconst { isVisible, isActive, canToggle, Icon, levels } =\n\t\tuseHeadingDropdownMenu({\n\t\t\tlevels: [1, 2, 3, 4, 5, 6]\n\t\t});\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Format text as heading\"\n\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\tdata-active-state={isActive ? 'on' : 'off'}\n\t\t\t\t\tdata-disabled={!canToggle}\n\t\t\t\t\tdata-style=\"ghost\"\n\t\t\t\t\tdisabled={!canToggle}\n\t\t\t\t\tisActive={isActive}\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t>\n\t\t\t\t\t<Icon />\n\t\t\t\t\t<ChevronDown className=\"size-2.5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\n\t\t\t<DropdownMenuContent\n\t\t\t\talign=\"start\"\n\t\t\t\tonCloseAutoFocus={(e) => e.preventDefault()}\n\t\t\t>\n\t\t\t\t{levels.map((level) => (\n\t\t\t\t\t<HeadingButton key={`heading-${level}`} level={level} />\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n"
    },
    {
      "path": "ui/primitives/button.tsx",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\nimport { Slot } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nconst buttonVariants = cva(\n\t\"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: 'bg-primary text-primary-foreground hover:bg-primary/90',\n\t\t\t\tdestructive:\n\t\t\t\t\t'bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n\t\t\t\toutline:\n\t\t\t\t\t'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',\n\t\t\t\tsecondary:\n\t\t\t\t\t'bg-secondary text-secondary-foreground hover:bg-secondary/80',\n\t\t\t\tghost:\n\t\t\t\t\t'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',\n\t\t\t\tlink: 'text-primary underline-offset-4 hover:underline'\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tdefault: 'h-9 px-4 py-2 has-[>svg]:px-3',\n\t\t\t\txs: 'h-7 gap-0 px-1.5',\n\t\t\t\tsm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',\n\t\t\t\tlg: 'h-10 rounded-md px-6 has-[>svg]:px-4',\n\t\t\t\ticon: 'size-9',\n\t\t\t\t'icon-xs': 'size-7',\n\t\t\t\t'icon-sm': 'size-8',\n\t\t\t\t'icon-lg': 'size-10'\n\t\t\t},\n\t\t\tisActive: {\n\t\t\t\ttrue: 'bg-accent text-accent-foreground dark:bg-accent/50'\n\t\t\t}\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: 'default',\n\t\t\tsize: 'default'\n\t\t}\n\t}\n);\n\nfunction Button({\n\tclassName,\n\tvariant = 'default',\n\tsize = 'default',\n\tasChild = false,\n\tisActive = false,\n\t...props\n}: Readonly<React.ComponentProps<'button'>> &\n\tVariantProps<typeof buttonVariants> & {\n\t\tasChild?: boolean;\n\t}) {\n\tconst Comp = asChild ? Slot.Root : 'button';\n\n\treturn (\n\t\t<Comp\n\t\t\tclassName={cn(buttonVariants({ variant, size, className, isActive }))}\n\t\t\tdata-size={size}\n\t\t\tdata-slot=\"button\"\n\t\t\tdata-variant={variant}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport { Button, buttonVariants };\n"
    },
    {
      "path": "ui/primitives/dropdown-menu.tsx",
      "content": "import { DropdownMenu as DropdownMenuPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction DropdownMenu({\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {\n\treturn <DropdownMenuPrimitive.Root data-slot=\"dropdown-menu\" {...props} />;\n}\n\nfunction DropdownMenuTrigger({\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Trigger\n\t\t\tdata-slot=\"dropdown-menu-trigger\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction DropdownMenuContent({\n\tclassName,\n\tsideOffset = 4,\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Portal>\n\t\t\t<DropdownMenuPrimitive.Content\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\tdata-slot=\"dropdown-menu-content\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</DropdownMenuPrimitive.Portal>\n\t);\n}\n\nfunction DropdownMenuItem({\n\tclassName,\n\tinset,\n\tvariant = 'default',\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {\n\tinset?: boolean;\n\tvariant?: 'default' | 'destructive';\n}) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Item\n\t\t\tclassName={cn(\n\t\t\t\t\"focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-inset={inset}\n\t\t\tdata-slot=\"dropdown-menu-item\"\n\t\t\tdata-variant={variant}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuItem\n};\n"
    },
    {
      "path": "ui/primitives/separator.tsx",
      "content": "import { Separator as SeparatorPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction Separator({\n\tclassName,\n\torientation = 'horizontal',\n\tdecorative = true,\n\t...props\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\n\treturn (\n\t\t<SeparatorPrimitive.Root\n\t\t\tclassName={cn(\n\t\t\t\t'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"separator\"\n\t\t\tdecorative={decorative}\n\t\t\torientation={orientation}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport { Separator };\n"
    },
    {
      "path": "ui/primitives/spacer.tsx",
      "content": "import * as React from 'react';\n\nexport type SpacerOrientation = 'horizontal' | 'vertical';\n\nexport interface SpacerProps extends React.HTMLAttributes<HTMLDivElement> {\n\torientation?: SpacerOrientation;\n\tsize?: string | number;\n}\n\nexport function Spacer({\n\torientation = 'horizontal',\n\tsize,\n\tstyle = {},\n\t...props\n}: SpacerProps) {\n\tconst computedStyle = {\n\t\t...style,\n\t\t...(orientation === 'horizontal' && !size && { flex: 1 }),\n\t\t...(size && {\n\t\t\twidth: orientation === 'vertical' ? '1px' : size,\n\t\t\theight: orientation === 'horizontal' ? '1px' : size\n\t\t})\n\t};\n\n\treturn <div {...props} style={computedStyle} />;\n}\n"
    },
    {
      "path": "ui/undo-redo-button.tsx",
      "content": "import { useEditorState } from '@tiptap/react';\nimport { Redo2, Undo2 } from 'lucide-react';\n\nimport { useNotraEditor } from '../hooks/use-notra-editor';\nimport { Button } from './primitives/button';\n\nimport type { Editor } from '@tiptap/core';\n\nexport interface UndoRedoButtonProps {\n\taction: 'undo' | 'redo';\n}\n\nexport function canExecuteAction(\n\teditor: Editor | null,\n\taction: 'undo' | 'redo'\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn action === 'undo' ? editor.can().undo() : editor.can().redo();\n}\n\nexport function executeAction(\n\teditor: Editor | null,\n\taction: 'undo' | 'redo'\n): boolean {\n\tif (!editor || !canExecuteAction(editor, action)) return false;\n\n\tconst chain = editor.chain().focus();\n\n\treturn action === 'undo' ? chain.undo().run() : chain.redo().run();\n}\n\nexport function UndoRedoButton({ action }: UndoRedoButtonProps) {\n\tconst { editor } = useNotraEditor();\n\n\tconst canExecute = useEditorState({\n\t\teditor,\n\t\tselector: (ctx) => canExecuteAction(ctx.editor, action)\n\t});\n\n\tconst Icon = action === 'undo' ? Undo2 : Redo2;\n\n\treturn (\n\t\t<Button\n\t\t\tdisabled={!canExecute}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={() => executeAction(editor, action)}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/__tests__/spacer.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport type { SpacerOrientation } from '../primitives/spacer';\n\n// Replicate the pure style computation from Spacer component\nfunction computeSpacerStyle(\n\torientation: SpacerOrientation = 'horizontal',\n\tsize: string | number | undefined,\n\tstyle: React.CSSProperties = {}\n): React.CSSProperties {\n\treturn {\n\t\t...style,\n\t\t...(orientation === 'horizontal' && !size && { flex: 1 }),\n\t\t...(size && {\n\t\t\twidth: orientation === 'vertical' ? '1px' : size,\n\t\t\theight: orientation === 'horizontal' ? '1px' : size\n\t\t})\n\t};\n}\n\n// ── Generators ───────────────────────────────────────────────────────\n\nconst orientationArbitrary: fc.Arbitrary<SpacerOrientation> = fc.constantFrom(\n\t'horizontal' as const,\n\t'vertical' as const\n);\n\nconst sizeArbitrary: fc.Arbitrary<string | number | undefined> = fc.oneof(\n\tfc.constant(undefined),\n\tfc.integer({ min: 1, max: 1000 }),\n\tfc.constantFrom('10px', '2rem', '50%', '1.5em', '100vh')\n);\n\n// ── Property 1: Spacer 样式计算正确性 ────────────────────────────────\n\ndescribe('Feature: toolbar-components, Property 1: Spacer 样式计算正确性', () => {\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('horizontal + no size → style contains flex: 1', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constant('horizontal' as SpacerOrientation),\n\t\t\t\tfc.constant(undefined),\n\t\t\t\t(orientation, size) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\t\texpect(result).toHaveProperty('flex', 1);\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('when size is provided, horizontal sets width=size and height=1px; vertical sets width=1px and height=size', () => {\n\t\tconst definedSizeArbitrary: fc.Arbitrary<string | number> = fc.oneof(\n\t\t\tfc.integer({ min: 1, max: 1000 }),\n\t\t\tfc.constantFrom('10px', '2rem', '50%', '1.5em', '100vh')\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\torientationArbitrary,\n\t\t\t\tdefinedSizeArbitrary,\n\t\t\t\t(orientation, size) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\n\t\t\t\t\tif (orientation === 'horizontal') {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', size);\n\t\t\t\t\t\texpect(result).toHaveProperty('height', '1px');\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', '1px');\n\t\t\t\t\t\texpect(result).toHaveProperty('height', size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('for any orientation and size combination, computed style satisfies all Spacer invariants', () => {\n\t\tfc.assert(\n\t\t\tfc.property(orientationArbitrary, sizeArbitrary, (orientation, size) => {\n\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\tif (orientation === 'horizontal' && !size) {\n\t\t\t\t\t// Req 1.2: flex: 1 when horizontal and no size\n\t\t\t\t\texpect(result).toHaveProperty('flex', 1);\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t} else if (size) {\n\t\t\t\t\t// Req 1.3: size applied as width/height based on orientation\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\n\t\t\t\t\tif (orientation === 'horizontal') {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', size);\n\t\t\t\t\t\texpect(result).toHaveProperty('height', '1px');\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', '1px');\n\t\t\t\t\t\texpect(result).toHaveProperty('height', size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// vertical + no size: no special styles\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('user-provided style properties are preserved in computed style', () => {\n\t\tconst userStyleArbitrary = fc.record({\n\t\t\tcolor: fc.constantFrom('red', 'blue', 'green'),\n\t\t\tmargin: fc.constantFrom('4px', '8px', '16px')\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\torientationArbitrary,\n\t\t\t\tsizeArbitrary,\n\t\t\t\tuserStyleArbitrary,\n\t\t\t\t(orientation, size, userStyle) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size, userStyle);\n\n\t\t\t\t\t// User-provided styles should always be present\n\t\t\t\t\texpect(result).toHaveProperty('color', userStyle.color);\n\t\t\t\t\texpect(result).toHaveProperty('margin', userStyle.margin);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "ui/__tests__/undo-redo-button.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test, vi } from 'vitest';\n\nimport { canExecuteAction, executeAction } from '../undo-redo-button';\n\n// Minimal mock that satisfies the subset of Editor used by canExecuteAction\ninterface MockEditor {\n\tisEditable: boolean;\n\tcan: () => { undo: () => boolean; redo: () => boolean };\n}\n\ntype EditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; canUndo: boolean; canRedo: boolean };\n\nconst editorStateArbitrary: fc.Arbitrary<EditorState> = fc.oneof(\n\tfc.constant<EditorState>({ type: 'null' }),\n\tfc.constant<EditorState>({ type: 'not-editable' }),\n\tfc.record<EditorState & { type: 'editable' }>({\n\t\ttype: fc.constant('editable' as const),\n\t\tcanUndo: fc.boolean(),\n\t\tcanRedo: fc.boolean()\n\t})\n);\n\nconst actionArbitrary: fc.Arbitrary<'undo' | 'redo'> = fc.constantFrom(\n\t'undo' as const,\n\t'redo' as const\n);\n\nfunction buildMockEditor(state: EditorState): MockEditor | null {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tcan: () => ({ undo: () => false, redo: () => false })\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tcan: () => ({\n\t\t\tundo: () => state.canUndo,\n\t\t\tredo: () => state.canRedo\n\t\t})\n\t};\n}\n\nfunction expectedResult(state: EditorState, action: 'undo' | 'redo'): boolean {\n\tif (state.type === 'null' || state.type === 'not-editable') return false;\n\n\treturn action === 'undo' ? state.canUndo : state.canRedo;\n}\n\ndescribe('Feature: fixed-toolbar, Property 1: canExecuteAction 正确反映编辑器能力', () => {\n\t/**\n\t * **Validates: Requirements 3.7, 3.8, 4.3**\n\t */\n\ttest('Property 1: canExecuteAction returns true iff editor is non-null, editable, and has matching history', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst editor = buildMockEditor(state);\n\t\t\t\t// Cast to satisfy the Editor type parameter without importing the full Tiptap dependency\n\t\t\t\tconst result = canExecuteAction(editor as never, action);\n\n\t\t\t\texpect(result).toBe(expectedResult(state, action));\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n// Extended mock that also tracks chain().focus().undo()/redo().run() calls\ninterface MockEditorWithChain {\n\tisEditable: boolean;\n\tcan: () => { undo: () => boolean; redo: () => boolean };\n\tchain: () => {\n\t\tfocus: () => {\n\t\t\tundo: () => { run: () => boolean };\n\t\t\tredo: () => { run: () => boolean };\n\t\t};\n\t};\n}\n\nfunction buildMockEditorWithChain(state: EditorState): {\n\teditor: MockEditorWithChain | null;\n\tspies: { undo: ReturnType<typeof vi.fn>; redo: ReturnType<typeof vi.fn> };\n} {\n\tconst undoRunSpy = vi.fn(() => true);\n\tconst redoRunSpy = vi.fn(() => true);\n\tconst spies = { undo: undoRunSpy, redo: redoRunSpy };\n\n\tif (state.type === 'null') return { editor: null, spies };\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\teditor: {\n\t\t\t\tisEditable: false,\n\t\t\t\tcan: () => ({ undo: () => false, redo: () => false }),\n\t\t\t\tchain: () => ({\n\t\t\t\t\tfocus: () => ({\n\t\t\t\t\t\tundo: () => ({ run: undoRunSpy }),\n\t\t\t\t\t\tredo: () => ({ run: redoRunSpy })\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\tspies\n\t\t};\n\t}\n\n\treturn {\n\t\teditor: {\n\t\t\tisEditable: true,\n\t\t\tcan: () => ({\n\t\t\t\tundo: () => state.canUndo,\n\t\t\t\tredo: () => state.canRedo\n\t\t\t}),\n\t\t\tchain: () => ({\n\t\t\t\tfocus: () => ({\n\t\t\t\t\tundo: () => ({ run: undoRunSpy }),\n\t\t\t\t\tredo: () => ({ run: redoRunSpy })\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\t\tspies\n\t};\n}\n\ndescribe('Feature: fixed-toolbar, Property 2: executeAction 安全性', () => {\n\t/**\n\t * **Validates: Requirements 3.5, 3.6**\n\t */\n\ttest('Property 2: when canExecuteAction is false, executeAction returns false and calls no commands', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst { editor, spies } = buildMockEditorWithChain(state);\n\t\t\t\tconst canExecute = canExecuteAction(editor as never, action);\n\n\t\t\t\tif (!canExecute) {\n\t\t\t\t\tconst result = executeAction(editor as never, action);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\texpect(spies.undo).not.toHaveBeenCalled();\n\t\t\t\t\texpect(spies.redo).not.toHaveBeenCalled();\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 3.5, 3.6**\n\t */\n\ttest('Property 2: when canExecuteAction is true, executeAction calls the corresponding command', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst { editor, spies } = buildMockEditorWithChain(state);\n\t\t\t\tconst canExecute = canExecuteAction(editor as never, action);\n\n\t\t\t\tif (canExecute) {\n\t\t\t\t\tconst result = executeAction(editor as never, action);\n\n\t\t\t\t\texpect(result).toBe(true);\n\n\t\t\t\t\tif (action === 'undo') {\n\t\t\t\t\t\texpect(spies.undo).toHaveBeenCalledOnce();\n\t\t\t\t\t\texpect(spies.redo).not.toHaveBeenCalled();\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(spies.redo).toHaveBeenCalledOnce();\n\t\t\t\t\t\texpect(spies.undo).not.toHaveBeenCalled();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "vitest.config.ts",
      "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n\ttest: {\n\t\tinclude: [\n\t\t\t'ui/__tests__/**/*.test.ts',\n\t\t\t'lib/__tests__/**/*.test.ts',\n\t\t\t'hooks/__tests__/**/*.test.ts'\n\t\t],\n\t\ttestTimeout: 30000\n\t}\n});\n"
    }
  ],
  "dependencies": [
    {
      "name": "@tiptap/core",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-horizontal-rule",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/pm",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/react",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/starter-kit",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/static-renderer",
      "version": "3.19.0"
    },
    {
      "name": "class-variance-authority",
      "version": "0.7.1"
    },
    {
      "name": "clsx",
      "version": "2.1.1"
    },
    {
      "name": "lucide-react",
      "version": "0.511.0"
    },
    {
      "name": "radix-ui",
      "version": "1.4.2"
    },
    {
      "name": "tailwind-merge",
      "version": "3.3.0"
    }
  ]
}