{
  "name": "editor",
  "version": "0.0.0",
  "description": "Minimal Tiptap React editor component",
  "files": [
    {
      "path": "core/editor.tsx",
      "content": "import '../styles/editor.css';\n\nimport { EditorContent, EditorContext, useEditor } from '@tiptap/react';\n\nimport { EditorExtensions } from '../extensions/editor';\nimport { getDictionary, I18nProvider } from '../i18n';\nimport { FixedToolbar } from '../ui/fixed-toolbar';\n\nimport type { Dictionary, Locale } from '../i18n';\n\nexport interface EditorProps {\n\tcontent?: string;\n\tonChange?: (content: string) => void;\n\tlocale?: Locale;\n\tmessages?: Partial<Dictionary>;\n}\n\nexport function Editor({\n\tcontent = '',\n\tonChange,\n\tlocale = 'en',\n\tmessages\n}: EditorProps) {\n\tconst dictionary = getDictionary(locale, messages);\n\n\tconst editor = useEditor({\n\t\tcontent,\n\t\teditorProps: {\n\t\t\tattributes: {\n\t\t\t\tautocomplete: 'off',\n\t\t\t\tautocorrect: 'off',\n\t\t\t\tautocapitalize: 'off',\n\t\t\t\t'aria-label': dictionary['editor.ariaLabel'],\n\t\t\t\tclass:\n\t\t\t\t\t'notra-editor flex-1 px-4 sm:px-[max(64px,calc(50%-375px))] pb-[30vh] pt-15 sm:pt-23 outline-none'\n\t\t\t}\n\t\t},\n\t\textensions: EditorExtensions,\n\t\tonUpdate: ({ editor }) => onChange?.(editor.getHTML())\n\t});\n\n\treturn (\n\t\t<I18nProvider locale={locale} messages={messages}>\n\t\t\t<EditorContext.Provider value={{ editor }}>\n\t\t\t\t<FixedToolbar />\n\t\t\t\t<EditorContent editor={editor} />\n\t\t\t</EditorContext.Provider>\n\t\t</I18nProvider>\n\t);\n}\n"
    },
    {
      "path": "core/viewer.tsx",
      "content": "import '../styles/editor.css';\n\nimport { JSONContent } from '@tiptap/core';\nimport { renderToReactElement } from '@tiptap/static-renderer/pm/react';\nimport { JSX } from 'react';\n\nimport { ViewerExtensions } from '../extensions/viewer';\n\nexport interface ViewerProps {\n\tcontent: JSONContent;\n}\n\nexport function Viewer({ content }: ViewerProps): JSX.Element {\n\treturn (\n\t\t<div className=\"notra-editor\">\n\t\t\t{renderToReactElement({ extensions: ViewerExtensions, content })}\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "extensions/editor.ts",
      "content": "import { TaskItem } from '@tiptap/extension-task-item';\nimport { TaskList } from '@tiptap/extension-task-list';\nimport { Underline } from '@tiptap/extension-underline';\n\nimport { HorizontalRule } from './horizontal-rule';\nimport { Starter } from './starter';\n\nexport const EditorExtensions = [\n\tStarter,\n\tHorizontalRule,\n\tTaskList,\n\tTaskItem.configure({ nested: true }),\n\tUnderline\n];\n"
    },
    {
      "path": "extensions/horizontal-rule.ts",
      "content": "import TiptapHorizontalRule from '@tiptap/extension-horizontal-rule';\nimport { mergeAttributes } from '@tiptap/react';\n\n// Wrapper div enables better cursor positioning around the rule\nexport const HorizontalRule = TiptapHorizontalRule.extend({\n\trenderHTML() {\n\t\treturn [\n\t\t\t'div',\n\t\t\tmergeAttributes(this.options.HTMLAttributes, { 'data-type': this.name }),\n\t\t\t['hr']\n\t\t];\n\t}\n});\n"
    },
    {
      "path": "extensions/starter.ts",
      "content": "import { StarterKit } from '@tiptap/starter-kit';\n\nexport const Starter = StarterKit.configure({\n\thorizontalRule: false,\n\tcodeBlock: false\n});\n"
    },
    {
      "path": "extensions/viewer.ts",
      "content": "import { HorizontalRule } from './horizontal-rule';\nimport { Starter } from './starter';\n\nexport const ViewerExtensions = [Starter, HorizontalRule];\n"
    },
    {
      "path": "hooks/use-blockquote.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport { TextQuote } from 'lucide-react';\nimport * as React from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport const BLOCKQUOTE_SHORTCUT_KEY = 'mod+shift+b';\n\nexport interface UseBlockquoteConfig {\n\teditor?: Editor | null;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport function canToggleBlockquote(\n\teditor: Editor | null,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isNodeInSchema('blockquote', editor) ||\n\t\tisNodeTypeSelected(editor, ['image'])\n\t)\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\treturn editor.can().toggleWrap('blockquote');\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function toggleBlockquote(editor: Editor | null): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleBlockquote(editor)) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\tview.dispatch(tr);\n\t\t\tstate = view.state;\n\t\t}\n\n\t\tconst selection = state.selection;\n\n\t\tlet chain = editor.chain().focus();\n\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tconst toggle = editor.isActive('blockquote')\n\t\t\t? chain.lift('blockquote')\n\t\t\t: chain.wrapIn('blockquote');\n\n\t\ttoggle.run();\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema('blockquote', editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleBlockquote(editor);\n\t}\n\n\treturn true;\n}\n\nexport function useBlockquote(config?: UseBlockquoteConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config || {};\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = React.useState<boolean>(true);\n\tconst canToggle = canToggleBlockquote(activeEditor);\n\tconst isActive = activeEditor?.isActive('blockquote') || false;\n\n\tReact.useEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, hideWhenUnavailable]);\n\n\tconst handleToggle = React.useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleBlockquote(activeEditor);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, onToggled]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle,\n\t\tlabel: dictionary['blockquote.label' as keyof typeof dictionary],\n\t\tshortcutKeys: BLOCKQUOTE_SHORTCUT_KEY,\n\t\tIcon: TextQuote as LucideIcon\n\t};\n}\n"
    },
    {
      "path": "hooks/use-heading-dropdown-menu.ts",
      "content": "import { Heading } from 'lucide-react';\nimport * as React from 'react';\n\nimport {\n\theadingIcons,\n\ttype Level,\n\tisHeadingActive,\n\tcanToggle,\n\tshouldShowButton\n} from './use-heading';\nimport { useNotraEditor } from './use-notra-editor';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport interface UseHeadingDropdownMenuConfig {\n\teditor?: Editor | null;\n\tlevels?: Level[];\n\thideWhenUnavailable?: boolean;\n}\n\nexport function getActiveHeadingLevel(\n\teditor: Editor | null,\n\tlevels: Level[] = [1, 2, 3, 4, 5, 6]\n): Level | undefined {\n\tif (!editor || !editor.isEditable) return undefined;\n\n\treturn levels.find((level) => isHeadingActive(editor, level));\n}\n\nexport function useHeadingDropdownMenu(config?: UseHeadingDropdownMenuConfig): {\n\tisVisible: boolean;\n\tactiveLevel: Level | undefined;\n\tisActive: boolean;\n\tcanToggle: boolean;\n\tlevels: Level[];\n\tIcon: LucideIcon;\n} {\n\tconst {\n\t\teditor: providedEditor,\n\t\tlevels = [1, 2, 3, 4, 5, 6],\n\t\thideWhenUnavailable = false\n\t} = config || {};\n\n\tconst { editor } = useNotraEditor(providedEditor);\n\tconst [isVisible, setIsVisible] = React.useState(true);\n\n\tconst activeLevel = getActiveHeadingLevel(editor, levels);\n\tconst isActive = isHeadingActive(editor);\n\tconst canToggleState = canToggle(editor);\n\n\tReact.useEffect(() => {\n\t\tif (!editor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({ editor, hideWhenUnavailable, level: levels })\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\teditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\teditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [editor, hideWhenUnavailable, levels]);\n\n\treturn {\n\t\tisVisible,\n\t\tactiveLevel,\n\t\tisActive,\n\t\tcanToggle: canToggleState,\n\t\tlevels,\n\t\tIcon: activeLevel ? headingIcons[activeLevel] : Heading\n\t};\n}\n"
    },
    {
      "path": "hooks/use-heading.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport {\n\tHeading1,\n\tHeading2,\n\tHeading3,\n\tHeading4,\n\tHeading5,\n\tHeading6\n} from 'lucide-react';\nimport * as React from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6;\n\nexport interface UseHeadingConfig {\n\teditor?: Editor | null;\n\tlevel: Level;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const headingIcons: Record<Level, LucideIcon> = {\n\t1: Heading1,\n\t2: Heading2,\n\t3: Heading3,\n\t4: Heading4,\n\t5: Heading5,\n\t6: Heading6\n};\n\n/**\n * Checks if heading can be toggled in the current editor state\n */\nexport function canToggle(\n\teditor: Editor | null,\n\tlevel?: Level,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (\n\t\t!isNodeInSchema('heading', editor) ||\n\t\tisNodeTypeSelected(editor, ['image'])\n\t)\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\treturn level\n\t\t\t? editor.can().setNode('heading', { level })\n\t\t\t: editor.can().setNode('heading');\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Checks if heading is currently active\n */\nexport function isHeadingActive(\n\teditor: Editor | null,\n\tlevel?: Level | Level[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (Array.isArray(level)) {\n\t\treturn level.some((l) => editor.isActive('heading', { level: l }));\n\t}\n\n\treturn level\n\t\t? editor.isActive('heading', { level })\n\t\t: editor.isActive('heading');\n}\n\n/**\n * Toggles heading in the editor\n */\nexport function toggleHeading(\n\teditor: Editor | null,\n\tlevel: Level | Level[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tconst levels = Array.isArray(level) ? level : [level];\n\tconst toggleLevel = levels.find((l) => canToggle(editor, l));\n\n\tif (!toggleLevel) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\t// Convert cursor/text selection to NodeSelection for complex nodes like list items\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\tview.dispatch(tr);\n\t\t\tstate = view.state;\n\t\t}\n\n\t\tconst selection = state.selection;\n\t\tlet chain = editor.chain().focus();\n\n\t\t// Expand selection to cover full text range for NodeSelection\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tconst isActive = levels.some((l) =>\n\t\t\teditor.isActive('heading', { level: l })\n\t\t);\n\n\t\tconst toggle = isActive\n\t\t\t? chain.setNode('paragraph')\n\t\t\t: chain.setNode('heading', { level: toggleLevel });\n\n\t\ttoggle.run();\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Determines if the heading button should be shown\n */\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\tlevel?: Level | Level[];\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, level, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema('heading', editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\tif (Array.isArray(level)) {\n\t\t\treturn level.some((l) => canToggle(editor, l));\n\t\t}\n\n\t\treturn canToggle(editor, level);\n\t}\n\n\treturn true;\n}\n\nexport function useHeading(config: UseHeadingConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\tlevel,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = React.useState<boolean>(true);\n\tconst canToggleState = canToggle(activeEditor, level);\n\tconst isActive = isHeadingActive(activeEditor, level);\n\n\tReact.useEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\tlevel,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, level, hideWhenUnavailable]);\n\n\tconst handleToggle = React.useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleHeading(activeEditor, level);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, level, onToggled]);\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle: canToggleState,\n\t\tlabel: dictionary[`heading.${level}`],\n\t\tIcon: headingIcons[level]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-list-dropdown-menu.ts",
      "content": "import { List } from 'lucide-react';\nimport * as React from 'react';\n\nimport { useTranslation } from '../i18n';\nimport {\n\tcanToggleList,\n\tisListActive,\n\tlistIcons,\n\ttype ListType\n} from './use-list';\nimport { useNotraEditor } from './use-notra-editor';\nimport { isNodeInSchema } from '../lib/utils';\n\nimport type { Dictionary } from '../i18n';\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport interface UseListDropdownMenuConfig {\n\t/**\n\t * The Tiptap editor instance.\n\t */\n\teditor?: Editor | null;\n\t/**\n\t * The list types to display in the dropdown.\n\t * @default [\"bulletList\", \"orderedList\", \"taskList\"]\n\t */\n\ttypes?: ListType[];\n\t/**\n\t * Whether the dropdown should be hidden when no list types are available\n\t * @default false\n\t */\n\thideWhenUnavailable?: boolean;\n}\n\nexport interface ListOption {\n\tlabel: string;\n\ttype: ListType;\n\ticon: React.ElementType;\n}\n\nconst listLabelKeys: Record<ListType, keyof Dictionary> = {\n\tbulletList: 'list.bullet',\n\torderedList: 'list.ordered',\n\ttaskList: 'list.task'\n};\n\nconst ALL_LIST_TYPES: ListType[] = [\n\t'bulletList',\n\t'orderedList',\n\t'taskList'\n] as const;\n\nexport function canToggleAnyList(\n\teditor: Editor | null,\n\tlistTypes: ListType[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn listTypes.some((type) => canToggleList(editor, type));\n}\n\nexport function isAnyListActive(\n\teditor: Editor | null,\n\tlistTypes: ListType[]\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn listTypes.some((type) => isListActive(editor, type));\n}\n\nexport function getFilteredListOptions(\n\toptions: ListOption[],\n\tavailableTypes: ListType[]\n): ListOption[] {\n\treturn options.filter((option) => availableTypes.includes(option.type));\n}\n\nexport function getActiveListType(\n\teditor: Editor | null,\n\tavailableTypes: ListType[]\n): ListType | undefined {\n\tif (!editor || !editor.isEditable) return undefined;\n\n\treturn availableTypes.find((type) => isListActive(editor, type));\n}\n\nexport function shouldShowListDropdown(params: {\n\teditor: Editor | null;\n\tlistTypes: ListType[];\n\thideWhenUnavailable: boolean;\n\tlistInSchema: boolean;\n\tcanToggleAny: boolean;\n}): boolean {\n\tconst { editor, hideWhenUnavailable, listInSchema, canToggleAny } = params;\n\n\tif (!listInSchema || !editor) {\n\t\treturn false;\n\t}\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleAny;\n\t}\n\n\treturn true;\n}\n\nexport function useListDropdownMenu(config?: UseListDropdownMenuConfig): {\n\tisVisible: boolean;\n\tactiveType: ListType | undefined;\n\tisActive: boolean;\n\tcanToggle: boolean;\n\ttypes: ListType[];\n\tfilteredLists: ListOption[];\n\tlabel: string;\n\tIcon: LucideIcon;\n} {\n\tconst {\n\t\teditor: providedEditor,\n\t\ttypes = ALL_LIST_TYPES,\n\t\thideWhenUnavailable = false\n\t} = config || {};\n\n\tconst { editor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = React.useState(false);\n\n\tconst listInSchema = types.some((type) => isNodeInSchema(type, editor));\n\n\tconst listOptions: ListOption[] = React.useMemo(\n\t\t() =>\n\t\t\tALL_LIST_TYPES.map((type) => ({\n\t\t\t\tlabel: dictionary[listLabelKeys[type]],\n\t\t\t\ttype,\n\t\t\t\ticon: listIcons[type]\n\t\t\t})),\n\t\t[dictionary]\n\t);\n\n\tconst filteredLists = React.useMemo(\n\t\t() => getFilteredListOptions(listOptions, types),\n\t\t[listOptions, types]\n\t);\n\n\tconst canToggleAny = canToggleAnyList(editor, types);\n\tconst isAnyActive = isAnyListActive(editor, types);\n\tconst activeType = getActiveListType(editor, types);\n\tconst activeList = filteredLists.find((option) => option.type === activeType);\n\n\tReact.useEffect(() => {\n\t\tif (!editor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowListDropdown({\n\t\t\t\t\teditor,\n\t\t\t\t\tlistTypes: types,\n\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\tlistInSchema,\n\t\t\t\t\tcanToggleAny\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\teditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\teditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [canToggleAny, editor, hideWhenUnavailable, listInSchema, types]);\n\n\treturn {\n\t\tisVisible,\n\t\tactiveType,\n\t\tisActive: isAnyActive,\n\t\tcanToggle: canToggleAny,\n\t\ttypes,\n\t\tfilteredLists,\n\t\tlabel: dictionary['list.dropdown.ariaLabel'],\n\t\tIcon: activeList ? listIcons[activeList.type] : List\n\t};\n}\n"
    },
    {
      "path": "hooks/use-list.ts",
      "content": "import { NodeSelection, TextSelection } from '@tiptap/pm/state';\nimport { List, ListOrdered, ListTodo } from 'lucide-react';\nimport * as React from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport {\n\tfindNodePosition,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type ListType = 'bulletList' | 'orderedList' | 'taskList';\n\nexport interface UseListConfig {\n\teditor?: Editor | null;\n\ttype: ListType;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const listIcons: Record<ListType, LucideIcon> = {\n\tbulletList: List,\n\torderedList: ListOrdered,\n\ttaskList: ListTodo\n};\n\nexport const LIST_SHORTCUT_KEYS: Record<ListType, string> = {\n\tbulletList: 'mod+shift+8',\n\torderedList: 'mod+shift+7',\n\ttaskList: 'mod+shift+9'\n};\n\n/**\n * Checks if a list can be toggled in the current editor state\n */\nexport function canToggleList(\n\teditor: Editor | null,\n\ttype: ListType,\n\tturnInto: boolean = true\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema(type, editor) || isNodeTypeSelected(editor, ['image']))\n\t\treturn false;\n\n\tif (!turnInto) {\n\t\tswitch (type) {\n\t\t\tcase 'bulletList':\n\t\t\t\treturn editor.can().toggleBulletList();\n\t\t\tcase 'orderedList':\n\t\t\t\treturn editor.can().toggleOrderedList();\n\t\t\tcase 'taskList':\n\t\t\t\treturn editor.can().toggleList('taskList', 'taskItem');\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tconst state = view.state;\n\t\tconst selection = state.selection;\n\n\t\tif (selection.empty || selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\t\t}\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Checks if list is currently active\n */\nexport function isListActive(editor: Editor | null, type: ListType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tswitch (type) {\n\t\tcase 'bulletList':\n\t\t\treturn editor.isActive('bulletList');\n\t\tcase 'orderedList':\n\t\t\treturn editor.isActive('orderedList');\n\t\tcase 'taskList':\n\t\t\treturn editor.isActive('taskList');\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Toggles list in the editor\n */\nexport function toggleList(editor: Editor | null, type: ListType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleList(editor, type)) return false;\n\n\ttry {\n\t\tconst view = editor.view;\n\t\tlet state = view.state;\n\t\tlet tr = state.tr;\n\n\t\tif (state.selection.empty || state.selection instanceof TextSelection) {\n\t\t\tconst pos = findNodePosition({\n\t\t\t\teditor,\n\t\t\t\tnode: state.selection.$anchor.node(1)\n\t\t\t})?.pos;\n\n\t\t\tif (!isValidPosition(pos)) return false;\n\n\t\t\ttr = tr.setSelection(NodeSelection.create(state.doc, pos));\n\t\t\tview.dispatch(tr);\n\t\t\tstate = view.state;\n\t\t}\n\n\t\tconst selection = state.selection;\n\n\t\tlet chain = editor.chain().focus();\n\n\t\tif (selection instanceof NodeSelection) {\n\t\t\tconst firstChild = selection.node.firstChild?.firstChild;\n\t\t\tconst lastChild = selection.node.lastChild?.lastChild;\n\n\t\t\tconst from = firstChild\n\t\t\t\t? selection.from + firstChild.nodeSize\n\t\t\t\t: selection.from + 1;\n\n\t\t\tconst to = lastChild\n\t\t\t\t? selection.to - lastChild.nodeSize\n\t\t\t\t: selection.to - 1;\n\n\t\t\tchain = chain.setTextSelection({ from, to }).clearNodes();\n\t\t}\n\n\t\tif (editor.isActive(type)) {\n\t\t\tchain\n\t\t\t\t.liftListItem('listItem')\n\t\t\t\t.lift('bulletList')\n\t\t\t\t.lift('orderedList')\n\t\t\t\t.lift('taskList')\n\t\t\t\t.run();\n\t\t} else {\n\t\t\tconst toggleMap: Record<ListType, () => typeof chain> = {\n\t\t\t\tbulletList: () => chain.toggleBulletList(),\n\t\t\t\torderedList: () => chain.toggleOrderedList(),\n\t\t\t\ttaskList: () => chain.toggleList('taskList', 'taskItem')\n\t\t\t};\n\n\t\t\tconst toggle = toggleMap[type];\n\n\t\t\tif (!toggle) return false;\n\n\t\t\ttoggle().run();\n\t\t}\n\n\t\teditor.chain().focus().selectTextblockEnd().run();\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Determines if the list button should be shown\n */\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\ttype: ListType;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, type, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isNodeInSchema(type, editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleList(editor, type);\n\t}\n\n\treturn true;\n}\n\nexport function useList(config: UseListConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\ttype,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = React.useState<boolean>(true);\n\tconst canToggle = canToggleList(activeEditor, type);\n\tconst isActive = isListActive(activeEditor, type);\n\n\tReact.useEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\ttype,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, type, hideWhenUnavailable]);\n\n\tconst handleToggle = React.useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleList(activeEditor, type);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, type, onToggled]);\n\n\tconst listLabelKeys: Record<ListType, keyof typeof dictionary> = {\n\t\tbulletList: 'list.bullet',\n\t\torderedList: 'list.ordered',\n\t\ttaskList: 'list.task'\n\t};\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleToggle,\n\t\tcanToggle,\n\t\tlabel: dictionary[listLabelKeys[type]],\n\t\tshortcutKeys: LIST_SHORTCUT_KEYS[type],\n\t\tIcon: listIcons[type]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-mark.ts",
      "content": "import { Bold, CodeXml, Italic, Strikethrough, Underline } from 'lucide-react';\nimport * as React from 'react';\n\nimport { useNotraEditor } from './use-notra-editor';\nimport { useTranslation } from '../i18n';\nimport { isMarkInSchema, isNodeTypeSelected } from '../lib/utils';\n\nimport type { Editor } from '@tiptap/core';\nimport type { LucideIcon } from 'lucide-react';\n\nexport type MarkType = 'bold' | 'italic' | 'underline' | 'strike' | 'code';\n\nexport interface UseMarkConfig {\n\teditor?: Editor | null;\n\ttype: MarkType;\n\thideWhenUnavailable?: boolean;\n\tonToggled?: () => void;\n}\n\nexport const markIcons: Record<MarkType, LucideIcon> = {\n\tbold: Bold,\n\titalic: Italic,\n\tunderline: Underline,\n\tstrike: Strikethrough,\n\tcode: CodeXml\n};\n\nexport const MARK_SHORTCUT_KEYS: Record<MarkType, string> = {\n\tbold: 'mod+b',\n\titalic: 'mod+i',\n\tunderline: 'mod+u',\n\tstrike: 'mod+shift+s',\n\tcode: 'mod+e'\n};\n\nexport function canToggleMark(editor: Editor | null, type: MarkType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isMarkInSchema(type, editor) || isNodeTypeSelected(editor, ['image']))\n\t\treturn false;\n\n\treturn editor.can().toggleMark(type);\n}\n\nexport function isMarkActive(editor: Editor | null, type: MarkType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn editor.isActive(type);\n}\n\nexport function toggleMark(editor: Editor | null, type: MarkType): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!canToggleMark(editor, type)) return false;\n\n\treturn editor.chain().focus().toggleMark(type).run();\n}\n\nexport function shouldShowButton(props: {\n\teditor: Editor | null;\n\ttype: MarkType;\n\thideWhenUnavailable: boolean;\n}): boolean {\n\tconst { editor, type, hideWhenUnavailable } = props;\n\n\tif (!editor || !editor.isEditable) return false;\n\n\tif (!isMarkInSchema(type, editor)) return false;\n\n\tif (hideWhenUnavailable && !editor.isActive('code')) {\n\t\treturn canToggleMark(editor, type);\n\t}\n\n\treturn true;\n}\n\nexport function useMark(config: UseMarkConfig) {\n\tconst {\n\t\teditor: providedEditor,\n\t\ttype,\n\t\thideWhenUnavailable = false,\n\t\tonToggled\n\t} = config;\n\n\tconst { editor: activeEditor } = useNotraEditor(providedEditor);\n\tconst dictionary = useTranslation();\n\tconst [isVisible, setIsVisible] = React.useState<boolean>(true);\n\tconst canToggle = canToggleMark(activeEditor, type);\n\tconst isActive = isMarkActive(activeEditor, type);\n\n\tReact.useEffect(() => {\n\t\tif (!activeEditor) return;\n\n\t\tconst handleSelectionUpdate = () => {\n\t\t\tsetIsVisible(\n\t\t\t\tshouldShowButton({\n\t\t\t\t\teditor: activeEditor,\n\t\t\t\t\ttype,\n\t\t\t\t\thideWhenUnavailable\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\n\t\thandleSelectionUpdate();\n\n\t\tactiveEditor.on('selectionUpdate', handleSelectionUpdate);\n\n\t\treturn () => {\n\t\t\tactiveEditor.off('selectionUpdate', handleSelectionUpdate);\n\t\t};\n\t}, [activeEditor, type, hideWhenUnavailable]);\n\n\tconst handleMark = React.useCallback(() => {\n\t\tif (!activeEditor) return false;\n\n\t\tconst success = toggleMark(activeEditor, type);\n\n\t\tif (success) {\n\t\t\tonToggled?.();\n\t\t}\n\n\t\treturn success;\n\t}, [activeEditor, type, onToggled]);\n\n\tconst markLabelKeys: Record<MarkType, string> = {\n\t\tbold: 'mark.bold',\n\t\titalic: 'mark.italic',\n\t\tunderline: 'mark.underline',\n\t\tstrike: 'mark.strike',\n\t\tcode: 'mark.code'\n\t};\n\n\treturn {\n\t\tisVisible,\n\t\tisActive,\n\t\thandleMark,\n\t\tcanToggle,\n\t\tlabel: dictionary[markLabelKeys[type] as keyof typeof dictionary],\n\t\tshortcutKeys: MARK_SHORTCUT_KEYS[type],\n\t\tIcon: markIcons[type]\n\t};\n}\n"
    },
    {
      "path": "hooks/use-notra-editor.ts",
      "content": "import { useCurrentEditor, useEditorState } from '@tiptap/react';\nimport * as React from 'react';\n\nimport type { Editor } from '@tiptap/core';\n\n/**\n * Hook that provides access to a Tiptap editor instance.\n *\n * Accepts an optional editor instance directly, or falls back to retrieving\n * the editor from the Tiptap context if available. This allows components\n * to work both when given an editor directly and when used within a Tiptap\n * editor context.\n *\n * @param providedEditor - Optional editor instance to use instead of the context editor\n * @returns The provided editor or the editor from context, whichever is available\n */\nexport function useNotraEditor(providedEditor?: Editor | null): {\n\teditor: Editor | null;\n} {\n\tconst { editor: contextEditor } = useCurrentEditor();\n\tconst editor = React.useMemo(\n\t\t() => providedEditor ?? contextEditor,\n\t\t[providedEditor, contextEditor]\n\t);\n\n\treturn (\n\t\tuseEditorState({\n\t\t\teditor,\n\t\t\tselector(context) {\n\t\t\t\treturn {\n\t\t\t\t\teditor: context.editor,\n\t\t\t\t\teditorState: context.editor?.state\n\t\t\t\t};\n\t\t\t}\n\t\t}) || { editor: null }\n\t);\n}\n"
    },
    {
      "path": "hooks/__tests__/use-blockquote.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggleBlockquote, toggleBlockquote } from '../use-blockquote';\n\n// ── Property 3: canToggleBlockquote and toggleBlockquote guard conditions ─\n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but blockquote node type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 3: canToggleBlockquote and toggleBlockquote guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 3.1, 3.2, 3.5, 3.6**\n\t */\n\ttest('canToggleBlockquote returns false when editor is null, not editable, or blockquote not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(canToggleGuardArbitrary, (editorState) => {\n\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\tconst result = canToggleBlockquote(editor as never);\n\n\t\t\t\texpect(result).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('when canToggleBlockquote returns false, toggleBlockquote also returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(canToggleGuardArbitrary, (editorState) => {\n\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\tconst canToggleResult = canToggleBlockquote(editor as never);\n\t\t\t\tconst toggleResult = toggleBlockquote(editor as never);\n\n\t\t\t\t// Guard states always make canToggleBlockquote return false\n\t\t\t\texpect(canToggleResult).toBe(false);\n\t\t\t\t// When canToggleBlockquote is false, toggleBlockquote must also be false\n\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-heading.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggle, toggleHeading } from '../use-heading';\nimport { getActiveHeadingLevel } from '../use-heading-dropdown-menu';\n\nimport type { Level } from '../use-heading';\n\n// ── Shared arbitraries ───────────────────────────────────────────────\n\nconst levelArbitrary: fc.Arbitrary<Level> = fc.constantFrom(\n\t1 as Level,\n\t2 as Level,\n\t3 as Level,\n\t4 as Level,\n\t5 as Level,\n\t6 as Level\n);\n\nconst levelsSubsetArbitrary: fc.Arbitrary<Level[]> = fc\n\t.subarray([1, 2, 3, 4, 5, 6] as Level[], { minLength: 0, maxLength: 6 })\n\t.map((arr) => [...arr].sort((a, b) => a - b));\n\n// ── Property 5: canToggle guard conditions ───────────────────────────\n\ntype CanToggleEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'no-heading-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleEditorState> =\n\tfc.constantFrom<CanToggleEditorState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'no-heading-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'heading' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// no-heading-in-schema: editable but heading not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 5: canToggle 守卫条件', () => {\n\t/**\n\t * **Validates: Requirements 6.4, 6.5**\n\t */\n\ttest('canToggle returns false when editor is null, not editable, or heading not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggle(editor as never, level);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 6: toggleHeading toggle behavior ────────────────────────\n\ntype ToggleEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'no-heading-in-schema' };\n\nconst toggleGuardArbitrary: fc.Arbitrary<ToggleEditorState> =\n\tfc.constantFrom<ToggleEditorState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'no-heading-in-schema' }\n\t);\n\nfunction buildToggleGuardEditor(state: ToggleEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: (name: string) => (name === 'heading' ? {} : undefined)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// no-heading-in-schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 6: toggleHeading 切换行为', () => {\n\t/**\n\t * **Validates: Requirements 6.2, 6.3**\n\t *\n\t * toggleHeading relies on editor.view, editor.chain(), NodeSelection, etc.\n\t * Full Tiptap chain API mocking is impractical, so we verify the guard\n\t * invariant: toggleHeading returns false for all invalid editor states.\n\t */\n\ttest('toggleHeading returns false when editor is null, not editable, or heading not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = toggleHeading(editor as never, level);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 6.2, 6.3**\n\t *\n\t * When canToggle returns false, toggleHeading must also return false.\n\t * This verifies the guard consistency between the two functions.\n\t */\n\ttest('toggleHeading returns false whenever canToggle returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlevelArbitrary,\n\t\t\t\t(editorState, level) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggle(editor as never, level);\n\t\t\t\t\tconst toggleResult = toggleHeading(editor as never, level);\n\n\t\t\t\t\tif (!canToggleResult) {\n\t\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 7: getActiveHeadingLevel icon selection ─────────────────\n\ntype ActiveHeadingEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeLevel: Level | undefined };\n\nconst activeHeadingEditorArbitrary: fc.Arbitrary<ActiveHeadingEditorState> =\n\tfc.oneof(\n\t\tfc.constant<ActiveHeadingEditorState>({ type: 'null' }),\n\t\tfc.constant<ActiveHeadingEditorState>({ type: 'not-editable' }),\n\t\tfc.record<ActiveHeadingEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveLevel: fc.option(levelArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildActiveHeadingEditor(state: ActiveHeadingEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string, attrs?: { level: Level }) => {\n\t\t\tif (name !== 'heading') return false;\n\n\t\t\tif (!attrs || state.activeLevel === undefined) return false;\n\n\t\t\treturn attrs.level === state.activeLevel;\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 7: getActiveHeadingLevel 图标选择', () => {\n\t/**\n\t * **Validates: Requirements 7.2, 7.3**\n\t */\n\ttest('returns the first level in the array that is active, or undefined if none', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tactiveHeadingEditorArbitrary,\n\t\t\t\tlevelsSubsetArbitrary,\n\t\t\t\t(editorState, levels) => {\n\t\t\t\t\tconst editor = buildActiveHeadingEditor(editorState);\n\t\t\t\t\tconst result = getActiveHeadingLevel(editor as never, levels);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBeUndefined();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, find the expected first matching level\n\t\t\t\t\tconst expected = levels.find((l) => l === editorState.activeLevel);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 7.2, 7.3**\n\t */\n\ttest('returns undefined when no heading level is active', () => {\n\t\tfc.assert(\n\t\t\tfc.property(levelsSubsetArbitrary, (levels) => {\n\t\t\t\t// Editor where no heading is active\n\t\t\t\tconst editor = {\n\t\t\t\t\tisEditable: true,\n\t\t\t\t\tisActive: () => false\n\t\t\t\t};\n\n\t\t\t\tconst result = getActiveHeadingLevel(editor as never, levels);\n\n\t\t\t\texpect(result).toBeUndefined();\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-list.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggleList, isListActive, toggleList } from '../use-list';\nimport {\n\tcanToggleAnyList,\n\tgetActiveListType,\n\tgetFilteredListOptions,\n\tisAnyListActive,\n\tshouldShowListDropdown\n} from '../use-list-dropdown-menu';\n\nimport type { ListType } from '../use-list';\nimport type { ListOption } from '../use-list-dropdown-menu';\n\n// ── Shared arbitraries ───────────────────────────────────────────────\n\nconst listTypeArbitrary: fc.Arbitrary<ListType> = fc.constantFrom(\n\t'bulletList' as ListType,\n\t'orderedList' as ListType,\n\t'taskList' as ListType\n);\n\n// ── Property 1: canToggleList guard conditions ───────────────────────\n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but list node type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: list-dropdown-menu, Property 1: canToggleList guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 1.1, 1.2**\n\t */\n\ttest('canToggleList returns false when editor is null, not editable, or list node type not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tlistTypeArbitrary,\n\t\t\t\t(editorState, listType) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggleList(editor as never, listType);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 2: isListActive guard and delegation ────────────────────\n\ntype IsListActiveEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeType: ListType | undefined };\n\nconst isListActiveEditorArbitrary: fc.Arbitrary<IsListActiveEditorState> =\n\tfc.oneof(\n\t\tfc.constant<IsListActiveEditorState>({ type: 'null' }),\n\t\tfc.constant<IsListActiveEditorState>({ type: 'not-editable' }),\n\t\tfc.record<IsListActiveEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveType: fc.option(listTypeArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildIsListActiveEditor(state: IsListActiveEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string) => {\n\t\t\tif (state.activeType === undefined) return false;\n\n\t\t\treturn name === state.activeType;\n\t\t}\n\t};\n}\n\ndescribe('Feature: list-dropdown-menu, Property 2: isListActive guard and delegation', () => {\n\t/**\n\t * **Validates: Requirements 1.4, 1.5**\n\t */\n\ttest('isListActive returns false when editor is null or not editable, and correctly delegates to editor.isActive when editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tisListActiveEditorArbitrary,\n\t\t\t\tlistTypeArbitrary,\n\t\t\t\t(editorState, listType) => {\n\t\t\t\t\tconst editor = buildIsListActiveEditor(editorState);\n\t\t\t\t\tconst result = isListActive(editor as never, listType);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBe(false);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, verify delegation to editor.isActive\n\t\t\t\t\tconst expected = editorState.activeType === listType;\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 3: toggleList and canToggleList consistency ─────────────\n\ntype ToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst toggleGuardArbitrary: fc.Arbitrary<ToggleGuardState> =\n\tfc.constantFrom<ToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildToggleGuardEditor(state: ToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but list node type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => undefined\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: list-dropdown-menu, Property 3: toggleList and canToggleList consistency', () => {\n\t/**\n\t * **Validates: Requirements 1.6, 1.7**\n\t */\n\ttest('when canToggleList returns false, toggleList also returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\ttoggleGuardArbitrary,\n\t\t\t\tlistTypeArbitrary,\n\t\t\t\t(editorState, listType) => {\n\t\t\t\t\tconst editor = buildToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggleList(editor as never, listType);\n\t\t\t\t\tconst toggleResult = toggleList(editor as never, listType);\n\n\t\t\t\t\t// Guard states always make canToggleList return false\n\t\t\t\t\texpect(canToggleResult).toBe(false);\n\t\t\t\t\t// When canToggleList is false, toggleList must also be false\n\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Shared arbitraries for Properties 4-8 ────────────────────────────\n\nconst ALL_LIST_TYPES: ListType[] = ['bulletList', 'orderedList', 'taskList'];\n\nconst listTypesSubsetArbitrary: fc.Arbitrary<ListType[]> = fc.subarray(\n\tALL_LIST_TYPES,\n\t{ minLength: 0, maxLength: 3 }\n);\n\ntype EditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeType: ListType | undefined };\n\nconst editorStateArbitrary: fc.Arbitrary<EditorState> = fc.oneof(\n\tfc.constant<EditorState>({ type: 'null' }),\n\tfc.constant<EditorState>({ type: 'not-editable' }),\n\tfc.record<EditorState & { type: 'editable' }>({\n\t\ttype: fc.constant('editable' as const),\n\t\tactiveType: fc.option(listTypeArbitrary, { nil: undefined })\n\t})\n);\n\nfunction buildMockEditor(state: EditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tnodes: {\n\t\t\t\t\t\tget: () => ({})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string) => {\n\t\t\tif (state.activeType === undefined) return false;\n\n\t\t\treturn name === state.activeType;\n\t\t},\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: () => ({})\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: true }\n\t\t}\n\t};\n}\n\n// ── Property 4: canToggleAnyList aggregation ─────────────────────────\n\ndescribe('Feature: list-dropdown-menu, Property 4: canToggleAnyList aggregation', () => {\n\t/**\n\t * **Validates: Requirements 2.1, 2.2**\n\t */\n\ttest('canToggleAnyList returns true iff at least one type canToggleList returns true', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorStateArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = canToggleAnyList(editor as never, listTypes);\n\t\t\t\t\tconst expected = listTypes.some((type) =>\n\t\t\t\t\t\tcanToggleList(editor as never, type)\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('canToggleAnyList returns false when editor is null or not editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constantFrom<EditorState>(\n\t\t\t\t\t{ type: 'null' },\n\t\t\t\t\t{ type: 'not-editable' }\n\t\t\t\t),\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = canToggleAnyList(editor as never, listTypes);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 5: isAnyListActive aggregation ──────────────────────────\n\ndescribe('Feature: list-dropdown-menu, Property 5: isAnyListActive aggregation', () => {\n\t/**\n\t * **Validates: Requirements 2.3, 2.4**\n\t */\n\ttest('isAnyListActive returns true iff at least one type isListActive returns true', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorStateArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = isAnyListActive(editor as never, listTypes);\n\t\t\t\t\tconst expected = listTypes.some((type) =>\n\t\t\t\t\t\tisListActive(editor as never, type)\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('isAnyListActive returns false when editor is null or not editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constantFrom<EditorState>(\n\t\t\t\t\t{ type: 'null' },\n\t\t\t\t\t{ type: 'not-editable' }\n\t\t\t\t),\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, listTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = isAnyListActive(editor as never, listTypes);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 6: getFilteredListOptions filtering ─────────────────────\n\nconst listOptionArbitrary: fc.Arbitrary<ListOption> = fc\n\t.record({\n\t\tlabel: fc.string({ minLength: 1, maxLength: 20 }),\n\t\ttype: listTypeArbitrary,\n\t\ticon: fc.constant(() => null)\n\t})\n\t.map((r) => r as unknown as ListOption);\n\nconst listOptionsArbitrary: fc.Arbitrary<ListOption[]> = fc.array(\n\tlistOptionArbitrary,\n\t{ minLength: 0, maxLength: 10 }\n);\n\ndescribe('Feature: list-dropdown-menu, Property 6: getFilteredListOptions filtering', () => {\n\t/**\n\t * **Validates: Requirements 2.5**\n\t */\n\ttest('returns only options whose type is in the subset, preserving original order', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlistOptionsArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(options, availableTypes) => {\n\t\t\t\t\tconst result = getFilteredListOptions(options, availableTypes);\n\n\t\t\t\t\t// Every returned option's type must be in availableTypes\n\t\t\t\t\tfor (const option of result) {\n\t\t\t\t\t\texpect(availableTypes).toContain(option.type);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Every option in the input whose type is in availableTypes must appear\n\t\t\t\t\tconst expectedOptions = options.filter((o) =>\n\t\t\t\t\t\tavailableTypes.includes(o.type)\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toHaveLength(expectedOptions.length);\n\n\t\t\t\t\t// Order must be preserved\n\t\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\t\texpect(result[i]).toBe(expectedOptions[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 7: getActiveListType selection ──────────────────────────\n\ndescribe('Feature: list-dropdown-menu, Property 7: getActiveListType selection', () => {\n\t/**\n\t * **Validates: Requirements 2.6, 2.7**\n\t */\n\ttest('returns the first active type in the array, or undefined if none match', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorStateArbitrary,\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\t(editorState, availableTypes) => {\n\t\t\t\t\tconst editor = buildMockEditor(editorState);\n\t\t\t\t\tconst result = getActiveListType(editor as never, availableTypes);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBeUndefined();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, find the expected first matching type\n\t\t\t\t\tconst expected = availableTypes.find(\n\t\t\t\t\t\t(type) => type === editorState.activeType\n\t\t\t\t\t);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('returns undefined when no list type is active', () => {\n\t\tfc.assert(\n\t\t\tfc.property(listTypesSubsetArbitrary, (availableTypes) => {\n\t\t\t\tconst editor = {\n\t\t\t\t\tisEditable: true,\n\t\t\t\t\tisActive: () => false\n\t\t\t\t};\n\n\t\t\t\tconst result = getActiveListType(editor as never, availableTypes);\n\n\t\t\t\texpect(result).toBeUndefined();\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 8: shouldShowListDropdown guard ─────────────────────────\n\ndescribe('Feature: list-dropdown-menu, Property 8: shouldShowListDropdown guard', () => {\n\t/**\n\t * **Validates: Requirements 2.8**\n\t */\n\ttest('returns false when listInSchema is false or editor is null', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\tfc.boolean(),\n\t\t\t\tfc.boolean(),\n\t\t\t\t(listTypes, hideWhenUnavailable, canToggleAny) => {\n\t\t\t\t\t// Case 1: listInSchema is false (editor can be anything)\n\t\t\t\t\tconst editorObj = buildMockEditor({\n\t\t\t\t\t\ttype: 'editable',\n\t\t\t\t\t\tactiveType: undefined\n\t\t\t\t\t});\n\n\t\t\t\t\tconst resultNoSchema = shouldShowListDropdown({\n\t\t\t\t\t\teditor: editorObj as never,\n\t\t\t\t\t\tlistTypes,\n\t\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\t\tlistInSchema: false,\n\t\t\t\t\t\tcanToggleAny\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(resultNoSchema).toBe(false);\n\n\t\t\t\t\t// Case 2: editor is null (listInSchema can be anything)\n\t\t\t\t\tconst resultNullEditor = shouldShowListDropdown({\n\t\t\t\t\t\teditor: null,\n\t\t\t\t\t\tlistTypes,\n\t\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\t\tlistInSchema: true,\n\t\t\t\t\t\tcanToggleAny\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(resultNullEditor).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('returns false when both listInSchema is false and editor is null', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlistTypesSubsetArbitrary,\n\t\t\t\tfc.boolean(),\n\t\t\t\tfc.boolean(),\n\t\t\t\t(listTypes, hideWhenUnavailable, canToggleAny) => {\n\t\t\t\t\tconst result = shouldShowListDropdown({\n\t\t\t\t\t\teditor: null,\n\t\t\t\t\t\tlistTypes,\n\t\t\t\t\t\thideWhenUnavailable,\n\t\t\t\t\t\tlistInSchema: false,\n\t\t\t\t\t\tcanToggleAny\n\t\t\t\t\t});\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "hooks/__tests__/use-mark.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport { canToggleMark, isMarkActive, toggleMark } from '../use-mark';\n\nimport type { MarkType } from '../use-mark';\n\n// ── Shared arbitraries ───────────────────────────────────────────────\n\nconst markTypeArbitrary: fc.Arbitrary<MarkType> = fc.constantFrom(\n\t'bold' as MarkType,\n\t'italic' as MarkType,\n\t'underline' as MarkType,\n\t'strike' as MarkType,\n\t'code' as MarkType\n);\n\n// ── Property 1: canToggleMark and toggleMark guard conditions ────────\n\ntype CanToggleGuardState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'not-in-schema' };\n\nconst canToggleGuardArbitrary: fc.Arbitrary<CanToggleGuardState> =\n\tfc.constantFrom<CanToggleGuardState>(\n\t\t{ type: 'null' },\n\t\t{ type: 'not-editable' },\n\t\t{ type: 'not-in-schema' }\n\t);\n\nfunction buildCanToggleGuardEditor(state: CanToggleGuardState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tschema: {\n\t\t\t\tspec: {\n\t\t\t\t\tmarks: { get: () => ({}) },\n\t\t\t\t\tnodes: { get: () => ({}) }\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// not-in-schema: editable but mark type not in schema\n\treturn {\n\t\tisEditable: true,\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tmarks: { get: () => undefined },\n\t\t\t\tnodes: { get: () => ({}) }\n\t\t\t}\n\t\t},\n\t\tstate: {\n\t\t\tselection: { empty: false }\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 1: canToggleMark and toggleMark guard conditions', () => {\n\t/**\n\t * **Validates: Requirements 1.1, 1.2, 1.7, 1.8**\n\t */\n\ttest('canToggleMark returns false when editor is null, not editable, or mark type not in schema', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tmarkTypeArbitrary,\n\t\t\t\t(editorState, markType) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst result = canToggleMark(editor as never, markType);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\ttest('when canToggleMark returns false, toggleMark also returns false', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tcanToggleGuardArbitrary,\n\t\t\t\tmarkTypeArbitrary,\n\t\t\t\t(editorState, markType) => {\n\t\t\t\t\tconst editor = buildCanToggleGuardEditor(editorState);\n\t\t\t\t\tconst canToggleResult = canToggleMark(editor as never, markType);\n\t\t\t\t\tconst toggleResult = toggleMark(editor as never, markType);\n\n\t\t\t\t\t// Guard states always make canToggleMark return false\n\t\t\t\t\texpect(canToggleResult).toBe(false);\n\t\t\t\t\t// When canToggleMark is false, toggleMark must also be false\n\t\t\t\t\texpect(toggleResult).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 2: isMarkActive guard and delegation ────────────────────\n\ntype IsMarkActiveEditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; activeType: MarkType | undefined };\n\nconst isMarkActiveEditorArbitrary: fc.Arbitrary<IsMarkActiveEditorState> =\n\tfc.oneof(\n\t\tfc.constant<IsMarkActiveEditorState>({ type: 'null' }),\n\t\tfc.constant<IsMarkActiveEditorState>({ type: 'not-editable' }),\n\t\tfc.record<IsMarkActiveEditorState & { type: 'editable' }>({\n\t\t\ttype: fc.constant('editable' as const),\n\t\t\tactiveType: fc.option(markTypeArbitrary, { nil: undefined })\n\t\t})\n\t);\n\nfunction buildIsMarkActiveEditor(state: IsMarkActiveEditorState) {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tisActive: () => false\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tisActive: (name: string) => {\n\t\t\tif (state.activeType === undefined) return false;\n\n\t\t\treturn name === state.activeType;\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 2: isMarkActive guard and delegation', () => {\n\t/**\n\t * **Validates: Requirements 1.5, 1.6**\n\t */\n\ttest('isMarkActive returns false when editor is null or not editable, and correctly delegates to editor.isActive when editable', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tisMarkActiveEditorArbitrary,\n\t\t\t\tmarkTypeArbitrary,\n\t\t\t\t(editorState, markType) => {\n\t\t\t\t\tconst editor = buildIsMarkActiveEditor(editorState);\n\t\t\t\t\tconst result = isMarkActive(editor as never, markType);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\teditorState.type === 'null' ||\n\t\t\t\t\t\teditorState.type === 'not-editable'\n\t\t\t\t\t) {\n\t\t\t\t\t\texpect(result).toBe(false);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For editable editors, verify delegation to editor.isActive\n\t\t\t\t\tconst expected = editorState.activeType === markType;\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "i18n/context.tsx",
      "content": "import { createContext, useContext, useMemo } from 'react';\n\nimport { en } from './messages/en';\nimport { ja } from './messages/ja';\nimport { zh } from './messages/zh';\n\nimport type { Dictionary, Locale } from './types';\n\ninterface I18nProviderProps {\n\tlocale?: Locale;\n\tmessages?: Partial<Dictionary>;\n\tchildren: React.ReactNode;\n}\n\nconst builtinDictionaries: Record<Locale, Dictionary> = { en, zh, ja };\n\nconst I18nContext = createContext<Dictionary>(en);\n\nexport function getDictionary(\n\tlocale: string,\n\tmessages?: Partial<Dictionary>\n): Dictionary {\n\t// Avoid prototype keys like \"toString\" matching via `in` operator\n\tconst base = Object.prototype.hasOwnProperty.call(builtinDictionaries, locale)\n\t\t? builtinDictionaries[locale as Locale]\n\t\t: builtinDictionaries.en;\n\n\tif (messages) {\n\t\treturn { ...base, ...messages } as Dictionary;\n\t}\n\n\treturn base;\n}\n\nexport function I18nProvider({\n\tlocale = 'en',\n\tmessages,\n\tchildren\n}: I18nProviderProps) {\n\tconst dictionary = useMemo(\n\t\t() => getDictionary(locale, messages),\n\t\t[locale, messages]\n\t);\n\n\treturn (\n\t\t<I18nContext.Provider value={dictionary}>{children}</I18nContext.Provider>\n\t);\n}\n\nexport function useTranslation(): Dictionary {\n\treturn useContext(I18nContext);\n}\n"
    },
    {
      "path": "i18n/index.ts",
      "content": "export type { Dictionary, Locale } from './types';\nexport { I18nProvider, useTranslation, getDictionary } from './context';\nexport { en } from './messages/en';\nexport { zh } from './messages/zh';\nexport { ja } from './messages/ja';\n"
    },
    {
      "path": "i18n/messages/en.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const en = {\n\t'heading.1': 'Heading 1',\n\t'heading.2': 'Heading 2',\n\t'heading.3': 'Heading 3',\n\t'heading.4': 'Heading 4',\n\t'heading.5': 'Heading 5',\n\t'heading.6': 'Heading 6',\n\t'heading.dropdown.ariaLabel': 'Format text as heading',\n\t'list.bullet': 'Bullet List',\n\t'list.ordered': 'Ordered List',\n\t'list.task': 'Task List',\n\t'list.dropdown.ariaLabel': 'Format text as list',\n\t'mark.bold': 'Bold',\n\t'mark.italic': 'Italic',\n\t'mark.underline': 'Underline',\n\t'mark.strike': 'Strikethrough',\n\t'mark.code': 'Code',\n\t'blockquote.label': 'Blockquote',\n\t'editor.ariaLabel': 'Main content area, start typing to enter text.'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/ja.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const ja = {\n\t'heading.1': '見出し 1',\n\t'heading.2': '見出し 2',\n\t'heading.3': '見出し 3',\n\t'heading.4': '見出し 4',\n\t'heading.5': '見出し 5',\n\t'heading.6': '見出し 6',\n\t'heading.dropdown.ariaLabel': 'テキストを見出しとして書式設定',\n\t'list.bullet': '箇条書き',\n\t'list.ordered': '番号付きリスト',\n\t'list.task': 'タスクリスト',\n\t'list.dropdown.ariaLabel': 'テキストをリストとして書式設定',\n\t'mark.bold': '太字',\n\t'mark.italic': '斜体',\n\t'mark.underline': '下線',\n\t'mark.strike': '取り消し線',\n\t'mark.code': 'コード',\n\t'blockquote.label': '引用',\n\t'editor.ariaLabel': 'メインコンテンツエリア、テキストを入力してください。'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/messages/zh.ts",
      "content": "import type { Dictionary } from '../types';\n\nexport const zh = {\n\t'heading.1': '一级标题',\n\t'heading.2': '二级标题',\n\t'heading.3': '三级标题',\n\t'heading.4': '四级标题',\n\t'heading.5': '五级标题',\n\t'heading.6': '六级标题',\n\t'heading.dropdown.ariaLabel': '将文本格式化为标题',\n\t'list.bullet': '无序列表',\n\t'list.ordered': '有序列表',\n\t'list.task': '任务列表',\n\t'list.dropdown.ariaLabel': '将文本格式化为列表',\n\t'mark.bold': '加粗',\n\t'mark.italic': '斜体',\n\t'mark.underline': '下划线',\n\t'mark.strike': '删除线',\n\t'mark.code': '代码',\n\t'blockquote.label': '引用',\n\t'editor.ariaLabel': '主要内容区域，开始输入文本。'\n} satisfies Dictionary;\n"
    },
    {
      "path": "i18n/types.ts",
      "content": "export interface Dictionary {\n\t'heading.1': string;\n\t'heading.2': string;\n\t'heading.3': string;\n\t'heading.4': string;\n\t'heading.5': string;\n\t'heading.6': string;\n\t'heading.dropdown.ariaLabel': string;\n\t'list.bullet': string;\n\t'list.ordered': string;\n\t'list.task': string;\n\t'list.dropdown.ariaLabel': string;\n\t'mark.bold': string;\n\t'mark.italic': string;\n\t'mark.underline': string;\n\t'mark.strike': string;\n\t'mark.code': string;\n\t'blockquote.label': string;\n\t'editor.ariaLabel': string;\n}\n\nexport type Locale = 'en' | 'zh' | 'ja';\n"
    },
    {
      "path": "i18n/__tests__/i18n.test.ts",
      "content": "import fc from 'fast-check';\nimport { describe, expect, it } from 'vitest';\n\nimport { getDictionary } from '../context';\nimport { en } from '../messages/en';\nimport { ja } from '../messages/ja';\nimport { zh } from '../messages/zh';\n\nimport type { Dictionary, Locale } from '../types';\n\n/**\n * **Feature: editor-i18n, Property 1: 内置字典完整性**\n * **Validates: Requirements 1.2, 1.3, 1.4**\n */\n\nconst expectedKeys: (keyof Dictionary)[] = [\n\t'heading.1',\n\t'heading.2',\n\t'heading.3',\n\t'heading.4',\n\t'heading.5',\n\t'heading.6',\n\t'heading.dropdown.ariaLabel',\n\t'editor.ariaLabel'\n];\n\nconst builtinDictionaries: Record<string, Dictionary> = { en, zh, ja };\n\ndescribe('Property 1: 内置字典完整性', () => {\n\tit.each(Object.entries(builtinDictionaries))(\n\t\t'%s dictionary contains all required keys',\n\t\t(_locale, dict) => {\n\t\t\tconst keys = Object.keys(dict);\n\n\t\t\tfor (const key of expectedKeys) {\n\t\t\t\texpect(keys).toContain(key);\n\t\t\t}\n\t\t}\n\t);\n\n\tit.each(Object.entries(builtinDictionaries))(\n\t\t'%s dictionary has only non-empty string values',\n\t\t(_locale, dict) => {\n\t\t\tfor (const key of expectedKeys) {\n\t\t\t\tconst value = dict[key];\n\n\t\t\t\texpect(typeof value).toBe('string');\n\t\t\t\texpect(value.length).toBeGreaterThan(0);\n\t\t\t}\n\t\t}\n\t);\n});\n\n/**\n * **Feature: editor-i18n, Property 2: Locale 解析正确性**\n * **Validates: Requirements 2.2**\n */\n\nconst localeArbitrary: fc.Arbitrary<Locale> = fc.constantFrom('en', 'zh', 'ja');\n\nconst localeDictionaryMap: Record<Locale, Dictionary> = { en, zh, ja };\n\ndescribe('Property 2: Locale 解析正确性', () => {\n\tit('getDictionary(locale) returns the exact built-in dictionary for that locale', () => {\n\t\tfc.assert(\n\t\t\tfc.property(localeArbitrary, (locale) => {\n\t\t\t\tconst result = getDictionary(locale);\n\t\t\t\tconst expected = localeDictionaryMap[locale];\n\n\t\t\t\texpect(result).toEqual(expected);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: editor-i18n, Property 3: 不支持的 Locale 回退**\n * **Validates: Requirements 2.4**\n */\n\nconst invalidLocaleArbitrary: fc.Arbitrary<string> = fc\n\t.string()\n\t.filter((s) => s !== 'en' && s !== 'zh' && s !== 'ja');\n\ndescribe('Property 3: 不支持的 Locale 回退', () => {\n\tit('getDictionary returns the English dictionary for any unsupported locale', () => {\n\t\tfc.assert(\n\t\t\tfc.property(invalidLocaleArbitrary, (locale) => {\n\t\t\t\tconst result = getDictionary(locale);\n\n\t\t\t\texpect(result).toEqual(en);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: editor-i18n, Property 4: 自定义消息合并**\n * **Validates: Requirements 3.1, 3.2**\n */\n\nconst dictionaryKeys: (keyof Dictionary)[] = [\n\t'heading.1',\n\t'heading.2',\n\t'heading.3',\n\t'heading.4',\n\t'heading.5',\n\t'heading.6',\n\t'heading.dropdown.ariaLabel',\n\t'editor.ariaLabel'\n];\n\nconst partialDictionaryArbitrary: fc.Arbitrary<Partial<Dictionary>> = fc\n\t.record(\n\t\tObject.fromEntries(\n\t\t\tdictionaryKeys.map((key) => [\n\t\t\t\tkey,\n\t\t\t\tfc.option(fc.string({ minLength: 1 }), { nil: undefined })\n\t\t\t])\n\t\t) as Record<keyof Dictionary, fc.Arbitrary<string | undefined>>\n\t)\n\t.map((rec) => {\n\t\tconst partial: Partial<Dictionary> = {};\n\n\t\tfor (const key of dictionaryKeys) {\n\t\t\tif (rec[key] !== undefined) {\n\t\t\t\tpartial[key] = rec[key];\n\t\t\t}\n\t\t}\n\n\t\treturn partial;\n\t});\n\ndescribe('Property 4: 自定义消息合并', () => {\n\tit('overridden keys use custom values, non-overridden keys use built-in values', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tlocaleArbitrary,\n\t\t\t\tpartialDictionaryArbitrary,\n\t\t\t\t(locale, override) => {\n\t\t\t\t\tconst result = getDictionary(locale, override);\n\t\t\t\t\tconst base = localeDictionaryMap[locale];\n\n\t\t\t\t\tfor (const key of dictionaryKeys) {\n\t\t\t\t\t\tif (key in override) {\n\t\t\t\t\t\t\texpect(result[key]).toBe(override[key]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texpect(result[key]).toBe(base[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n/**\n * **Feature: editor-i18n, Property 5: Dictionary JSON 往返一致性**\n * **Validates: Requirements 5.1**\n */\n\nconst dictionaryArbitrary: fc.Arbitrary<Dictionary> = fc.record(\n\tObject.fromEntries(\n\t\tdictionaryKeys.map((key) => [key, fc.string({ minLength: 1 })])\n\t) as Record<keyof Dictionary, fc.Arbitrary<string>>\n);\n\ndescribe('Property 5: Dictionary JSON 往返一致性', () => {\n\tit('JSON.parse(JSON.stringify(dict)) produces a deeply equal result', () => {\n\t\tfc.assert(\n\t\t\tfc.property(dictionaryArbitrary, (dict) => {\n\t\t\t\tconst roundTripped = JSON.parse(JSON.stringify(dict));\n\n\t\t\t\texpect(roundTripped).toEqual(dict);\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "lib/utils.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nimport type { Editor } from '@tiptap/core';\nimport type { Node as TiptapNode } from '@tiptap/pm/model';\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n\nexport function isNodeInSchema(\n\tnodeName: string,\n\teditor: Editor | null\n): boolean {\n\tif (!editor?.schema) return false;\n\n\treturn editor.schema.spec.nodes.get(nodeName) !== undefined;\n}\n\nexport function isMarkInSchema(\n\tmarkName: string,\n\teditor: Editor | null\n): boolean {\n\tif (!editor?.schema) return false;\n\n\treturn editor.schema.spec.marks.get(markName) !== undefined;\n}\n\nexport function isNodeTypeSelected(\n\teditor: Editor | null,\n\ttypes: string[] = []\n): boolean {\n\tif (!editor || !editor.state.selection) return false;\n\n\tconst { state } = editor;\n\tconst { selection } = state;\n\n\tif (selection.empty) return false;\n\n\tif (selection instanceof NodeSelection) {\n\t\tconst node = selection.node;\n\n\t\treturn node ? types.includes(node.type.name) : false;\n\t}\n\n\treturn false;\n}\n\nexport function isValidPosition(pos: number | null | undefined): pos is number {\n\treturn typeof pos === 'number' && pos >= 0;\n}\n\nfunction findNodeAtPosition(editor: Editor, position: number) {\n\ttry {\n\t\tconst node = editor.state.doc.nodeAt(position);\n\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn node;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function findNodePosition(props: {\n\teditor: Editor | null;\n\tnode?: TiptapNode | null;\n\tnodePos?: number | null;\n}): { pos: number; node: TiptapNode } | null {\n\tconst { editor, node, nodePos } = props;\n\n\tif (!editor || !editor.state?.doc) return null;\n\n\tconst hasValidNode = node !== undefined && node !== null;\n\tconst hasValidPos = isValidPosition(nodePos);\n\n\tif (!hasValidNode && !hasValidPos) {\n\t\treturn null;\n\t}\n\n\tif (hasValidNode) {\n\t\tlet foundPos = -1;\n\t\tlet foundNode: TiptapNode | null = null;\n\n\t\teditor.state.doc.descendants((currentNode, pos) => {\n\t\t\tif (currentNode === node) {\n\t\t\t\tfoundPos = pos;\n\t\t\t\tfoundNode = currentNode;\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (foundPos !== -1 && foundNode !== null) {\n\t\t\treturn { pos: foundPos, node: foundNode };\n\t\t}\n\t}\n\n\tif (hasValidPos) {\n\t\tconst nodeAtPos = findNodeAtPosition(editor, nodePos!);\n\n\t\tif (nodeAtPos) {\n\t\t\treturn { pos: nodePos!, node: nodeAtPos };\n\t\t}\n\t}\n\n\treturn null;\n}\n"
    },
    {
      "path": "lib/__tests__/utils.test.ts",
      "content": "import { NodeSelection } from '@tiptap/pm/state';\nimport * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport {\n\tisMarkInSchema,\n\tisNodeInSchema,\n\tisNodeTypeSelected,\n\tisValidPosition\n} from '../utils';\n\n// ── Property 2: isValidPosition ──────────────────────────────────────\n\ndescribe('Feature: toolbar-components, Property 2: isValidPosition 正确性', () => {\n\t/**\n\t * **Validates: Requirements 5.4**\n\t */\n\ttest('returns true if and only if value is a number >= 0', () => {\n\t\tconst valueArbitrary: fc.Arbitrary<number | null | undefined> = fc.oneof(\n\t\t\tfc.integer(),\n\t\t\tfc.double({ noNaN: false }),\n\t\t\tfc.constant(null),\n\t\t\tfc.constant(undefined)\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(valueArbitrary, (v) => {\n\t\t\t\tconst result = isValidPosition(v);\n\t\t\t\tconst expected = typeof v === 'number' && v >= 0;\n\n\t\t\t\texpect(result).toBe(expected);\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 3: isNodeInSchema ───────────────────────────────────────\n\n// Minimal mock for the Editor.schema.spec.nodes interface\ninterface MockEditor {\n\tschema: {\n\t\tspec: {\n\t\t\tnodes: { get: (name: string) => unknown };\n\t\t};\n\t};\n}\n\ntype EditorInput = { type: 'null' } | { type: 'present'; nodeNames: string[] };\n\nconst editorInputArbitrary: fc.Arbitrary<EditorInput> = fc.oneof(\n\tfc.constant<EditorInput>({ type: 'null' }),\n\tfc.record<EditorInput & { type: 'present' }>({\n\t\ttype: fc.constant('present' as const),\n\t\tnodeNames: fc.array(fc.string({ minLength: 1, maxLength: 20 }), {\n\t\t\tminLength: 0,\n\t\t\tmaxLength: 10\n\t\t})\n\t})\n);\n\nfunction buildMockEditorForSchema(input: EditorInput): MockEditor | null {\n\tif (input.type === 'null') return null;\n\n\tconst nodeSet = new Set(input.nodeNames);\n\n\treturn {\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tnodes: {\n\t\t\t\t\tget: (name: string) => (nodeSet.has(name) ? {} : undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 3: isNodeInSchema 正确性', () => {\n\t/**\n\t * **Validates: Requirements 5.1**\n\t */\n\ttest('returns true iff editor is non-null and schema.spec.nodes contains the name', () => {\n\t\tconst nodeNameArbitrary = fc.string({ minLength: 1, maxLength: 20 });\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\teditorInputArbitrary,\n\t\t\t\tnodeNameArbitrary,\n\t\t\t\t(editorInput, nodeName) => {\n\t\t\t\t\tconst editor = buildMockEditorForSchema(editorInput);\n\t\t\t\t\tconst result = isNodeInSchema(nodeName, editor as never);\n\n\t\t\t\t\tif (editorInput.type === 'null') {\n\t\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst expected = editorInput.nodeNames.includes(nodeName);\n\n\t\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 4: isNodeTypeSelected ───────────────────────────────────\n\ntype SelectionKind =\n\t| { kind: 'null-editor' }\n\t| { kind: 'empty' }\n\t| { kind: 'text' }\n\t| { kind: 'node'; nodeTypeName: string };\n\nconst selectionKindArbitrary: fc.Arbitrary<SelectionKind> = fc.oneof(\n\tfc.constant<SelectionKind>({ kind: 'null-editor' }),\n\tfc.constant<SelectionKind>({ kind: 'empty' }),\n\tfc.constant<SelectionKind>({ kind: 'text' }),\n\tfc.record<SelectionKind & { kind: 'node' }>({\n\t\tkind: fc.constant('node' as const),\n\t\tnodeTypeName: fc.string({ minLength: 1, maxLength: 20 })\n\t})\n);\n\nfunction buildMockEditorForSelection(sel: SelectionKind) {\n\tif (sel.kind === 'null-editor') return null;\n\n\tif (sel.kind === 'empty') {\n\t\treturn {\n\t\t\tstate: {\n\t\t\t\tselection: { empty: true }\n\t\t\t}\n\t\t};\n\t}\n\n\tif (sel.kind === 'text') {\n\t\t// Non-empty, non-NodeSelection\n\t\treturn {\n\t\t\tstate: {\n\t\t\t\tselection: { empty: false }\n\t\t\t}\n\t\t};\n\t}\n\n\t// NodeSelection — create an object that passes `instanceof NodeSelection`\n\tconst nodeSelection = Object.create(NodeSelection.prototype, {\n\t\tempty: { value: false, writable: false },\n\t\tnode: {\n\t\t\tvalue: { type: { name: sel.nodeTypeName } },\n\t\t\twritable: false\n\t\t}\n\t});\n\n\treturn {\n\t\tstate: { selection: nodeSelection }\n\t};\n}\n\ndescribe('Feature: toolbar-components, Property 4: isNodeTypeSelected 正确性', () => {\n\t/**\n\t * **Validates: Requirements 5.2**\n\t */\n\ttest('returns true iff selection is a NodeSelection and node type name is in the types array', () => {\n\t\tconst typesArbitrary = fc.array(\n\t\t\tfc.string({ minLength: 1, maxLength: 20 }),\n\t\t\t{ minLength: 0, maxLength: 10 }\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(selectionKindArbitrary, typesArbitrary, (sel, types) => {\n\t\t\t\tconst editor = buildMockEditorForSelection(sel);\n\t\t\t\tconst result = isNodeTypeSelected(editor as never, types);\n\n\t\t\t\tif (sel.kind === 'null-editor') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else if (sel.kind === 'empty' || sel.kind === 'text') {\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t} else {\n\t\t\t\t\t// NodeSelection case\n\t\t\t\t\tconst expected = types.includes(sel.nodeTypeName);\n\n\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n\n// ── Property 4 (toolbar-formatting-buttons): isMarkInSchema ──────────\n\ntype MarkEditorInput =\n\t| { type: 'null' }\n\t| { type: 'no-schema' }\n\t| { type: 'present'; markNames: string[] };\n\nconst markEditorInputArbitrary: fc.Arbitrary<MarkEditorInput> = fc.oneof(\n\tfc.constant<MarkEditorInput>({ type: 'null' }),\n\tfc.constant<MarkEditorInput>({ type: 'no-schema' }),\n\tfc.record<MarkEditorInput & { type: 'present' }>({\n\t\ttype: fc.constant('present' as const),\n\t\tmarkNames: fc.array(fc.string({ minLength: 1, maxLength: 20 }), {\n\t\t\tminLength: 0,\n\t\t\tmaxLength: 10\n\t\t})\n\t})\n);\n\nfunction buildMockEditorForMarkSchema(\n\tinput: MarkEditorInput\n): Record<string, unknown> | null {\n\tif (input.type === 'null') return null;\n\n\tif (input.type === 'no-schema') return {};\n\n\tconst markSet = new Set(input.markNames);\n\n\treturn {\n\t\tschema: {\n\t\t\tspec: {\n\t\t\t\tmarks: {\n\t\t\t\t\tget: (name: string) => (markSet.has(name) ? {} : undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\ndescribe('Feature: toolbar-formatting-buttons, Property 4: isMarkInSchema correctness', () => {\n\t/**\n\t * **Validates: Requirements 8.1, 8.2, 8.3**\n\t */\n\ttest('returns false when editor is null or schema does not exist', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constantFrom<MarkEditorInput>(\n\t\t\t\t\t{ type: 'null' },\n\t\t\t\t\t{ type: 'no-schema' }\n\t\t\t\t),\n\t\t\t\tfc.string({ minLength: 1, maxLength: 20 }),\n\t\t\t\t(editorInput, markName) => {\n\t\t\t\t\tconst editor = buildMockEditorForMarkSchema(editorInput);\n\t\t\t\t\tconst result = isMarkInSchema(markName, editor as never);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 8.2, 8.3**\n\t */\n\ttest('returns true iff editor is non-null with schema and marks spec contains the name', () => {\n\t\tconst markNameArbitrary = fc.string({ minLength: 1, maxLength: 20 });\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tmarkEditorInputArbitrary,\n\t\t\t\tmarkNameArbitrary,\n\t\t\t\t(editorInput, markName) => {\n\t\t\t\t\tconst editor = buildMockEditorForMarkSchema(editorInput);\n\t\t\t\t\tconst result = isMarkInSchema(markName, editor as never);\n\n\t\t\t\t\tif (editorInput.type === 'null' || editorInput.type === 'no-schema') {\n\t\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst expected = editorInput.markNames.includes(markName);\n\n\t\t\t\t\t\texpect(result).toBe(expected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "styles/base.css",
      "content": ".notra-editor {\n\twhite-space: pre-wrap;\n\toutline: none;\n\tcolor: var(--notra-text);\n}\n\n.notra-editor > * {\n\tposition: relative;\n}\n"
    },
    {
      "path": "styles/blockquote.css",
      "content": ".notra-editor {\n\tblockquote {\n\t\tposition: relative;\n\t\tpadding-left: 1em;\n\t\tpadding-top: 0.375em;\n\t\tpadding-bottom: 0.375em;\n\t\tmargin: 1.5rem 0;\n\n\t\tp {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t/* Decorative left bar via pseudo-element */\n\t\t&::before {\n\t\t\tposition: absolute;\n\t\t\tbottom: 0;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\theight: 100%;\n\t\t\twidth: 0.25em;\n\t\t\tbackground-color: var(--notra-blockquote-bar);\n\t\t\tcontent: '';\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/code.css",
      "content": ".notra-editor {\n\tcode {\n\t\tbackground-color: var(--notra-code-bg);\n\t\tcolor: var(--notra-code-text);\n\t\tborder: 1px solid var(--notra-code-border);\n\t\tfont-family:\n\t\t\tui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;\n\t\tfont-size: 0.875em;\n\t\tline-height: 1.4;\n\t\tborder-radius: 0.375rem;\n\t\tpadding: 0.1em 0.2em;\n\t}\n\n\tpre {\n\t\tbackground-color: var(--notra-codeblock-bg);\n\t\tcolor: var(--notra-codeblock-text);\n\t\tborder: 1px solid var(--notra-codeblock-border);\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 1.5em;\n\t\tpadding: 1em;\n\t\tfont-size: 1rem;\n\t\tborder-radius: 0.375rem;\n\t\toverflow-x: auto;\n\n\t\tcode {\n\t\t\tbackground-color: transparent;\n\t\t\tborder: none;\n\t\t\tborder-radius: 0;\n\t\t\tcolor: inherit;\n\t\t\tpadding: 0;\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/editor.css",
      "content": "@import './variables.css';\n@import './base.css';\n@import './heading.css';\n@import './text.css';\n@import './list.css';\n@import './code.css';\n@import './blockquote.css';\n@import './horizontal-rule.css';\n@import './image.css';\n"
    },
    {
      "path": "styles/heading.css",
      "content": "/* Vertical rhythm values from Tailwind Typography */\n.notra-editor {\n\th1,\n\th2,\n\th3,\n\th4 {\n\t\tposition: relative;\n\t\tcolor: inherit;\n\t\tfont-style: inherit;\n\n\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n\t}\n\n\th1 {\n\t\tmargin-top: 0;\n\t\tmargin-bottom: 0.888889em;\n\t\tfont-size: 2.25em;\n\t\tfont-weight: 700;\n\t\tline-height: 1.11111;\n\t}\n\n\th2 {\n\t\tmargin-top: 2em;\n\t\tmargin-bottom: 1em;\n\t\tfont-size: 1.5em;\n\t\tfont-weight: 700;\n\t\tline-height: 1.33333;\n\t}\n\n\th3 {\n\t\tmargin-top: 1.6em;\n\t\tmargin-bottom: 0.6em;\n\t\tfont-size: 1.25em;\n\t\tfont-weight: 600;\n\t\tline-height: 1.6;\n\t}\n\n\th4 {\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 0.5em;\n\t\tfont-weight: 600;\n\t\tline-height: 1.5;\n\t}\n}\n"
    },
    {
      "path": "styles/horizontal-rule.css",
      "content": ".notra-editor {\n\thr {\n\t\tborder: none;\n\t\theight: 1px;\n\t\tbackground-color: var(--notra-hr);\n\t\tmargin-top: 2.25em;\n\t\tmargin-bottom: 2.25em;\n\t}\n}\n"
    },
    {
      "path": "styles/image.css",
      "content": ".notra-editor {\n\timg {\n\t\tmax-width: 100%;\n\t\theight: auto;\n\t\tdisplay: block;\n\t\tmargin: 2rem 0;\n\t\tborder-radius: 0.25rem;\n\t}\n}\n"
    },
    {
      "path": "styles/list.css",
      "content": ".notra-editor {\n\t--notra-checklist-bg: var(--notra-gray-a-100);\n\t--notra-checklist-bg-active: var(--notra-gray-a-900);\n\t--notra-checklist-border: var(--notra-gray-a-200);\n\t--notra-checklist-border-active: var(--notra-gray-a-900);\n\t--notra-checklist-check-icon: white;\n\t--notra-checklist-text-active: var(--notra-gray-a-500);\n}\n\n.dark .notra-editor,\n.notra-editor.dark {\n\t--notra-checklist-check-icon: black;\n}\n\n@media (prefers-color-scheme: dark) {\n\t.notra-editor:not(.light) {\n\t\t--notra-checklist-check-icon: black;\n\t}\n}\n\n.notra-editor {\n\tol,\n\tul {\n\t\tmargin-top: 1.5em;\n\t\tmargin-bottom: 1.5em;\n\t\tpadding-left: 1.5em;\n\n\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t&:last-child {\n\t\t\tmargin-bottom: 0;\n\t\t}\n\n\t\tol,\n\t\tul {\n\t\t\tmargin-top: 0;\n\t\t\tmargin-bottom: 0;\n\t\t}\n\t}\n\n\tli {\n\t\tp {\n\t\t\tmargin-top: 0;\n\t\t\tline-height: 1.6;\n\t\t}\n\t}\n\n\tol {\n\t\tlist-style: decimal;\n\n\t\tol {\n\t\t\tlist-style: lower-alpha;\n\n\t\t\tol {\n\t\t\t\tlist-style: lower-roman;\n\t\t\t}\n\t\t}\n\t}\n\n\tul:not([data-type='taskList']) {\n\t\tlist-style: disc;\n\n\t\tul {\n\t\t\tlist-style: circle;\n\n\t\t\tul {\n\t\t\t\tlist-style: square;\n\t\t\t}\n\t\t}\n\t}\n\n\tul[data-type='taskList'] {\n\t\tpadding-left: 0.25em;\n\n\t\tli {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\talign-items: flex-start;\n\n\t\t\t&:not(:has(> p:first-child)) {\n\t\t\t\tlist-style-type: none;\n\t\t\t}\n\n\t\t\t&[data-checked='true'] {\n\t\t\t\t> div > p {\n\t\t\t\t\topacity: 0.5;\n\t\t\t\t\ttext-decoration: line-through;\n\t\t\t\t}\n\n\t\t\t\t> div > p span {\n\t\t\t\t\ttext-decoration: line-through;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlabel {\n\t\t\t\tposition: relative;\n\t\t\t\tpadding-top: 0.375rem;\n\t\t\t\tpadding-right: 0.5rem;\n\n\t\t\t\tinput[type='checkbox'] {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\topacity: 0;\n\t\t\t\t\twidth: 0;\n\t\t\t\t\theight: 0;\n\t\t\t\t}\n\n\t\t\t\tspan {\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\twidth: 1em;\n\t\t\t\t\theight: 1em;\n\t\t\t\t\tborder: 1px solid var(--notra-checklist-border);\n\t\t\t\t\tborder-radius: 0.25rem;\n\t\t\t\t\tposition: relative;\n\t\t\t\t\tcursor: pointer;\n\t\t\t\t\tbackground-color: var(--notra-checklist-bg);\n\t\t\t\t\ttransition:\n\t\t\t\t\t\tbackground-color 80ms ease-out,\n\t\t\t\t\t\tborder-color 80ms ease-out;\n\n\t\t\t\t\t&::before {\n\t\t\t\t\t\tcontent: '';\n\t\t\t\t\t\tposition: absolute;\n\t\t\t\t\t\tleft: 50%;\n\t\t\t\t\t\ttop: 50%;\n\t\t\t\t\t\ttransform: translate(-50%, -50%);\n\t\t\t\t\t\twidth: 0.75em;\n\t\t\t\t\t\theight: 0.75em;\n\t\t\t\t\t\tbackground-color: var(--notra-checklist-check-icon);\n\t\t\t\t\t\topacity: 0;\n\t\t\t\t\t\tmask: url('data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22currentColor%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M21.4142%204.58579C22.1953%205.36683%2022.1953%206.63317%2021.4142%207.41421L10.4142%2018.4142C9.63317%2019.1953%208.36684%2019.1953%207.58579%2018.4142L2.58579%2013.4142C1.80474%2012.6332%201.80474%2011.3668%202.58579%2010.5858C3.36683%209.80474%204.63317%209.80474%205.41421%2010.5858L9%2014.1716L18.5858%204.58579C19.3668%203.80474%2020.6332%203.80474%2021.4142%204.58579Z%22%20fill%3D%22currentColor%22%2F%3E%3C%2Fsvg%3E')\n\t\t\t\t\t\t\tcenter / contain no-repeat;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinput[type='checkbox']:checked + span {\n\t\t\t\t\tbackground: var(--notra-checklist-bg-active);\n\t\t\t\t\tborder-color: var(--notra-checklist-border-active);\n\n\t\t\t\t\t&::before {\n\t\t\t\t\t\topacity: 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdiv {\n\t\t\t\tflex: 1 1 0%;\n\t\t\t\tmin-width: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
      "path": "styles/text.css",
      "content": ".notra-editor {\n\tp:not(:first-child) {\n\t\tfont-size: 1rem;\n\t\tline-height: 1.6;\n\t\tfont-weight: normal;\n\t\tmargin-top: 1.25em;\n\t}\n\n\tstrong {\n\t\tfont-weight: 700;\n\t}\n\n\tem {\n\t\tfont-style: italic;\n\t}\n\n\ta {\n\t\tcolor: var(--notra-link);\n\t\ttext-decoration: underline;\n\t}\n\n\ta span {\n\t\ttext-decoration: underline;\n\t}\n\n\ts span {\n\t\ttext-decoration: line-through;\n\t}\n\n\tu span {\n\t\ttext-decoration: underline;\n\t}\n}\n"
    },
    {
      "path": "styles/variables.css",
      "content": "/* Palette - override these to change the theme */\n.notra-editor {\n\t/* Gray alpha scale */\n\t--notra-gray-a-50: rgb(56 56 56 / 4%);\n\t--notra-gray-a-100: rgb(15 22 36 / 5%);\n\t--notra-gray-a-200: rgb(37 39 45 / 10%);\n\t--notra-gray-a-300: rgb(47 50 55 / 20%);\n\t--notra-gray-a-400: rgb(40 44 51 / 42%);\n\t--notra-gray-a-500: rgb(52 55 60 / 64%);\n\t--notra-gray-a-600: rgb(36 39 46 / 78%);\n\t--notra-gray-a-700: rgb(35 37 42 / 87%);\n\t--notra-gray-a-800: rgb(30 32 36 / 95%);\n\t--notra-gray-a-900: rgb(29 30 32 / 98%);\n\n\t/* Brand */\n\t--notra-brand-50: rgb(239 238 255);\n\t--notra-brand-100: rgb(222 219 255);\n\t--notra-brand-200: rgb(195 189 255);\n\t--notra-brand-300: rgb(157 138 255);\n\t--notra-brand-400: rgb(122 82 255);\n\t--notra-brand-500: rgb(98 41 255);\n\t--notra-brand-600: rgb(84 0 229);\n\t--notra-brand-700: rgb(75 0 204);\n\t--notra-brand-800: rgb(56 0 153);\n\t--notra-brand-900: rgb(43 25 102);\n\t--notra-brand-950: hsl(257deg 100% 9%);\n\n\t/* Semantic tokens */\n\t--notra-text: var(--notra-gray-a-900);\n\t--notra-link: var(--notra-brand-500);\n\t--notra-code-bg: var(--notra-gray-a-100);\n\t--notra-code-text: var(--notra-gray-a-700);\n\t--notra-code-border: var(--notra-gray-a-200);\n\t--notra-codeblock-bg: var(--notra-gray-a-50);\n\t--notra-codeblock-text: var(--notra-gray-a-800);\n\t--notra-codeblock-border: var(--notra-gray-a-200);\n\t--notra-blockquote-bar: var(--notra-gray-a-900);\n\t--notra-hr: var(--notra-gray-a-200);\n}\n\n/* Dark mode via .dark ancestor or class on editor itself */\n.dark .notra-editor,\n.notra-editor.dark {\n\t--notra-gray-a-50: rgb(232 232 253 / 5%);\n\t--notra-gray-a-100: rgb(231 231 243 / 7%);\n\t--notra-gray-a-200: rgb(238 238 246 / 11%);\n\t--notra-gray-a-300: rgb(239 239 245 / 22%);\n\t--notra-gray-a-400: rgb(244 244 255 / 37%);\n\t--notra-gray-a-500: rgb(236 238 253 / 50%);\n\t--notra-gray-a-600: rgb(247 247 253 / 64%);\n\t--notra-gray-a-700: rgb(251 251 254 / 75%);\n\t--notra-gray-a-800: rgb(253 253 253 / 88%);\n\t--notra-gray-a-900: rgb(255 255 255 / 96%);\n\t--notra-link: var(--notra-brand-400);\n}\n\n/* Dark mode via system preference (opt-out with .light class) */\n@media (prefers-color-scheme: dark) {\n\t.notra-editor:not(.light) {\n\t\t--notra-gray-a-50: rgb(232 232 253 / 5%);\n\t\t--notra-gray-a-100: rgb(231 231 243 / 7%);\n\t\t--notra-gray-a-200: rgb(238 238 246 / 11%);\n\t\t--notra-gray-a-300: rgb(239 239 245 / 22%);\n\t\t--notra-gray-a-400: rgb(244 244 255 / 37%);\n\t\t--notra-gray-a-500: rgb(236 238 253 / 50%);\n\t\t--notra-gray-a-600: rgb(247 247 253 / 64%);\n\t\t--notra-gray-a-700: rgb(251 251 254 / 75%);\n\t\t--notra-gray-a-800: rgb(253 253 253 / 88%);\n\t\t--notra-gray-a-900: rgb(255 255 255 / 96%);\n\t\t--notra-link: var(--notra-brand-400);\n\t}\n}\n"
    },
    {
      "path": "ui/blockquote-button.tsx",
      "content": "import { useEditorState } from '@tiptap/react';\nimport * as React from 'react';\n\nimport { canToggleBlockquote, useBlockquote } from '../hooks/use-blockquote';\nimport { useNotraEditor } from '../hooks/use-notra-editor';\nimport { Button } from './primitives/button';\n\nexport function BlockquoteButton() {\n\tconst { editor } = useNotraEditor();\n\n\tconst { isVisible, handleToggle, label, Icon } = useBlockquote({\n\t\teditor\n\t});\n\n\tconst editorState = useEditorState({\n\t\teditor,\n\t\tselector: (ctx) => ({\n\t\t\tcanToggle: canToggleBlockquote(ctx.editor),\n\t\t\tisActive: ctx.editor?.isActive('blockquote') ?? false\n\t\t})\n\t});\n\n\tconst canToggle = editorState?.canToggle ?? false;\n\tconst isActive = editorState?.isActive ?? false;\n\n\tconst handleClick = React.useCallback(\n\t\t(event: React.MouseEvent<HTMLButtonElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canToggle}\n\t\t\tisActive={isActive}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleClick}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/fixed-toolbar.tsx",
      "content": "import { BlockquoteButton } from './blockquote-button';\nimport { HeadingDropdownMenu } from './heading-dropdown-menu';\nimport { ListDropdownMenu } from './list-dropdown-menu';\nimport { MarkButton } from './mark-button';\nimport { Separator } from './primitives/separator';\nimport { Spacer } from './primitives/spacer';\nimport { UndoRedoButton } from './undo-redo-button';\nimport { cn } from '../lib/utils';\n\nfunction ToolbarGroup({ children }: { children: React.ReactNode }) {\n\treturn <div className=\"flex items-center gap-0.5\">{children}</div>;\n}\n\nfunction ToolbarSeparator() {\n\treturn <Separator className=\"!h-6\" orientation=\"vertical\" />;\n}\n\nexport interface FixedToolbarProps {\n\tclassName?: string;\n}\n\nexport function FixedToolbar({ className }: FixedToolbarProps) {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t'h-11 flex items-center gap-1 overflow-x-auto px-2 border-b',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t>\n\t\t\t<Spacer />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<UndoRedoButton action=\"undo\" />\n\t\t\t\t<UndoRedoButton action=\"redo\" />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<HeadingDropdownMenu />\n\t\t\t\t<ListDropdownMenu />\n\t\t\t\t<BlockquoteButton />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<ToolbarSeparator />\n\n\t\t\t<ToolbarGroup>\n\t\t\t\t<MarkButton type=\"bold\" />\n\t\t\t\t<MarkButton type=\"italic\" />\n\t\t\t\t<MarkButton type=\"underline\" />\n\t\t\t\t<MarkButton type=\"strike\" />\n\t\t\t\t<MarkButton type=\"code\" />\n\t\t\t</ToolbarGroup>\n\n\t\t\t<Spacer />\n\t\t</div>\n\t);\n}\n"
    },
    {
      "path": "ui/heading-button.tsx",
      "content": "import * as React from 'react';\n\nimport { DropdownMenuItem } from './primitives/dropdown-menu';\nimport { useHeading } from '../hooks/use-heading';\n\nimport type { Level } from '../hooks/use-heading';\n\nexport interface HeadingButtonProps {\n\tlevel: Level;\n}\n\nexport function HeadingButton({ level }: HeadingButtonProps) {\n\tconst { isVisible, handleToggle, Icon, label } = useHeading({ level });\n\n\tconst handleClick = React.useCallback(\n\t\t(event: React.MouseEvent<HTMLDivElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenuItem onClick={handleClick}>\n\t\t\t<Icon className=\"text-popover-foreground\" />\n\t\t\t{label}\n\t\t</DropdownMenuItem>\n\t);\n}\n"
    },
    {
      "path": "ui/heading-dropdown-menu.tsx",
      "content": "import { ChevronDown } from 'lucide-react';\n\nimport { HeadingButton } from './heading-button';\nimport { useHeadingDropdownMenu } from '../hooks/use-heading-dropdown-menu';\nimport { useTranslation } from '../i18n';\nimport { Button } from './primitives/button';\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuTrigger\n} from './primitives/dropdown-menu';\n\nexport function HeadingDropdownMenu() {\n\tconst dictionary = useTranslation();\n\tconst { isVisible, isActive, canToggle, Icon, levels } =\n\t\tuseHeadingDropdownMenu({\n\t\t\tlevels: [1, 2, 3, 4, 5, 6]\n\t\t});\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\taria-label={dictionary['heading.dropdown.ariaLabel']}\n\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\tdata-active-state={isActive ? 'on' : 'off'}\n\t\t\t\t\tdata-disabled={!canToggle}\n\t\t\t\t\tdata-style=\"ghost\"\n\t\t\t\t\tdisabled={!canToggle}\n\t\t\t\t\tisActive={isActive}\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t>\n\t\t\t\t\t<Icon />\n\t\t\t\t\t<ChevronDown className=\"size-2.5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\n\t\t\t<DropdownMenuContent\n\t\t\t\talign=\"start\"\n\t\t\t\tonCloseAutoFocus={(e) => e.preventDefault()}\n\t\t\t>\n\t\t\t\t{levels.map((level) => (\n\t\t\t\t\t<HeadingButton key={`heading-${level}`} level={level} />\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n"
    },
    {
      "path": "ui/list-button.tsx",
      "content": "import * as React from 'react';\n\nimport { DropdownMenuItem } from './primitives/dropdown-menu';\nimport { useList } from '../hooks/use-list';\n\nimport type { ListType } from '../hooks/use-list';\n\nexport interface ListButtonProps {\n\ttype: ListType;\n}\n\nexport function ListButton({ type }: ListButtonProps) {\n\tconst { isVisible, handleToggle, Icon, label } = useList({ type });\n\n\tconst handleClick = React.useCallback(\n\t\t(event: React.MouseEvent<HTMLDivElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleToggle();\n\t\t},\n\t\t[handleToggle]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenuItem onClick={handleClick}>\n\t\t\t<Icon className=\"text-popover-foreground\" />\n\t\t\t{label}\n\t\t</DropdownMenuItem>\n\t);\n}\n"
    },
    {
      "path": "ui/list-dropdown-menu.tsx",
      "content": "import { ChevronDown } from 'lucide-react';\n\nimport { ListButton } from './list-button';\nimport { useListDropdownMenu } from '../hooks/use-list-dropdown-menu';\nimport { useTranslation } from '../i18n';\nimport { Button } from './primitives/button';\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuTrigger\n} from './primitives/dropdown-menu';\n\nexport function ListDropdownMenu() {\n\tconst dictionary = useTranslation();\n\tconst { isVisible, isActive, canToggle, Icon, filteredLists } =\n\t\tuseListDropdownMenu();\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<Button\n\t\t\t\t\taria-label={dictionary['list.dropdown.ariaLabel']}\n\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\tdata-active-state={isActive ? 'on' : 'off'}\n\t\t\t\t\tdata-disabled={!canToggle}\n\t\t\t\t\tdata-style=\"ghost\"\n\t\t\t\t\tdisabled={!canToggle}\n\t\t\t\t\tisActive={isActive}\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t>\n\t\t\t\t\t<Icon />\n\t\t\t\t\t<ChevronDown className=\"size-2.5\" />\n\t\t\t\t</Button>\n\t\t\t</DropdownMenuTrigger>\n\n\t\t\t<DropdownMenuContent\n\t\t\t\talign=\"start\"\n\t\t\t\tonCloseAutoFocus={(e) => e.preventDefault()}\n\t\t\t>\n\t\t\t\t{filteredLists.map((list) => (\n\t\t\t\t\t<ListButton key={list.type} type={list.type} />\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n"
    },
    {
      "path": "ui/mark-button.tsx",
      "content": "import { useEditorState } from '@tiptap/react';\nimport * as React from 'react';\n\nimport { canToggleMark, isMarkActive, useMark } from '../hooks/use-mark';\nimport { useNotraEditor } from '../hooks/use-notra-editor';\nimport { Button } from './primitives/button';\n\nimport type { MarkType } from '../hooks/use-mark';\n\nexport interface MarkButtonProps {\n\ttype: MarkType;\n}\n\nexport function MarkButton({ type }: MarkButtonProps) {\n\tconst { editor } = useNotraEditor();\n\n\tconst { isVisible, handleMark, label, Icon } = useMark({\n\t\teditor,\n\t\ttype\n\t});\n\n\tconst editorState = useEditorState({\n\t\teditor,\n\t\tselector: (ctx) => ({\n\t\t\tcanToggle: canToggleMark(ctx.editor, type),\n\t\t\tisActive: isMarkActive(ctx.editor, type)\n\t\t})\n\t});\n\n\tconst canToggle = editorState?.canToggle ?? false;\n\tconst isActive = editorState?.isActive ?? false;\n\n\tconst handleClick = React.useCallback(\n\t\t(event: React.MouseEvent<HTMLButtonElement>) => {\n\t\t\tif (event.defaultPrevented) return;\n\n\t\t\thandleMark();\n\t\t},\n\t\t[handleMark]\n\t);\n\n\tif (!isVisible) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Button\n\t\t\taria-label={label}\n\t\t\tdisabled={!canToggle}\n\t\t\tisActive={isActive}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={handleClick}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/primitives/button.tsx",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\nimport { Slot } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nconst buttonVariants = cva(\n\t\"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n\t{\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: 'bg-primary text-primary-foreground hover:bg-primary/90',\n\t\t\t\tdestructive:\n\t\t\t\t\t'bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n\t\t\t\toutline:\n\t\t\t\t\t'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',\n\t\t\t\tsecondary:\n\t\t\t\t\t'bg-secondary text-secondary-foreground hover:bg-secondary/80',\n\t\t\t\tghost:\n\t\t\t\t\t'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',\n\t\t\t\tlink: 'text-primary underline-offset-4 hover:underline'\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tdefault: 'h-9 px-4 py-2 has-[>svg]:px-3',\n\t\t\t\txs: 'h-7 gap-0 px-1.5',\n\t\t\t\tsm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',\n\t\t\t\tlg: 'h-10 rounded-md px-6 has-[>svg]:px-4',\n\t\t\t\ticon: 'size-9',\n\t\t\t\t'icon-xs': 'size-7',\n\t\t\t\t'icon-sm': 'size-8',\n\t\t\t\t'icon-lg': 'size-10'\n\t\t\t},\n\t\t\tisActive: {\n\t\t\t\ttrue: 'bg-accent text-accent-foreground dark:bg-accent/50'\n\t\t\t}\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: 'default',\n\t\t\tsize: 'default'\n\t\t}\n\t}\n);\n\nfunction Button({\n\tclassName,\n\tvariant = 'default',\n\tsize = 'default',\n\tasChild = false,\n\tisActive = false,\n\t...props\n}: Readonly<React.ComponentProps<'button'>> &\n\tVariantProps<typeof buttonVariants> & {\n\t\tasChild?: boolean;\n\t}) {\n\tconst Comp = asChild ? Slot.Root : 'button';\n\n\treturn (\n\t\t<Comp\n\t\t\tclassName={cn(buttonVariants({ variant, size, className, isActive }))}\n\t\t\tdata-size={size}\n\t\t\tdata-slot=\"button\"\n\t\t\tdata-variant={variant}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport { Button, buttonVariants };\n"
    },
    {
      "path": "ui/primitives/dropdown-menu.tsx",
      "content": "import { DropdownMenu as DropdownMenuPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction DropdownMenu({\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {\n\treturn <DropdownMenuPrimitive.Root data-slot=\"dropdown-menu\" {...props} />;\n}\n\nfunction DropdownMenuTrigger({\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Trigger\n\t\t\tdata-slot=\"dropdown-menu-trigger\"\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nfunction DropdownMenuContent({\n\tclassName,\n\tsideOffset = 4,\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Portal>\n\t\t\t<DropdownMenuPrimitive.Content\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',\n\t\t\t\t\tclassName\n\t\t\t\t)}\n\t\t\t\tdata-slot=\"dropdown-menu-content\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</DropdownMenuPrimitive.Portal>\n\t);\n}\n\nfunction DropdownMenuItem({\n\tclassName,\n\tinset,\n\tvariant = 'default',\n\t...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {\n\tinset?: boolean;\n\tvariant?: 'default' | 'destructive';\n}) {\n\treturn (\n\t\t<DropdownMenuPrimitive.Item\n\t\t\tclassName={cn(\n\t\t\t\t\"focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-inset={inset}\n\t\t\tdata-slot=\"dropdown-menu-item\"\n\t\t\tdata-variant={variant}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport {\n\tDropdownMenu,\n\tDropdownMenuTrigger,\n\tDropdownMenuContent,\n\tDropdownMenuItem\n};\n"
    },
    {
      "path": "ui/primitives/separator.tsx",
      "content": "import { Separator as SeparatorPrimitive } from 'radix-ui';\nimport * as React from 'react';\n\nimport { cn } from '../../lib/utils';\n\nfunction Separator({\n\tclassName,\n\torientation = 'horizontal',\n\tdecorative = true,\n\t...props\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\n\treturn (\n\t\t<SeparatorPrimitive.Root\n\t\t\tclassName={cn(\n\t\t\t\t'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tdata-slot=\"separator\"\n\t\t\tdecorative={decorative}\n\t\t\torientation={orientation}\n\t\t\t{...props}\n\t\t/>\n\t);\n}\n\nexport { Separator };\n"
    },
    {
      "path": "ui/primitives/spacer.tsx",
      "content": "import * as React from 'react';\n\nexport type SpacerOrientation = 'horizontal' | 'vertical';\n\nexport interface SpacerProps extends React.HTMLAttributes<HTMLDivElement> {\n\torientation?: SpacerOrientation;\n\tsize?: string | number;\n}\n\nexport function Spacer({\n\torientation = 'horizontal',\n\tsize,\n\tstyle = {},\n\t...props\n}: SpacerProps) {\n\tconst computedStyle = {\n\t\t...style,\n\t\t...(orientation === 'horizontal' && !size && { flex: 1 }),\n\t\t...(size && {\n\t\t\twidth: orientation === 'vertical' ? '1px' : size,\n\t\t\theight: orientation === 'horizontal' ? '1px' : size\n\t\t})\n\t};\n\n\treturn <div {...props} style={computedStyle} />;\n}\n"
    },
    {
      "path": "ui/undo-redo-button.tsx",
      "content": "import { useEditorState } from '@tiptap/react';\nimport { Redo2, Undo2 } from 'lucide-react';\n\nimport { useNotraEditor } from '../hooks/use-notra-editor';\nimport { Button } from './primitives/button';\n\nimport type { Editor } from '@tiptap/core';\n\nexport interface UndoRedoButtonProps {\n\taction: 'undo' | 'redo';\n}\n\nexport function canExecuteAction(\n\teditor: Editor | null,\n\taction: 'undo' | 'redo'\n): boolean {\n\tif (!editor || !editor.isEditable) return false;\n\n\treturn action === 'undo' ? editor.can().undo() : editor.can().redo();\n}\n\nexport function executeAction(\n\teditor: Editor | null,\n\taction: 'undo' | 'redo'\n): boolean {\n\tif (!editor || !canExecuteAction(editor, action)) return false;\n\n\tconst chain = editor.chain().focus();\n\n\treturn action === 'undo' ? chain.undo().run() : chain.redo().run();\n}\n\nexport function UndoRedoButton({ action }: UndoRedoButtonProps) {\n\tconst { editor } = useNotraEditor();\n\n\tconst canExecute = useEditorState({\n\t\teditor,\n\t\tselector: (ctx) => canExecuteAction(ctx.editor, action)\n\t});\n\n\tconst Icon = action === 'undo' ? Undo2 : Redo2;\n\n\treturn (\n\t\t<Button\n\t\t\tdisabled={!canExecute}\n\t\t\tsize=\"icon-xs\"\n\t\t\tvariant=\"ghost\"\n\t\t\tonClick={() => executeAction(editor, action)}\n\t\t>\n\t\t\t<Icon size={16} />\n\t\t</Button>\n\t);\n}\n"
    },
    {
      "path": "ui/__tests__/spacer.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test } from 'vitest';\n\nimport type { SpacerOrientation } from '../primitives/spacer';\n\n// Replicate the pure style computation from Spacer component\nfunction computeSpacerStyle(\n\torientation: SpacerOrientation = 'horizontal',\n\tsize: string | number | undefined,\n\tstyle: React.CSSProperties = {}\n): React.CSSProperties {\n\treturn {\n\t\t...style,\n\t\t...(orientation === 'horizontal' && !size && { flex: 1 }),\n\t\t...(size && {\n\t\t\twidth: orientation === 'vertical' ? '1px' : size,\n\t\t\theight: orientation === 'horizontal' ? '1px' : size\n\t\t})\n\t};\n}\n\n// ── Generators ───────────────────────────────────────────────────────\n\nconst orientationArbitrary: fc.Arbitrary<SpacerOrientation> = fc.constantFrom(\n\t'horizontal' as const,\n\t'vertical' as const\n);\n\nconst sizeArbitrary: fc.Arbitrary<string | number | undefined> = fc.oneof(\n\tfc.constant(undefined),\n\tfc.integer({ min: 1, max: 1000 }),\n\tfc.constantFrom('10px', '2rem', '50%', '1.5em', '100vh')\n);\n\n// ── Property 1: Spacer 样式计算正确性 ────────────────────────────────\n\ndescribe('Feature: toolbar-components, Property 1: Spacer 样式计算正确性', () => {\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('horizontal + no size → style contains flex: 1', () => {\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\tfc.constant('horizontal' as SpacerOrientation),\n\t\t\t\tfc.constant(undefined),\n\t\t\t\t(orientation, size) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\t\texpect(result).toHaveProperty('flex', 1);\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('when size is provided, horizontal sets width=size and height=1px; vertical sets width=1px and height=size', () => {\n\t\tconst definedSizeArbitrary: fc.Arbitrary<string | number> = fc.oneof(\n\t\t\tfc.integer({ min: 1, max: 1000 }),\n\t\t\tfc.constantFrom('10px', '2rem', '50%', '1.5em', '100vh')\n\t\t);\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\torientationArbitrary,\n\t\t\t\tdefinedSizeArbitrary,\n\t\t\t\t(orientation, size) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\n\t\t\t\t\tif (orientation === 'horizontal') {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', size);\n\t\t\t\t\t\texpect(result).toHaveProperty('height', '1px');\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', '1px');\n\t\t\t\t\t\texpect(result).toHaveProperty('height', size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('for any orientation and size combination, computed style satisfies all Spacer invariants', () => {\n\t\tfc.assert(\n\t\t\tfc.property(orientationArbitrary, sizeArbitrary, (orientation, size) => {\n\t\t\t\tconst result = computeSpacerStyle(orientation, size);\n\n\t\t\t\tif (orientation === 'horizontal' && !size) {\n\t\t\t\t\t// Req 1.2: flex: 1 when horizontal and no size\n\t\t\t\t\texpect(result).toHaveProperty('flex', 1);\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t} else if (size) {\n\t\t\t\t\t// Req 1.3: size applied as width/height based on orientation\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\n\t\t\t\t\tif (orientation === 'horizontal') {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', size);\n\t\t\t\t\t\texpect(result).toHaveProperty('height', '1px');\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(result).toHaveProperty('width', '1px');\n\t\t\t\t\t\texpect(result).toHaveProperty('height', size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// vertical + no size: no special styles\n\t\t\t\t\texpect(result).not.toHaveProperty('flex');\n\t\t\t\t\texpect(result).not.toHaveProperty('width');\n\t\t\t\t\texpect(result).not.toHaveProperty('height');\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 200 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 1.2, 1.3**\n\t */\n\ttest('user-provided style properties are preserved in computed style', () => {\n\t\tconst userStyleArbitrary = fc.record({\n\t\t\tcolor: fc.constantFrom('red', 'blue', 'green'),\n\t\t\tmargin: fc.constantFrom('4px', '8px', '16px')\n\t\t});\n\n\t\tfc.assert(\n\t\t\tfc.property(\n\t\t\t\torientationArbitrary,\n\t\t\t\tsizeArbitrary,\n\t\t\t\tuserStyleArbitrary,\n\t\t\t\t(orientation, size, userStyle) => {\n\t\t\t\t\tconst result = computeSpacerStyle(orientation, size, userStyle);\n\n\t\t\t\t\t// User-provided styles should always be present\n\t\t\t\t\texpect(result).toHaveProperty('color', userStyle.color);\n\t\t\t\t\texpect(result).toHaveProperty('margin', userStyle.margin);\n\t\t\t\t}\n\t\t\t),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "ui/__tests__/undo-redo-button.test.ts",
      "content": "import * as fc from 'fast-check';\nimport { describe, expect, test, vi } from 'vitest';\n\nimport { canExecuteAction, executeAction } from '../undo-redo-button';\n\n// Minimal mock that satisfies the subset of Editor used by canExecuteAction\ninterface MockEditor {\n\tisEditable: boolean;\n\tcan: () => { undo: () => boolean; redo: () => boolean };\n}\n\ntype EditorState =\n\t| { type: 'null' }\n\t| { type: 'not-editable' }\n\t| { type: 'editable'; canUndo: boolean; canRedo: boolean };\n\nconst editorStateArbitrary: fc.Arbitrary<EditorState> = fc.oneof(\n\tfc.constant<EditorState>({ type: 'null' }),\n\tfc.constant<EditorState>({ type: 'not-editable' }),\n\tfc.record<EditorState & { type: 'editable' }>({\n\t\ttype: fc.constant('editable' as const),\n\t\tcanUndo: fc.boolean(),\n\t\tcanRedo: fc.boolean()\n\t})\n);\n\nconst actionArbitrary: fc.Arbitrary<'undo' | 'redo'> = fc.constantFrom(\n\t'undo' as const,\n\t'redo' as const\n);\n\nfunction buildMockEditor(state: EditorState): MockEditor | null {\n\tif (state.type === 'null') return null;\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\tisEditable: false,\n\t\t\tcan: () => ({ undo: () => false, redo: () => false })\n\t\t};\n\t}\n\n\treturn {\n\t\tisEditable: true,\n\t\tcan: () => ({\n\t\t\tundo: () => state.canUndo,\n\t\t\tredo: () => state.canRedo\n\t\t})\n\t};\n}\n\nfunction expectedResult(state: EditorState, action: 'undo' | 'redo'): boolean {\n\tif (state.type === 'null' || state.type === 'not-editable') return false;\n\n\treturn action === 'undo' ? state.canUndo : state.canRedo;\n}\n\ndescribe('Feature: fixed-toolbar, Property 1: canExecuteAction 正确反映编辑器能力', () => {\n\t/**\n\t * **Validates: Requirements 3.7, 3.8, 4.3**\n\t */\n\ttest('Property 1: canExecuteAction returns true iff editor is non-null, editable, and has matching history', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst editor = buildMockEditor(state);\n\t\t\t\t// Cast to satisfy the Editor type parameter without importing the full Tiptap dependency\n\t\t\t\tconst result = canExecuteAction(editor as never, action);\n\n\t\t\t\texpect(result).toBe(expectedResult(state, action));\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n\n// Extended mock that also tracks chain().focus().undo()/redo().run() calls\ninterface MockEditorWithChain {\n\tisEditable: boolean;\n\tcan: () => { undo: () => boolean; redo: () => boolean };\n\tchain: () => {\n\t\tfocus: () => {\n\t\t\tundo: () => { run: () => boolean };\n\t\t\tredo: () => { run: () => boolean };\n\t\t};\n\t};\n}\n\nfunction buildMockEditorWithChain(state: EditorState): {\n\teditor: MockEditorWithChain | null;\n\tspies: { undo: ReturnType<typeof vi.fn>; redo: ReturnType<typeof vi.fn> };\n} {\n\tconst undoRunSpy = vi.fn(() => true);\n\tconst redoRunSpy = vi.fn(() => true);\n\tconst spies = { undo: undoRunSpy, redo: redoRunSpy };\n\n\tif (state.type === 'null') return { editor: null, spies };\n\n\tif (state.type === 'not-editable') {\n\t\treturn {\n\t\t\teditor: {\n\t\t\t\tisEditable: false,\n\t\t\t\tcan: () => ({ undo: () => false, redo: () => false }),\n\t\t\t\tchain: () => ({\n\t\t\t\t\tfocus: () => ({\n\t\t\t\t\t\tundo: () => ({ run: undoRunSpy }),\n\t\t\t\t\t\tredo: () => ({ run: redoRunSpy })\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\tspies\n\t\t};\n\t}\n\n\treturn {\n\t\teditor: {\n\t\t\tisEditable: true,\n\t\t\tcan: () => ({\n\t\t\t\tundo: () => state.canUndo,\n\t\t\t\tredo: () => state.canRedo\n\t\t\t}),\n\t\t\tchain: () => ({\n\t\t\t\tfocus: () => ({\n\t\t\t\t\tundo: () => ({ run: undoRunSpy }),\n\t\t\t\t\tredo: () => ({ run: redoRunSpy })\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\t\tspies\n\t};\n}\n\ndescribe('Feature: fixed-toolbar, Property 2: executeAction 安全性', () => {\n\t/**\n\t * **Validates: Requirements 3.5, 3.6**\n\t */\n\ttest('Property 2: when canExecuteAction is false, executeAction returns false and calls no commands', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst { editor, spies } = buildMockEditorWithChain(state);\n\t\t\t\tconst canExecute = canExecuteAction(editor as never, action);\n\n\t\t\t\tif (!canExecute) {\n\t\t\t\t\tconst result = executeAction(editor as never, action);\n\n\t\t\t\t\texpect(result).toBe(false);\n\t\t\t\t\texpect(spies.undo).not.toHaveBeenCalled();\n\t\t\t\t\texpect(spies.redo).not.toHaveBeenCalled();\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n\n\t/**\n\t * **Validates: Requirements 3.5, 3.6**\n\t */\n\ttest('Property 2: when canExecuteAction is true, executeAction calls the corresponding command', () => {\n\t\tfc.assert(\n\t\t\tfc.property(editorStateArbitrary, actionArbitrary, (state, action) => {\n\t\t\t\tconst { editor, spies } = buildMockEditorWithChain(state);\n\t\t\t\tconst canExecute = canExecuteAction(editor as never, action);\n\n\t\t\t\tif (canExecute) {\n\t\t\t\t\tconst result = executeAction(editor as never, action);\n\n\t\t\t\t\texpect(result).toBe(true);\n\n\t\t\t\t\tif (action === 'undo') {\n\t\t\t\t\t\texpect(spies.undo).toHaveBeenCalledOnce();\n\t\t\t\t\t\texpect(spies.redo).not.toHaveBeenCalled();\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpect(spies.redo).toHaveBeenCalledOnce();\n\t\t\t\t\t\texpect(spies.undo).not.toHaveBeenCalled();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t{ numRuns: 100 }\n\t\t);\n\t});\n});\n"
    },
    {
      "path": "vitest.config.ts",
      "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n\ttest: {\n\t\tinclude: [\n\t\t\t'ui/__tests__/**/*.test.ts',\n\t\t\t'lib/__tests__/**/*.test.ts',\n\t\t\t'hooks/__tests__/**/*.test.ts',\n\t\t\t'i18n/__tests__/**/*.test.ts'\n\t\t],\n\t\ttestTimeout: 30000\n\t}\n});\n"
    }
  ],
  "dependencies": [
    {
      "name": "@tiptap/core",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-horizontal-rule",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-task-item",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-task-list",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/extension-underline",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/pm",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/react",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/starter-kit",
      "version": "3.19.0"
    },
    {
      "name": "@tiptap/static-renderer",
      "version": "3.19.0"
    },
    {
      "name": "class-variance-authority",
      "version": "0.7.1"
    },
    {
      "name": "clsx",
      "version": "2.1.1"
    },
    {
      "name": "lucide-react",
      "version": "0.511.0"
    },
    {
      "name": "radix-ui",
      "version": "1.4.2"
    },
    {
      "name": "tailwind-merge",
      "version": "3.3.0"
    }
  ]
}